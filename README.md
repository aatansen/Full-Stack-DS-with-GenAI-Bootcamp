<div align="center">
<h1>Full Stack DS with GenAI Bootcamp</h1>

> *Notes, Assignments of Full Stack DS with GenAI Bootcamp*
</div>

# **Context**
- [**Context**](#context)
- [**Day 01 - Induction Session**](#day-01---induction-session)
  - [**Session and Overview**](#session-and-overview)
    - [Introduction](#introduction)
- [**Day 02 - Introduction to AI \& System Setup**](#day-02---introduction-to-ai--system-setup)
  - [**Introduction to AI**](#introduction-to-ai)
    - [What is AI?](#what-is-ai)
    - [What is Data Science?](#what-is-data-science)
    - [Career Opportunities](#career-opportunities)
    - [Importance of DS](#importance-of-ds)
    - [Application of AI](#application-of-ai)
    - [Venn Diagram](#venn-diagram)
    - [AI Project Development Life Cycle](#ai-project-development-life-cycle)
    - [Different Roles in AI](#different-roles-in-ai)
  - [**System Setup Tools**](#system-setup-tools)
- [**Day 03 - Introduction And Basic Of Python**](#day-03---introduction-and-basic-of-python)
  - [**Introduction to Python \& Setup**](#introduction-to-python--setup)
  - [**Write our first Program in Python**](#write-our-first-program-in-python)
    - [print() Function Parameters in Python](#print-function-parameters-in-python)
  - [**Operators in Python**](#operators-in-python)
  - [**Python Data Types \& Comments**](#python-data-types--comments)
  - [**Variables, Keywords \& Identifiers in Python**](#variables-keywords--identifiers-in-python)
    - [Variables](#variables)
    - [Keywords](#keywords)
    - [Identifiers](#identifiers)
  - [**Python Input**](#python-input)
  - [**Type Conversion in Python**](#type-conversion-in-python)
  - [**Literals in Python**](#literals-in-python)
- [**Day 04 - Conditional Statements, Pip, Modules \& Loops**](#day-04---conditional-statements-pip-modules--loops)
  - [**Conditional Statements**](#conditional-statements)
  - [**PIP (Pip Installs Packages)**](#pip-pip-installs-packages)
  - [**Modules in Python**](#modules-in-python)
  - [**Loops in Python**](#loops-in-python)
- [**Assignment 01**](#assignment-01)
- [**Day 05 - Loops in Python**](#day-05---loops-in-python)
  - [**Loops Recap**](#loops-recap)
  - [**Loop Control Statements**](#loop-control-statements)
  - [**Code Visualization Tool**](#code-visualization-tool)
- [**Day 06 - Strings in Python**](#day-06---strings-in-python)
  - [**Strings in Python**](#strings-in-python)
    - [Creating Strings](#creating-strings)
    - [Accessing Strings](#accessing-strings)
    - [Adding Chars to Strings](#adding-chars-to-strings)
    - [Editing Strings](#editing-strings)
    - [Deleting Strings](#deleting-strings)
    - [Operations on Strings](#operations-on-strings)
    - [String Functions](#string-functions)
    - [String Methods](#string-methods)
  - [**Strings Exercise**](#strings-exercise)
    - [Find the length of a given string without using the len() function](#find-the-length-of-a-given-string-without-using-the-len-function)
    - [Extract username from a given email](#extract-username-from-a-given-email)
- [**Day 07 - List in Python**](#day-07---list-in-python)
  - [**List in Python**](#list-in-python)
    - [What are Lists?](#what-are-lists)
    - [Lists Vs Arrays](#lists-vs-arrays)
    - [Characteristics of a List](#characteristics-of-a-list)
    - [How to create a list](#how-to-create-a-list)
    - [Access items from a List](#access-items-from-a-list)
    - [List Methods](#list-methods)
    - [List Functions](#list-functions)
    - [Editing items in a List](#editing-items-in-a-list)
    - [Deleting items from a List](#deleting-items-from-a-list)
    - [Operations on Lists](#operations-on-lists)
    - [List comprehension](#list-comprehension)
    - [`zip()` Function in Python](#zip-function-in-python)
- [**Assignment 02**](#assignment-02)
- [**Day 08 - Tuples, Sets \& Dictionary**](#day-08---tuples-sets--dictionary)
  - [**Tuples**](#tuples)
    - [Creating a Tuple](#creating-a-tuple)
    - [Accessing Items in Tuple](#accessing-items-in-tuple)
    - [Editing Items in Tuple](#editing-items-in-tuple)
    - [Adding Items in Tuple](#adding-items-in-tuple)
    - [Deleting Items in Tuple](#deleting-items-in-tuple)
    - [Operations on Tuples](#operations-on-tuples)
    - [Tuple Methods](#tuple-methods)
    - [Tuple Functions](#tuple-functions)
    - [Tuple Unpacking](#tuple-unpacking)
    - [Using `zip()` with Tuples](#using-zip-with-tuples)
    - [Tuple Comprehension](#tuple-comprehension)
    - [List vs Tuple](#list-vs-tuple)
  - [**Sets**](#sets)
    - [Creating a Set](#creating-a-set)
    - [Accessing Items in Set](#accessing-items-in-set)
    - [Editing Items in Set](#editing-items-in-set)
    - [Adding Items in Set](#adding-items-in-set)
    - [Deleting Items in Set](#deleting-items-in-set)
    - [Operations on Set](#operations-on-set)
    - [Set Methods](#set-methods)
    - [Set Functions](#set-functions)
    - [Frozenset in Python](#frozenset-in-python)
    - [Set Comprehension](#set-comprehension)
    - [Using `zip()` with Sets](#using-zip-with-sets)
  - [**Dictionary**](#dictionary)
    - [Creating a Dictionary](#creating-a-dictionary)
    - [Accessing Items in Dictionary](#accessing-items-in-dictionary)
    - [Editing Items in Dictionary](#editing-items-in-dictionary)
    - [Adding Items in Dictionary](#adding-items-in-dictionary)
    - [Deleting Items in Dictionary](#deleting-items-in-dictionary)
    - [Operations on Dictionary](#operations-on-dictionary)
    - [Dictionary Methods](#dictionary-methods)
    - [Dictionary Functions](#dictionary-functions)
    - [Dictionary Unpacking](#dictionary-unpacking)
    - [Using `zip()` with Dictionary](#using-zip-with-dictionary)
    - [Dictionary Comprehension](#dictionary-comprehension)
    - [Simple Project Using Dictionary](#simple-project-using-dictionary)
- [**Day 09 - Functions in Python**](#day-09---functions-in-python)
  - [**Functions in Python**](#functions-in-python)
    - [Characteristics of Function](#characteristics-of-function)
    - [Creating a Function](#creating-a-function)
    - [Parameter vs Argument](#parameter-vs-argument)
    - [Types of Arguments](#types-of-arguments)
    - [`*args` vs `**kwargs`](#args-vs-kwargs)
    - [Variable Scope in Functions](#variable-scope-in-functions)
    - [Nested Functions](#nested-functions)
    - [Functions are First-Class Citizens](#functions-are-first-class-citizens)
    - [Benefits of Using a Function](#benefits-of-using-a-function)
    - [Lambda Function](#lambda-function)
    - [Lambda vs Normal Function](#lambda-vs-normal-function)
    - [Higher-Order Functions](#higher-order-functions)
    - [`enumerate()` Function](#enumerate-function)
- [**Day 10 - Virtual Environment \& Requirements**](#day-10---virtual-environment--requirements)
  - [**Virtual Environment**](#virtual-environment)
    - [Create Conda Environment](#create-conda-environment)
    - [List and Remove Conda Environments](#list-and-remove-conda-environments)
  - [**Requirements**](#requirements)
    - [`requirements.txt` file](#requirementstxt-file)
- [**Assignment 03**](#assignment-03)
- [**Day 11 - File Handling, Exception Handling and Logging**](#day-11---file-handling-exception-handling-and-logging)
  - [**File Handling**](#file-handling)
    - [What is File Handling?](#what-is-file-handling)
    - [File Modes](#file-modes)
    - [File Handling Using `Open` All Modes](#file-handling-using-open-all-modes)
    - [File Handling Using `with` All Modes](#file-handling-using-with-all-modes)
    - [`Open` vs `With` in Python](#open-vs-with-in-python)
    - [Serialization and Deserialization](#serialization-and-deserialization)
    - [Pickling in Python](#pickling-in-python)
    - [JSON Dump vs Pickling](#json-dump-vs-pickling)
    - [File Handling Using `os` Module](#file-handling-using-os-module)
  - [**Exception Handling in Python**](#exception-handling-in-python)
    - [Try and Except](#try-and-except)
    - [Try, Except with Multiple Exceptions](#try-except-with-multiple-exceptions)
    - [Try, Except with Generic Exception](#try-except-with-generic-exception)
    - [Else Block](#else-block)
    - [Finally Block](#finally-block)
    - [Raising Exceptions](#raising-exceptions)
    - [Custom Exception](#custom-exception)
    - [Try-Except-Else-Finally Complete Structure](#try-except-else-finally-complete-structure)
  - [**Logging in Python**](#logging-in-python)
    - [Import Logging Module](#import-logging-module)
    - [Basic Configuration (Console Logging)](#basic-configuration-console-logging)
    - [Logging to a File](#logging-to-a-file)
    - [Logging Levels](#logging-levels)
    - [Custom Logger](#custom-logger)
    - [Advanced Format](#advanced-format)
    - [Exception Logging](#exception-logging)
- [**Day 12 - Building an Iron Man JARVIS System**](#day-12---building-an-iron-man-jarvis-system)
  - [**Features in JARVIS System**](#features-in-jarvis-system)
  - [**JARVIS System Setup**](#jarvis-system-setup)
- [**Day 13 - Multilingual AI Assistant**](#day-13---multilingual-ai-assistant)
  - [Extending Jarvis Chatbot](#extending-jarvis-chatbot)
- [**Assignment 04**](#assignment-04)
- [**Day 14 - Additional Topics, Regex**](#day-14---additional-topics-regex)
  - [**Additional Topics**](#additional-topics)
    - [Python Code In Text Files](#python-code-in-text-files)
    - [Command Line Utility](#command-line-utility)
  - [**Regular Expression (Regex)**](#regular-expression-regex)
    - [Email Extract Using Regex](#email-extract-using-regex)
  - [**Organize Files Using Python**](#organize-files-using-python)
- [**Day 15 - Introduction to OOP**](#day-15---introduction-to-oop)
  - [**The Robot Problem**](#the-robot-problem)
    - [Class \& Object](#class--object)
    - [Constructor (`__init__`)](#constructor-__init__)
    - [`self` Keyword](#self-keyword)
    - [Instance Variables](#instance-variables)
    - [Class Variables](#class-variables)
    - [Instance Methods](#instance-methods)
  - [**Class vs Object**](#class-vs-object)
    - [Class](#class)
    - [Object](#object)
    - [Key Differences in Class and Object](#key-differences-in-class-and-object)
    - [Multiple Objects from One Class](#multiple-objects-from-one-class)
- [**Day 16 - Writing our first Class in OOP**](#day-16---writing-our-first-class-in-oop)
  - [**ATM Machine Using OOP**](#atm-machine-using-oop)
- [**Day 17 - Self \& Encapsulation in OOP**](#day-17---self--encapsulation-in-oop)
  - [**Magic Method/Dunder Method**](#magic-methoddunder-method)
  - [**Concept of **self** keyword in OOP**](#concept-of-self-keyword-in-oop)
  - [**How objects access attributes in OOP**](#how-objects-access-attributes-in-oop)
  - [**Reference Variable in OOP**](#reference-variable-in-oop)
  - [**Pass by reference**](#pass-by-reference)
  - [**Mutability of object in OOP**](#mutability-of-object-in-oop)
  - [**What is instance variable**](#what-is-instance-variable)
  - [**Encapsulation in OOP**](#encapsulation-in-oop)
    - [Types of Access Control](#types-of-access-control)
    - [Getter \& Setter (Encapsulation Tool)](#getter--setter-encapsulation-tool)
    - [Name Mangling (Private Variable Internals)](#name-mangling-private-variable-internals)
- [**Day 18 - Inheritance in OOP**](#day-18---inheritance-in-oop)
  - [**Collection Of Class Objects**](#collection-of-class-objects)
  - [**Static Variable in OOP**](#static-variable-in-oop)
  - [**Instance vs Static Variable in OOP**](#instance-vs-static-variable-in-oop)
  - [**Aggregation**](#aggregation)
  - [**DRY Principle**](#dry-principle)
  - [**Inheritance**](#inheritance)
- [**Day 19 - Polymorphism, Abstraction \& Modular Coding**](#day-19---polymorphism-abstraction--modular-coding)
  - [**Types of Inheritance**](#types-of-inheritance)
    - [Single Inheritance](#single-inheritance)
    - [Multilevel Inheritance](#multilevel-inheritance)
    - [Multiple Inheritance](#multiple-inheritance)
    - [Hierarchical Inheritance](#hierarchical-inheritance)
    - [Hybrid Inheritance](#hybrid-inheritance)
    - [Diamond Problem (Special Case)](#diamond-problem-special-case)
  - [**Method Overriding**](#method-overriding)
  - [**Super Keyword in OOP**](#super-keyword-in-oop)
  - [**Multilevel Inheritance**](#multilevel-inheritance-1)
  - [**Polymorphism**](#polymorphism)
  - [**Abstraction**](#abstraction)
  - [**Modular Coding**](#modular-coding)
- [**Day 20 - Mega OOP Project**](#day-20---mega-oop-project)
  - [Gemini CLI Text Analyzer (NLP)](#gemini-cli-text-analyzer-nlp)
- [**Day 21 - Decorator, Iterators \& Generator**](#day-21---decorator-iterators--generator)
  - [**Namespaces**](#namespaces)
    - [Types of Namespaces in Python](#types-of-namespaces-in-python)
      - [1. Built-in Namespace](#1-built-in-namespace)
      - [2. Global Namespace](#2-global-namespace)
      - [3. Local Namespace](#3-local-namespace)
    - [Namespace Lifetime](#namespace-lifetime)
    - [LEGB Rule (Name Resolution Order)](#legb-rule-name-resolution-order)
    - [Global Keyword](#global-keyword)
    - [Nonlocal Keyword](#nonlocal-keyword)
    - [Checking Namespaces](#checking-namespaces)
    - [Namespace vs Scope](#namespace-vs-scope)
  - [**Decorator**](#decorator)
  - [**Iterators**](#iterators)
  - [**Generators**](#generators)
    - [Generator vs Normal Function](#generator-vs-normal-function)
    - [`yield` Keyword Explained](#yield-keyword-explained)
    - [Generator is an Iterator](#generator-is-an-iterator)
    - [Generator Expression](#generator-expression)
    - [`yield` vs `return`](#yield-vs-return)
    - [Where To Use Generators](#where-to-use-generators)
- [**Day 22 - User Interface (UI) Creation**](#day-22---user-interface-ui-creation)
  - [**Design simple UI**](#design-simple-ui)
- [**Assignment 05**](#assignment-05)
- [**Day 23 - PyPI Package Discussion**](#day-23---pypi-package-discussion)
  - [**PyPI Package**](#pypi-package)
    - [What is a Python Package?](#what-is-a-python-package)
    - [Package Manager: `pip`](#package-manager-pip)
    - [Requirements File](#requirements-file)
    - [Virtual Environments](#virtual-environments)
    - [How a Package is Structured](#how-a-package-is-structured)
    - [Publishing a Package to PyPI](#publishing-a-package-to-pypi)
- [**Day 24,25 - Publish Package to PyPI**](#day-2425---publish-package-to-pypi)
  - [**Youtube Notebook Embed Package**](#youtube-notebook-embed-package)
    - [Day 24 - Project Setup](#day-24---project-setup)
    - [Day 25 - Publish to PyPI](#day-25---publish-to-pypi)

# **Day 01 - Induction Session**

## **Session and Overview**

### Introduction

- Overview on
  - Github
  - Linkedin
  - Email
  - Assignment Submission

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 02 - Introduction to AI & System Setup**

## **Introduction to AI**

### What is AI?

- Artificial Intelligence (AI) is the creation of computer systems that can simulate human intelligence to perform tasks.
- In short, AI allows machines to:
  - Learn from data.
  - Reason and solve problems.
  - Make decisions or take actions (like recognizing speech or driving a car)

[‚¨ÜÔ∏è Go to Context](#context)

### What is Data Science?

- Data Science is an interdisciplinary field that uses scientific methods, processes,algorithms, and systems to extract knowledge and insights from vast amounts of structured and unstructured data, in order to inform human decision-making and strategy.
- In simpler terms: It's the entire process of getting useful, actionable knowledge out of raw data.

[‚¨ÜÔ∏è Go to Context](#context)

### Career Opportunities

- "The rise of AI/Data Science needs will create roughly 11.5 million job openings
- by 2026" US Bureau of Labour Statistics "By 2026, AI/Data Scientists and Analysts will become the number one emerging role in the world." World Economic Forum
- Data Science and Artificial Intelligence are amongst the hottest fields of the 21st century that will impact all segments of daily life by 2025, from transport and logistics to healthcare and customer service.

[‚¨ÜÔ∏è Go to Context](#context)

### Importance of DS

- Data science helps brands to understand their customers in a much enhanced and empowered manner.
- It allows brands to communicate their story in such a engaging and powerful manner.
- Data is a new field that is constantly growing and evolving.
- Its findings and results can be applied to almost any sector like travel, healthcare and education among others.
- Data science is accessible to almost all sectors.

[‚¨ÜÔ∏è Go to Context](#context)

### Application of AI

- **Healthcare** ‚Äì AI helps in disease detection, medical imaging, drug discovery, and robotic surgery.
- **Finance** ‚Äì Used for fraud detection, stock prediction, automated trading, and credit risk analysis.
- **Education** ‚Äì Powers personalized learning, grading automation, and virtual tutoring systems.
- **Transportation** ‚Äì Enables self-driving cars, route optimization, and predictive vehicle maintenance.
- **Manufacturing** ‚Äì Improves production efficiency, defect detection, and supply chain optimization.
- **Retail** ‚Äì Provides product recommendations, demand forecasting, and customer behavior analysis.
- **Agriculture** ‚Äì Supports crop monitoring, soil analysis, pest control, and smart irrigation.
- **Cybersecurity** ‚Äì Detects anomalies, prevents intrusions, and strengthens network defenses.
- **Entertainment** ‚Äì Generates AI-driven music, movies, games, and content personalization.
- **Customer Service** ‚Äì Automates responses through chatbot and voice assistants for 24/7 support.

[‚¨ÜÔ∏è Go to Context](#context)

### Venn Diagram

![venn diagram](https://i.imgur.com/6e3FSxF.png)

[‚¨ÜÔ∏è Go to Context](#context)

### AI Project Development Life Cycle

![ai project development life cycle](https://i.imgur.com/r3L7rpk.png)

[‚¨ÜÔ∏è Go to Context](#context)

### Different Roles in AI

- **Data Analyst** - Data analysis + AI insights
- **Machine Learning Engineer** - Predictive models, pipelines
- **Deep Learning Engineer** - Neural networks, CV, NLP
- **NLP Engineer / LLM Engineer** - Text, chatbot, RAG, fine-tuning
- **Computer Vision Engineer** - Images, video, 3D data
- **Generative AI Engineer** - Image/audio/text generation/RAG/Agents/MCP
- **MLOps Engineer** - Model optimization/deployment & monitoring
- **AI Engineer/Data Scientist** - Full AI stack (ML, DL, LLMs, MLOps)
- **AI Research Engineer** - Develop new algorithms & architectures

[‚¨ÜÔ∏è Go to Context](#context)

## **System Setup Tools**

- [Anaconda](https://www.anaconda.com/download/success)
- [VS Code](https://code.visualstudio.com/)
- [Git](https://git-scm.com/install/windows)
- [GitHub](https://github.com/)
- [Salary Range](https://www.glassdoor.com/)

> VS Code Extension - Python, Code Runner, Jupyter, Git, Graph, Git Lens.

[‚¨ÜÔ∏è Go to Context](#context)

# [**Day 03 - Introduction And Basic Of Python**](./Day%2003%20-%20Introduction%20And%20Basic%20Of%20Python/)

## **Introduction to Python & Setup**

- What is Python?
  - Python is a high-level, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation.

- Why Python?
  - Easy to learn
  - Design Philosophy
  - Batteries Included
  - General Purpose
  - Libraries & Community

- Installation & Environment Setup
  - [Python](https://www.python.org/downloads/)
  - [Anaconda](https://www.anaconda.com/download/success)
  - [Google Colab](https://colab.research.google.com/)

[‚¨ÜÔ∏è Go to Context](#context)

## **Write our first Program in Python**

```py
print("Hello World")
```

### print() Function Parameters in Python

- `objects`: Values to print (can be multiple)
  - Example: `print("Hello", "World") ‚Üí Hello World`
- `sep`: Separator between multiple objects (default = `' '`)
  - Example: `print("Hello", "World", sep="-") ‚Üí Hello-World`
- `end`: String added after the output (default = `'\n'`)
  - Example: `print("Hello", end="!") ‚Üí Hello!`
- `file`: Output stream to write (default = `sys.stdout`)
  - Example: `print("Hello", file=sys.stderr)`
- `flush`: Whether to forcibly flush the stream (default = `False`)
  - Example: `print("Processing...", flush=True)`

[‚¨ÜÔ∏è Go to Context](#context)

## **Operators in Python**

- Arithmetic Operators
  - Addition (`+ `): `5 + 3 ‚Üí 8`
  - Subtraction (`- `): `5 - 3 ‚Üí 2`
  - Multiplication (`*`): `5 * 3 ‚Üí 15`
  - Division (`/`): `5 / 2 ‚Üí 2.5`
  - Floor Division (`//`): `5 // 2 ‚Üí 2`
  - Modulus (`%`): `5 % 2 ‚Üí 1`
  - Exponentiation (`**`): `2 ** 3 ‚Üí 8`

- Comparison Operators
  - Equal to (`==`): `5 == 3 ‚Üí False`
  - Not equal to (` !=`): `5 != 3 ‚Üí True`
  - Greater than (`>`): `5 > 3 ‚Üí True`
  - Less than (`<`): `5 < 3 ‚Üí False`
  - Greater than or equal to (`>=`): `5 >= 3 ‚Üí True`
  - Less than or equal to (`<=`): `5 <= 3 ‚Üí False`

- Assignment Operators
  - Assign (`=`): `x = 5`
  - Add and assign (` +=`): `x += 3 ‚Üí x = x + 3`
  - Subtract and assign (`-=`): `x -= 3 ‚Üí x = x - 3`
  - Multiply and assign (`*=`): `x *= 3 ‚Üí x = x * 3`
  - Divide and assign (`/=`): `x /= 3 ‚Üí x = x / 3`
  - Floor divide and assign (`//=`): `x //= 3 ‚Üí x = x // 3`
  - Modulus and assign (`%=`): `x %= 3 ‚Üí x = x % 3`
  - Exponentiate and assign (`**=`): `x **= 3 ‚Üí x = x ** 3`

- Logical Operators
  - Logical AND (`and`): `True and False ‚Üí False`
  - Logical OR (`or`): `True or False ‚Üí True`
  - Logical NOT (`not`): `not True ‚Üí False`

- Bitwise Operators
  - Bitwise AND (`&`): `5 & 3 ‚Üí 1`
  - Bitwise OR (`|`): `5 | 3 ‚Üí 7`
  - Bitwise XOR (`^`): `5 ^ 3 ‚Üí 6`
  - Bitwise NOT (`~`): `~5 ‚Üí -6`
  - Left shift (`<<`): `5 << 1 ‚Üí 10`
  - Right shift (`>>`): `5 >> 1 ‚Üí 2`

- Membership Operators
  - In (`in`): `'a' in 'apple' ‚Üí True`
  - Not in (`not in`): `'b' not in 'apple' ‚Üí True`

- Identity Operators
  - Is (`is`): `x is y`
  - Is not (`is not`): `x is not y`

[‚¨ÜÔ∏è Go to Context](#context)

## **Python Data Types & Comments**

- Data Types in Python
  - Integer (`int`) - Whole numbers: `x = 10`
  - Float (`float`) - Decimal numbers: `y = 3.14`
  - Complex (`complex`) - Complex numbers: `z = 2 + 3j`
  - String (`str`) - Text: `s = "Hello"`
  - Boolean (`bool`) - True or False: `flag = True`
  - List (`list`) - Ordered, mutable collection: `lst = [1, 2, 3]`
  - Tuple (`tuple`) - Ordered, immutable collection: `tup = (1, 2, 3)`
  - Set (`set`) - Unordered, unique elements: `st = {1, 2, 3}`
  - Dictionary (`dict`) - Key-value pairs: `d = {"a": 1, "b": 2}`
  - NoneType (`None`) - Represents no value: `x = None`

- Comments in Python
  - Single-line comment (`#`): `# This is a comment`
  - Multi-line comment (triple quotes `''' '''` or `""" """`)

    ```py
    '''
    This is
    a multi-line comment
    '''
    ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Variables, Keywords & Identifiers in Python**

### Variables

- Variable Binding in Python
  - Static Binding: Variable type is fixed at **compile time** (not typical in Python, seen in languages like C/C++)

    ```py
    int x = 10;  // x is always integer
    ```

  - Dynamic Binding: Variable type is determined at **runtime** (Python uses this)

    ```py
    x = 10      # x is int
    x = "Hello" # x now becomes str
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Keywords

- Boolean Literals
  - `True`: Boolean true value
  - `False`: Boolean false value
  - `None`: Represents absence of value

- Conditional / Decision Making
  - `if`: Conditional execution
  - `elif`: Else-if condition
  - `else`: Default condition
  - `assert`: Check condition, raise error if false
  - `not`: Logical NOT
  - `and`: Logical AND
  - `or`: Logical OR
  - `in`: Membership check
  - `is`: Identity check

- Loops
  - `for`: For loop
  - `while`: While loop
  - `break`: Exit loop
  - `continue`: Skip current iteration
  - `else`: Optional else block in loops

- Functions & Classes
  - `def`: Define a function
  - `return`: Return value from function
  - `lambda`: Anonymous function
  - `class`: Define a class
  - `nonlocal`: Modify variable in outer (but non-global) scope
  - `global`: Declare global variable

- Exception Handling
  - `try`: Start exception block
  - `except`: Handle exception
  - `finally`: Execute code regardless of exception
  - `raise`: Raise an exception

- Modules & Imports
  - `import`: Import module
  - `from`: Import specific names from module
  - `as`: Alias for module or variable

- Asynchronous Programming
  - `async`: Define asynchronous function
  - `await`: Wait for asynchronous operation

- Others / Flow Control
  - `pass`: Do nothing (placeholder)
  - `del`: Delete variable or object
  - `yield`: Produce generator value

[‚¨ÜÔ∏è Go to Context](#context)

### Identifiers

- Names given to variables, functions, classes, or objects to identify them.
  - Rules for Python Identifiers:
    - Can contain letters (`a-z`, `A-Z`), digits (`0-9`), and underscore (`_`)
    - Must **start with a letter or underscore**, not a digit
    - Case-sensitive (`myVar` ‚â† `myvar`)
    - Cannot be a **keyword** (like `if`, `for`, `class`)
    - No spaces or special characters allowed

  - Examples:
    - Valid: `my_var`, `_counter`, `Data123`, `userName`
    - Invalid: `123data`, `my-var`, `for`, `user name`

  - Naming Conventions:
    - Variables / functions: `snake_case` ‚Üí `my_variable`
    - Classes: `PascalCase` ‚Üí `MyClass`
    - Constants: `UPPER_CASE` ‚Üí `PI_VALUE`

[‚¨ÜÔ∏è Go to Context](#context)

## **Python Input**

- Input in Python

  - `input()`: Reads a line of text from the user (always returns a string)
    - Example: `name = input("Enter your name: ")`

[‚¨ÜÔ∏è Go to Context](#context)

## **Type Conversion in Python**

- `int()`: Convert to integer
  - Example: `x = int(3.14) ‚Üí 3`

- `float()`: Convert to float
  - Example: `y = float(5) ‚Üí 5.0`

- `str()`: Convert to string
  - Example: `s = str(100) ‚Üí "100"`

- `bool()`: Convert to boolean
  - Example: `flag = bool(0) ‚Üí False`

- `complex()`: Convert to complex number
  - Example: `c = complex(2, 3) ‚Üí (2+3j)`

- `list()`: Convert to list
  - Example: `lst = list("abc") ‚Üí ['a','b','c']`

- `tuple()`: Convert to tuple
  - Example: `tup = tuple([1,2,3]) ‚Üí (1,2,3)`

- `set()`: Convert to set
  - Example: `st = set([1,2,2,3]) ‚Üí {1,2,3}`

- `dict()`: Convert to dictionary (from iterable of key-value pairs)
  - Example: `d = dict([("a",1),("b",2)]) ‚Üí {'a':1,'b':2}`

- `ord()`: Convert character to ASCII/Unicode integer
  - Example: `num = ord('A') ‚Üí 65`

- `chr()`: Convert ASCII/Unicode integer to character
  - Example: `ch = chr(65) ‚Üí 'A'`

[‚¨ÜÔ∏è Go to Context](#context)

## **Literals in Python**

- Literals in Python : Literals are **fixed values** assigned directly in the code that represent data. They are not computed or changed during execution.

  - String Literals
    - Example: `s = "Hello World"`

  - Numeric Literals
    - Integer
      - Example: `x = 10`
    - Float
      - Example: `y = 3.14`
    - Complex
      - Example: `z = 2 + 3j`

  - Boolean Literals
    - Example: `flag = True` / `flag = False`

  - None Literal
    - Example: `x = None`

  - Collection Literals
    - List
      - Example: `lst = [1, 2, 3]`
    - Tuple
      - Example: `tup = (1, 2, 3)`
    - Set
      - Example: `st = {1, 2, 3}`
    - Dictionary
      - Example: `d = {"a":1, "b":2}`

  - Bytes Literals
    - Example: `b = b"Hello"`

[‚¨ÜÔ∏è Go to Context](#context)

# [**Day 04 - Conditional Statements, Pip, Modules & Loops**](./Day%2004%20-%20Conditional%20Statements,%20Pip,%20Modules%20&%20Loops/)

## **Conditional Statements**

- Conditional Statements in Python : Conditional statements are used to make decisions in code based on whether a condition is **True** or **False**.

  - `if` Statement

    ```py
    x = 10
    if x > 5:
        print("x is greater than 5")
    ```

  - `if-else` Statement

    ```py
    x = 3
    if x > 5:
        print("x is greater than 5")
    else:
        print("x is not greater than 5")
    ```

  - `if-elif-else` Statement

    ```py
    x = 0
    if x > 0:
        print("Positive")
    elif x < 0:
        print("Negative")
    else:
        print("Zero")
    ```

  - Nested `if` Statement

    ```py
    x = 15
    if x > 0:
        if x % 2 == 0:
            print("Positive Even")
        else:
            print("Positive Odd")
    ```

  - Conditional Expression (Ternary Operator)

    ```py
    x = 10
    result = "Even" if x % 2 == 0 else "Odd"
    print(result)
    ```

[‚¨ÜÔ∏è Go to Context](#context)

## **PIP (Pip Installs Packages)**

- PIP (Pip Installs Packages) : `pip` is the **package manager for Python** used to install, upgrade, and manage external Python libraries and dependencies.

- Check pip version
  - `pip --version`

- Install a package
  - `pip install package_name`

- Install specific version
  - `pip install package_name==1.2.3`

- Upgrade a package
  - `pip install --upgrade package_name`

- Uninstall a package
  - `pip uninstall package_name`

- Show installed packages
  - `pip list`

- Show details of a package
  - `pip show package_name`

- Save installed packages to a requirements file
  - `pip freeze > requirements.txt`

- Install packages from a requirements file
  - `pip install -r requirements.txt`

[‚¨ÜÔ∏è Go to Context](#context)

## **Modules in Python**

- Modules in Python : A **module** in Python is a file containing Python code (functions, variables, or classes) that can be imported and reused in other programs.

  - Types of Modules
    - Built-in Modules: Pre-installed with Python (e.g., `math`, `os`, `sys`)
    - User-defined Modules: Created by the user as `.py` files
    - External Modules: Installed using `pip` (e.g., `requests`, `numpy`)

  - Importing a Module

    ```py
    import math
    print(math.sqrt(16))
    ```

  - Importing Specific Function

    ```pt
    from math import sqrt
    print(sqrt(25))
    ```

  - Importing with Alias

    ```py
    import math as m
    print(m.pi)
    ```

  - Importing All Contents (not recommended)

    ```py
    from math import *
    print(factorial(5))
    ```

  - Creating a User-defined Module

    - File: `my_module.py`

      ```py
      def greet(name):
          return f"Hello, {name}!"
      ```

    - Usage:

      ```py
      import my_module
      print(my_module.greet("Tansen"))
      ```

  - Checking Module Search Path

    ```py
    import sys
    print(sys.path)
    ```

  - Re-importing a Modified Module

    ```py
    import importlib
    importlib.reload(my_module)
    ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Loops in Python**

- Loops in Python : Loops are used to **execute a block of code repeatedly** until a certain condition is met.

  - Types of Loops
    - `for` loop
    - `while` loop

  - `for` Loop
    - Used to iterate over a sequence (list, tuple, string, range, etc.)

      ```py
      for i in range(5):
          print(i)
      ```

  - `while` Loop
    - Executes as long as the condition is `True`

      ```py
      x = 0
      while x < 5:
          print(x)
          x += 1
      ```

  - `break` Statement
    - Used to **exit** the loop immediately

      ```py
      for i in range(10):
          if i == 5:
              break
          print(i)
      ```

  - `continue` Statement
    - Skips the current iteration and continues with the next

      ```py
      for i in range(5):
          if i == 2:
              continue
          print(i)
      ```

  - `else` with Loop
    - The `else` block executes **only if the loop completes normally** (without `break`)

      ```py
      for i in range(3):
          print(i)
      else:
          print("Loop finished")
      ```

  - Nested Loops
    - A loop inside another loop

      ```py
      for i in range(2):
          for j in range(3):
              print(i, j)
      ```

  - Infinite Loop
    - A loop that runs forever until a `break` condition occurs

      ```py
      while True:
          print("Running...")
          break
      ```

[‚¨ÜÔ∏è Go to Context](#context)

# [**Assignment 01**](./Assignments/Assignment%2001/)

[‚¨ÜÔ∏è Go to Context](#context)

# [**Day 05 - Loops in Python**](./Day%2005%20-%20Loops%20in%20Python/)

## **Loops Recap**

- `while` Loop: Repeats code **while a condition is True**

  ```py
  x = 0
  while x < 3:
      print("Count:", x)
      x += 1
  ```

- `for` Loop: Iterates over a sequence (list, string, range, etc.)

  ```py
  for i in range(3):
      print("Index:", i)
  ```

- Program to print multiplication table

  ```py
  number = int(input("Enter a number: "))
  i=1
  while i<=10:
      print(f"{number} * {i} = {number*i}")
      i+=1
  ```

- Guess the number game

  ```py
  """
  - Genera a random number (1-100)
  - Take an input from user -> guess the number
  - Compare / match the num
  - if user guess>generate number -> guess a lower num
  - if guess < generate num-> guess a higher num
  - if num correct show result
  """
  import random
  random_num=random.randint(1, 100)
  num = int(input("Guess the number: "))
  counter =1

  while num!=random_num:
      if num>random_num:
          print("Guess a lower num")
      elif num<random_num:
          print("Guess a higher num")
      num = int(input("Guess the number: "))
      counter+=1
  else:
      print(f"Total attempt: {counter}")
      print("You guess the correct number")
  ```

- Range print using list

  ```py
  list(range(1,11))
  ```

- For loop range with skip steps

  ```py
  for i in range(1,11,2):
      print(i)
  ```

- Reverse loop

  ```py
  for i in range(11,-1,-1):
      print(i)
  ```

- Triangle pattern using nested loop

  ```py
  # triangle pattern using nested for loop
  for i in range(1,6):
      for j in range(1,i+1):
          print("*", end="")
      print("")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Loop Control Statements**

- `break`

  ```py
  # break
  for i in range(1,11):
      if i==5:
          break
      print(i)
  ```

- `continue`

  ```py
  # continue
  for i in range(1,10):
      if i==5:
          continue
      print(i)
  ```

- `pass`

  ```py
  # pass
  for i in range(1,11):
      pass
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Code Visualization Tool**

- [Python Tutor](https://pythontutor.com/python-compiler.html)
- [Thonny](https://thonny.org/)

[‚¨ÜÔ∏è Go to Context](#context)

# [**Day 06 - Strings in Python**](./Day%2006%20-%20Strings%20in%20Python/)

## **Strings in Python**

### Creating Strings

- Single and multiline string

  ```py
  s = 'hello'
  s = "hello"

  # multiline strings
  s = '''hello'''
  s = """hello"""
  s = str('hello')
  print(s)
  ```

- String explicit type conversion (int to str)

  ```py
  a = 34
  str(a)
  ```

- `SyntaxError: unterminated string literal`

  - Use double quotes:

    ```py
    print("it's my birthday")
    ```

  - Escape the single quote:

    ```py
    print('it\'s my birthday')
    ```

  - Use triple quotes:

    ```py
    print('''it's my birthday''')
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Accessing Strings

- By Index (0-based)

  ```py
  s = "Python"
  print(s[0])  # P
  print(s[5])  # n
  ```

- Negative Indexing (from end)

  ```py
  s = "Python"
  print(s[-1])  # n
  print(s[-3])  # h
  ```

- String Slicing

  ```py
  s = "Python"
  print(s[0:3])   # Pyt
  print(s[2:])    # thon
  print(s[:4])    # Pyth
  print(s[::2])   # Pto
  ```

- Accessing Characters with Loop

  ```py
  s = "AI"
  for ch in s:
      print(ch)
  ```

- Index access

  ```py
  intro = "My name is Tansen"
  intro.index("T") - len(intro)
  ```

- Positive and negative index access (Multiple)

- Positive index using list comprehension

  ```py
  indices  = [i for i,c in enumerate(intro) if c =="n"]
  indices
  ```

- Negative index using list comprehension

  ```py
  neg_indices = [i - len(intro) for i in indices]
  neg_indices
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Adding Chars to Strings

- Using Concatenation (`+`)

  ```py
  s = "Hello"
  s = s + " World"
  print(s)  # Hello World
  ```

- Using `join()`

  ```py
  s = "-".join(["A", "B", "C"])
  print(s)  # A-B-C
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Editing Strings

- Strings are **immutable**, cannot change directly
- Using slicing and concatenation

  ```py
  s = "Hello"
  s = "J" + s[1:]
  print(s)  # Jello
  ```

- Using `replace()`

  ```py
  s = "Hello"
  s = s.replace("H", "J")
  print(s)  # Jello
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Deleting Strings

- Using `del` to remove entire string

  ```py
  s = "Hello"
  del s
  # print(s) ‚Üí Error: s is not defined
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Operations on Strings

- Arithmetic Operations
  - Concatenation (` +`)

    ```py
    s1 = "Hello"
    s2 = "World"
    s3 = s1 + " " + s2
    print(s3)  # Hello World
    ```

  - Repetition (`*`)

    ```py
    s = "Hi! " * 3
    print(s)  # Hi! Hi! Hi!
    ```

- Relational Operations
  - Comparison (`==`, ` !=`, `<`, `>`, `<=`, `>=`)

    ```py
    s1 = "apple"
    s2 = "banana"
    print(s1 == s2)  # False
    print(s1 < s2)   # True
    ```

- Logical Operations
  - `and`, `or`, `not` on boolean results of comparisons

    ```py
    s1 = "apple"
    s2 = "banana"
    print(s1 < s2 and s2 > "aardvark")  # True
    print(not(s1 == s2))                 # True
    ```

- Loops on Strings
  - Iterating over characters

    ```py
    s = "Python"
    for ch in s:
        print(ch)
    ```

- Membership Operations
  - `in` and `not in`

    ```py
    s = "Python"
    print("P" in s)     # True
    print("z" not in s) # True
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### String Functions

- `len()`: Get length of string

  ```py
  s = "Python"
  print(len(s))  # 6
  ```

- `ord()`: Get ASCII/Unicode value of character

  ```py
  print(ord('A'))  # 65
  ```

- `chr()`: Get character from ASCII/Unicode value

  ```py
  print(chr(65))  # 'A'
  ```

- `max()`: Get character with maximum ASCII value

  ```py
  s = "Python"
  print(max(s))  # y
  ```

- `min()`: Get character with minimum ASCII value

  ```py
  s = "Python"
  print(min(s))  # P
  ```

- `sorted()`: Return sorted list of characters

  ```py
  s = "Python"
  print(sorted(s))  # ['P', 'h', 'n', 'o', 't', 'y']
  ```

- `reversed()`: Return iterator to reverse string

  ```py
  s = "Python"
  print(''.join(reversed(s)))  # nohtyP
  ```

- `type()`: Get type of object

  ```py
  s = "Python"
  print(type(s))  # <class 'str'>
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### String Methods

- `upper()`: Convert string to uppercase

  ```py
  s = "hello"
  print(s.upper())  # HELLO
  ```

- `lower()`: Convert string to lowercase

  ```py
  s = "HELLO"
  print(s.lower())  # hello
  ```

- `capitalize()`: Capitalize first character

  ```py
  s = "hello"
  print(s.capitalize())  # Hello
  ```

- `title()`: Capitalize first character of each word

  ```py
  s = "hello world"
  print(s.title())  # Hello World
  ```

- `strip()`: Remove leading and trailing whitespace

  ```py
  s = "  hello  "
  print(s.strip())  # hello
  ```

- `replace()`: Replace substring with another

  ```py
  s = "Hello World"
  print(s.replace("World", "Python"))  # Hello Python
  ```

- `split()`: Split string into list by separator

  ```py
  s = "a,b,c"
  print(s.split(","))  # ['a', 'b', 'c']
  ```

- `join()`: Join list of strings with separator

  ```py
  lst = ["a","b","c"]
  print("-".join(lst))  # a-b-c
  ```

- `find()`: Find index of substring (-1 if not found)

  ```py
  s = "Python"
  print(s.find("t"))  # 2
  ```

- `count()`: Count occurrences of substring

  ```py
  s = "banana"
  print(s.count("a"))  # 3
  ```

- `startswith()`: Check if string starts with substring

  ```py
  s = "Python"
  print(s.startswith("Py"))  # True
  ```

- `endswith()`: Check if string ends with substring

  ```py
  s = "Python"
  print(s.endswith("on"))  # True
  ```

- `isalpha()`: Check if all characters are alphabetic

  ```py
  s = "Python"
  print(s.isalpha())  # True
  ```

- `isalnum()`: Check if all characters are number

  ```py
  s = "123"
  print(s.isalnum())  # True
  ```

- `isdigit()`: Check if all characters are digits

  ```py
  s = "123"
  print(s.isdigit())  # True
  ```

- `isspace()`: Check if string contains only whitespace

  ```py
  s = "   "
  print(s.isspace())  # True
  ```

- `isidentifier()`: Checks if a string is a **valid Python identifier** (variable, function, class name).


  ```py
  s1 = "variable1"
  s2 = "1variable"
  print(s1.isidentifier())  # True
  print(s2.isidentifier())  # False
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Strings Exercise**

### Find the length of a given string without using the len() function

```py
s = input("Enter a String: ")

counter = 1
for i in s:
    counter += 1

print(counter)
```

### Extract username from a given email

- If the email is `aatansen@gmail.com`
- Then the username should be `aatansen`

  ```py
  # email = "aatansen@gmail.com"
  email = input("Enter your email: ")
  pos = email.index("@")
  print(email[0:pos])
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# [**Day 07 - List in Python**](./Day%2007%20-%20List%20in%20Python/)

## **List in Python**

### What are Lists?

- List is a data type where you can store multiple items under 1 name. More technically, lists act like dynamic arrays which means you can add more items on the fly.

  - A list is an **ordered**, **mutable**, and **dynamic** collection of elements.
  - Created using **square brackets `[]`** or the **list()** constructor.

- **Characteristics**
  - **Ordered** ‚Äî Maintains insertion order
  - **Mutable / Changeable** ‚Äî Elements can be modified
  - **Heterogeneous** ‚Äî Can store different data types
  - **Allows Duplicates** ‚Äî Repeated values are allowed
  - **Dynamic Size** ‚Äî Can grow or shrink automatically
  - **Index-Based Access** ‚Äî Supports positive and negative indexing
  - **Can Be Nested** ‚Äî Lists can contain other lists
  - **Can Store Any Python Object** ‚Äî Numbers, strings, functions, classes, etc.
  - **More Memory Usage** than tuples
  - **Slower** compared to tuples due to mutability

    ```py
    my_list = [10, "Hello", 3.14, True]
    print(my_list)
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Lists Vs Arrays

- **Lists**
  - Can store elements of **different data types**
  - Part of **core Python**
  - Flexible but slower for large numeric data

    ```py
    my_list = [1, "two", 3.0, True]
    print(my_list)
    ```

- **Arrays**
  - Can store elements of **same data type only**
  - Need to import from **array module** or **NumPy**
  - More **memory-efficient** for numeric operations

    ```py
    import array
    arr = array.array('i', [1, 2, 3, 4])
    print(arr)
    ```

  - **Key Differences**
    - **Data Type:** Lists ‚Üí Heterogeneous | Arrays ‚Üí Homogeneous
    - **Speed:** Arrays are faster for numeric operations
    - **Size:** Lists ‚Üí Dynamic | Arrays ‚Üí Fixed (unless NumPy array)
    - **Memory:** Arrays use less memory than lists
    - **Usage:** Lists are flexible | Arrays are optimized for computation

    ```mermaid
    flowchart TD

        %% --- Python List Section ---
        subgraph L1["Python List"]
            direction LR
            L1desc["(Dynamic Array: grows automatically)"]
            L1A["Index 0 ‚Üí 10"]
            L1B["Index 1 ‚Üí 20"]
            L1C["Index 2 ‚Üí 30"]
        end

        %% --- Array Section ---
        subgraph A1["Array Module"]
            direction LR
            A1desc["(Fixed Size: array('i', [10,20,30]))"]
            A1A["Index 0 ‚Üí 10"]
            A1B["Index 1 ‚Üí 20"]
            A1C["Index 2 ‚Üí 30"]
        end

        L1 -->|"append(40)"| L2
        A1 -->|"add new value"| A2

        %% --- After Adding Value (List) ---
        subgraph L2["After append(40)"]
            direction LR
            L2A["üÜï New Memory Block Allocated"]
            L2B["Values Copied: 10, 20, 30, 40"]
        end

        %% --- After Adding Value (Array) ---
        subgraph A2["Array Overflow"]
            direction LR
            A2A["‚ùå Memory Full"]
            A2B["‚úÖ Must create new array and copy values"]
        end

        %% --- Style Definitions ---
        classDef list fill:#2E86C1,stroke:#1B4F72,color:#fff,font-weight:bold;
        classDef array fill:#B9770E,stroke:#873600,color:#fff,font-weight:bold;
        classDef resized fill:#1E8449,stroke:#145A32,color:#fff,font-weight:bold;
        classDef overflow fill:#C0392B,stroke:#641E16,color:#fff,font-weight:bold;

        class L1,L1A,L1B,L1C,L1desc list;
        class A1,A1A,A1B,A1C,A1desc array;
        class L2,L2A,L2B resized;
        class A2,A2A,A2B overflow;
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Characteristics of a List

- **Ordered** ‚Äî Elements maintain their insertion order
- **Changeable / Mutable** ‚Äî Elements can be modified after creation
- **Heterogeneous** ‚Äî Can store elements of different data types
- **Can Have Duplicates** ‚Äî Allows repeated elements
- **Dynamic** ‚Äî Size can grow or shrink as needed
- **Can Be Nested** ‚Äî Lists can contain other lists
- **Index-Based Access** ‚Äî Elements can be accessed using indices
- **Can Contain Any Python Object** ‚Äî Strings, numbers, lists, tuples, functions, etc.

[‚¨ÜÔ∏è Go to Context](#context)

### How to create a list

- Using square brackets `[]`

  ```py
  my_list = [1, 2, 3, 4]
  ```

- Using `list()` constructor

  ```py
  my_list = list((1, 2, 3, 4))
  ```

- Empty list

  ```py
  my_list = []
  ```

- Heterogeneous list

  ```py
  my_list = [1, "Hello", 3.5, True]
  ```

- Nested list

  ```py
  my_list = [[1, 2], [3, 4]]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Access items from a List

- Using index (0-based)

  ```py
  my_list = [10, 20, 30, 40]
  print(my_list[1])  # 20
  ```

- Using negative index (from end)

  ```py
  my_list = [10, 20, 30, 40]
  print(my_list[-1])  # 40
  ```

- Using slicing

  ```py
  my_list = [10, 20, 30, 40, 50]
  print(my_list[1:4])  # [20, 30, 40]
  ```

- Accessing nested list

  ```py
  my_list = [[1, 2], [3, 4]]
  print(my_list[1][0])  # 3
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### List Methods

- `append()` ‚Äî Add an item to the end

  ```py
  my_list = [1, 2, 3]
  my_list.append(4)
  print(my_list)  # [1, 2, 3, 4]
  ```

- `extend()` ‚Äî Add multiple items from another list

  ```py
  my_list = [1, 2, 3]
  my_list.extend([4, 5])
  print(my_list)  # [1, 2, 3, 4, 5]
  ```

- `insert()` ‚Äî Insert item at specific position

  ```py
  my_list = [1, 3, 4]
  my_list.insert(1, 2)
  print(my_list)  # [1, 2, 3, 4]
  ```

- `remove()` ‚Äî Remove first occurrence of an item

  ```py
  my_list = [1, 2, 3, 2]
  my_list.remove(2)
  print(my_list)  # [1, 3, 2]
  ```

- `pop()` ‚Äî Remove and return item by index (default last)

  ```py
  my_list = [1, 2, 3]
  my_list.pop()
  print(my_list)  # [1, 2]
  ```

- `clear()` ‚Äî Remove all elements

  ```py
  my_list = [1, 2, 3]
  my_list.clear()
  print(my_list)  # []
  ```

- `index()` ‚Äî Return index of first occurrence

  ```py
  my_list = [10, 20, 30, 20]
  print(my_list.index(20))  # 1
  ```

- `count()` ‚Äî Count occurrences of item

  ```py
  my_list = [1, 2, 2, 3]
  print(my_list.count(2))  # 2
  ```

- `sort()` ‚Äî Sort list in ascending order

  ```py
  my_list = [3, 1, 2]
  my_list.sort()
  print(my_list)  # [1, 2, 3]
  ```

- `reverse()` ‚Äî Reverse order of list

  ```py
  my_list = [1, 2, 3]
  my_list.reverse()
  print(my_list)  # [3, 2, 1]
  ```

- `copy()` ‚Äî Return shallow copy of list

  ```py
  my_list = [1, 2, 3]
  new_list = my_list.copy()
  print(new_list)  # [1, 2, 3]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### List Functions

- `len()` ‚Äî Returns number of elements in list

  ```py
  my_list = [1, 2, 3]
  print(len(my_list))  # 3
  ```

- `max()` ‚Äî Returns maximum element

  ```py
  my_list = [1, 5, 3]
  print(max(my_list))  # 5
  ```

- `min()` ‚Äî Returns minimum element

  ```py
  my_list = [1, 5, 3]
  print(min(my_list))  # 1
  ```

- `sum()` ‚Äî Returns sum of elements

  ```py
  my_list = [1, 2, 3]
  print(sum(my_list))  # 6
  ```

- `sorted()` ‚Äî Returns sorted list (ascending by default)

  ```py
  my_list = [3, 1, 2]
  print(sorted(my_list))  # [1, 2, 3]
  ```

- `reversed()` ‚Äî Returns iterator to reverse list

  ```py
  my_list = [1, 2, 3]
  print(list(reversed(my_list)))  # [3, 2, 1]
  ```

- `any()` ‚Äî Returns True if any element is True

  ```py
  my_list = [0, 0, 1]
  print(any(my_list))  # True
  ```

- `all()` ‚Äî Returns True if all elements are True

  ```py
  my_list = [1, 2, 3]
  print(all(my_list))  # True
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Editing items in a List

  ```py
  # editing with slicing
  L = [1,2,3,4]
  L[1:4] = [200,300,400]
  print(L)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Deleting items from a List

  ```py
  L = [1,2,3,4]
  del L[0]
  print(L)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Operations on Lists

- **Concatenation (` +`)**

  ```py
  list1 = [1, 2]
  list2 = [3, 4]
  result = list1 + list2
  print(result)  # [1, 2, 3, 4]
  ```

- **Repetition (`*`)**

  ```py
  list1 = [1, 2]
  result = list1 * 3
  print(result)  # [1, 2, 1, 2, 1, 2]
  ```

- **Membership (`in`, `not in`)**

  ```py
  list1 = [1, 2, 3]
  print(2 in list1)     # True
  print(5 not in list1) # True
  ```

- **Iteration / Loops**

  ```py
  list1 = [1, 2, 3]
  for item in list1:
      print(item)
  ```

- **Indexing and Slicing**

  ```py
  list1 = [10, 20, 30, 40]
  print(list1[1])    # 20
  print(list1[1:3])  # [20, 30]
  ```

- **Length (`len()`)**

  ```py
  list1 = [1, 2, 3, 4]
  print(len(list1))  # 4
  ```

- **Minimum and Maximum (`min()`, `max()`)**

  ```py
  list1 = [5, 2, 9]
  print(min(list1))  # 2
  print(max(list1))  # 9
  ```

- **Sum (`sum()`)**

  ```py
  list1 = [1, 2, 3]
  print(sum(list1))  # 6
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### List comprehension

- A concise way to **create lists** using a single line of code with loops and conditions.

- Basic Syntax

  ```py
  [expression for item in iterable if condition]
  ```

- Squares of numbers

  ```py
  squares = [x**2 for x in range(5)]
  print(squares)  # [0, 1, 4, 9, 16]
  ```

- Even numbers only

  ```py
  evens = [x for x in range(10) if x % 2 == 0]
  print(evens)  # [0, 2, 4, 6, 8]
  ```

- Convert strings to uppercase

  ```py
  fruits = ["apple", "banana", "cherry"]
  fruits_upper = [f.upper() for f in fruits]
  print(fruits_upper)  # ['APPLE', 'BANANA', 'CHERRY']
  ```

- Nested List Comprehension

  ```py
  matrix = [[1,2,3],[4,5,6]]
  flat = [num for row in matrix for num in row]
  print(flat)  # [1, 2, 3, 4, 5, 6]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### `zip()` Function in Python

- Combines multiple iterables (lists, tuples, etc.) element-wise into a single iterator of tuples.

- Syntax

  ```py
  zip(iterable1, iterable2, ...)
  ```

- Example ‚Äî Basic usage

  ```py
  list1 = [1, 2, 3]
  list2 = ['a', 'b', 'c']
  zipped = zip(list1, list2)
  print(list(zipped))  # [(1, 'a'), (2, 'b'), (3, 'c')]
  ```

- Example ‚Äî More than two iterables

  ```py
  nums = [1, 2, 3]
  chars = ['x', 'y', 'z']
  bools = [True, False, True]
  zipped = zip(nums, chars, bools)
  print(list(zipped))  # [(1, 'x', True), (2, 'y', False), (3, 'z', True)]
  ```

- Example ‚Äî Iterating directly

  ```py
  for num, char in zip([1,2], ['a','b']):
      print(num, char)
  # Output:
  # 1 a
  # 2 b
  ```

> [!NOTE]
>
> - Stops at the **shortest iterable**
> - Can be combined with `list()`, `dict()`, or unpacking

[‚¨ÜÔ∏è Go to Context](#context)

# [**Assignment 02**](./Assignments/Assignment%2002/)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 08 - Tuples, Sets & Dictionary**

## **Tuples**

- **Tuples in Python**
  - A tuple is an **ordered**, **immutable** collection of elements.
  - Created using **parentheses `()`** or the **tuple()** constructor.

- **Characteristics**
  - **Ordered** ‚Äî Maintains insertion order
  - **Immutable** ‚Äî Cannot be changed after creation
  - **Heterogeneous** ‚Äî Can store different data types
  - **Allows Duplicates** ‚Äî Repeated items are allowed
  - **Index-Based Access** ‚Äî Access elements using indices
  - **Hashable (if all elements are immutable)** ‚Äî Can be used as dictionary keys
  - **Faster than lists** due to immutability
  - **Can be nested** ‚Äî Tuples inside tuples
  - **Uses less memory** than lists

    ```py
    my_tuple = (10, "Hello", 3.14, True)
    print(my_tuple)
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Creating a Tuple

- Using parentheses `()`

  ```py
  t = (1, 2, 3)
  ```

- Without parentheses (tuple packing)

  ```py
  t = 1, 2, 3
  ```

- Single-element tuple (requires comma)

  ```py
  t = (5,)
  ```

- Using `tuple()` constructor

  ```py
  t = tuple([1, 2, 3])
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Accessing Items in Tuple

- Using index

  ```py
  t = (10, 20, 30)
  print(t[1])  # 20
  ```

- Negative indexing

  ```py
  t = (10, 20, 30)
  print(t[-1])  # 30
  ```

- Slicing

  ```py
  t = (1, 2, 3, 4)
  print(t[1:3])  # (2, 3)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Editing Items in Tuple

- Not possible ‚Äî tuples are **immutable**

  ```py
  t = (1, 2, 3)
  # t[0] = 5  ‚Üí Error
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Adding Items in Tuple

- Create a **new tuple** using concatenation

  ```py
  t = (1, 2, 3)
  t = t + (4,)
  print(t)  # (1, 2, 3, 4)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Deleting Items in Tuple

- Delete entire tuple

  ```py
  t = (1, 2, 3)
  del t
  # print(t) ‚Üí Error: t is not defined
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Operations on Tuples

- Concatenation (` +`)

  ```py
  t1 = (1, 2)
  t2 = (3, 4)
  result = t1 + t2
  print(result)  # (1, 2, 3, 4)
  ```

- Repetition (`*`)

  ```py
  t = (1, 2)
  result = t * 3
  print(result)  # (1, 2, 1, 2, 1, 2)
  ```

- Membership (`in`, `not in`)

  ```py
  t = (10, 20, 30)
  print(20 in t)      # True
  print(50 not in t)  # True
  ```

- Indexing & Slicing

  ```py
  t = (5, 10, 15, 20)
  print(t[2])     # 15
  print(t[1:3])   # (10, 15)
  ```

- Iteration

  ```py
  t = ("a", "b", "c")
  for item in t:
      print(item)
  ```

- Length (`len()`)

  ```py
  t = (1, 2, 3)
  print(len(t))  # 3
  ```

- Maximum & Minimum (`max()`, `min()`)

  ```py
  t = (5, 2, 9)
  print(max(t))  # 9
  print(min(t))  # 2
  ```

- Count occurrences (`count()`)

  ```py
  t = (1, 2, 2, 3)
  print(t.count(2))  # 2
  ```

- Find index (`index()`)

  ```py
  t = (10, 20, 30)
  print(t.index(20))  # 1
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Tuple Methods

- **count() ‚Äì Count occurrences of a value**

  ```py
  t = (1, 2, 2, 3, 2)
  print(t.count(2))  # 3
  ```

- **index() ‚Äì Find the index of a value**

  ```py
  t = ("apple", "banana", "mango", "banana")
  print(t.index("banana"))  # 1
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Tuple Functions

- Length (`len()`)

  ```py
  t = (10, 20, 30)
  print(len(t))  # 3
  ```

- Maximum Value (`max()`)

  ```py
  t = (5, 9, 2)
  print(max(t))  # 9
  ```

- Minimum Value (`min()`)

  ```py
  t = (5, 9, 2)
  print(min(t))  # 2
  ```

- Sum of Elements (`sum()`)

  ```py
  t = (1, 2, 3, 4)
  print(sum(t))  # 10
  ```

- Sorting (`sorted()`)

  ```py
  t = (3, 1, 2)
  print(sorted(t))  # [1, 2, 3]
  ```

- Convert to List (`list()`)

  ```py
  t = (1, 2, 3)
  lst = list(t)
  print(lst)  # [1, 2, 3]
  ```

- Convert to Tuple (`tuple()`)

  ```py
  lst = [4, 5, 6]
  t = tuple(lst)
  print(t)  # (4, 5, 6)
  ```

- Check Type (`type()`)

  ```py
  t = (10, 20)
  print(type(t))  # <class 'tuple'>
  ```

- Check if any element is True (`any()`)

  ```py
  t = (0, False, 5)
  print(any(t))  # True
  ```

- Check if all elements are True (`all()`)

  ```py
  t = (1, 2, 3)
  print(all(t))  # True
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Tuple Unpacking

- Basic Unpacking

  ```py
  t = (10, 20, 30)
  a, b, c = t
  print(a, b, c)  # 10 20 30
  ```

- Unpacking with Different Variable Names

  ```py
  person = ("TT", 25, "Bangladesh")
  name, age, country = person
  print(name, age, country)  # TT 25 Bangladesh
  ```

- Unpacking with Asterisk (`*`)

  ```py
  t = (1, 2, 3, 4, 5)
  a, *b = t
  print(a)  # 1
  print(b)  # [2, 3, 4, 5]
  ```

- Asterisk in Middle

  ```py
  t = (10, 20, 30, 40, 50)
  a, *b, c = t
  print(a)  # 10
  print(b)  # [20, 30, 40]
  print(c)  # 50
  ```

- Nested Tuple Unpacking

  ```py
  t = ("TT", (10, 20))
  name, (x, y) = t
  print(name)  # TT
  print(x, y)  # 10 20
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Using `zip()` with Tuples

- Basic Zip

  ```py
  t1 = (1, 2, 3)
  t2 = ('a', 'b', 'c')
  zipped = zip(t1, t2)
  print(tuple(zipped))  # ((1, 'a'), (2, 'b'), (3, 'c'))
  ```

- Zip Multiple Tuples

  ```py
  t1 = (1, 2, 3)
  t2 = ('x', 'y', 'z')
  t3 = (True, False, True)
  zipped = zip(t1, t2, t3)
  print(tuple(zipped))  # ((1, 'x', True), (2, 'y', False), (3, 'z', True))
  ```

- Iterating Over Zipped Tuples

  ```py
  t1 = (1, 2, 3)
  t2 = ('a', 'b', 'c')
  for num, char in zip(t1, t2):
      print(num, char)
  # Output:
  # 1 a
  # 2 b
  # 3 c
  ```

- Unzipping Tuples

  ```py
  zipped = ((1, 'a'), (2, 'b'), (3, 'c'))
  t1, t2 = zip(*zipped)
  print(t1)  # (1, 2, 3)
  print(t2)  # ('a', 'b', 'c')
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Tuple Comprehension

- Python does **not have true tuple comprehensions**. Using parentheses `()` creates a **generator expression**, not a tuple.

  - Example (Generator Expression)

    ```py
    t_gen = (x*2 for x in range(5))
    print(t_gen)  # <generator object ...>
    print(list(t_gen))  # [0, 2, 4, 6, 8]
    ```

  - Convert Generator to Tuple

    ```py
    t = tuple(x*2 for x in range(5))
    print(t)  # (0, 2, 4, 6, 8)
    ```

  - With Condition

    ```py
    t = tuple(x for x in range(10) if x%2==0)
    print(t)  # (0, 2, 4, 6, 8)
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### List vs Tuple

- **Mutability**
  - List ‚Üí Mutable (can modify elements)
  - Tuple ‚Üí Immutable (cannot modify elements)

- **Syntax**
  - List ‚Üí Square brackets `[]`
  - Tuple ‚Üí Parentheses `()`

- **Order**
  - Both are ordered (maintain insertion order)

- **Duplicates**
  - Both allow duplicates

- **Heterogeneity**
  - Both can store heterogeneous elements

- **Memory Usage**
  - List ‚Üí Uses more memory
  - Tuple ‚Üí More memory efficient

- **Speed**
  - List ‚Üí Slower for iteration and operations
  - Tuple ‚Üí Faster due to immutability

- **Methods**
  - List ‚Üí Many methods like append, insert, remove, pop, sort
  - Tuple ‚Üí Only count() and index()

- **Use Cases**
  - List ‚Üí Use when collection may change
  - Tuple ‚Üí Use when data should not change, faster access, can be used as dictionary key

[‚¨ÜÔ∏è Go to Context](#context)

## **Sets**

- **Set in Python**

  - **Definition**
    - A set is an **unordered**, **mutable**, and **unique** collection of elements.
    - Created using **curly braces `{}`** or the **set()** constructor.

  - **Characteristics**
    - **Unordered** ‚Äî Does not maintain insertion order
    - **Mutable** ‚Äî Elements can be added or removed
    - **Unique Elements** ‚Äî Duplicates are automatically removed
    - **Heterogeneous** ‚Äî Can store multiple data types (numbers, strings, tuples, etc.)
    - **Unindexed** ‚Äî Cannot access elements by index
    - **Supports Set Operations** ‚Äî Union, intersection, difference, symmetric difference
    - **Can Be Nested with Immutable Types** ‚Äî Cannot have sets inside sets, but can contain tuples
    - **Faster Membership Testing** than lists or tuples

      ```py
      my_set = {1, 2, 3, 3}
      print(my_set)  # {1, 2, 3}
      ```

[‚¨ÜÔ∏è Go to Context](#context)

### Creating a Set

- Using curly braces

  ```py
  my_set = {1, 2, 3}
  ```

- Using `set()` constructor

  ```py
  my_set = set([1, 2, 3])
  ```

- Empty set

  ```py
  my_set = set()
  ```

### Accessing Items in Set

- Sets are **unordered**, so cannot access by index

  ```py
  my_set = {1, 2, 3}
  for item in my_set:
      print(item)
  ```

### Editing Items in Set

- Not possible directly, but can **remove and add** elements

### Adding Items in Set

- Using `add()`

  ```py
  my_set = {1, 2}
  my_set.add(3)
  print(my_set)  # {1, 2, 3}
  ```

- Using `update()` (multiple items)

  ```py
  my_set = {1, 2}
  my_set.update([3, 4, 5])
  print(my_set)  # {1, 2, 3, 4, 5}
  ```

### Deleting Items in Set

- Using `remove()` (raises error if not found)

  ```py
  my_set = {1, 2, 3}
  my_set.remove(2)
  print(my_set)  # {1, 3}
  ```

- Using `discard()` (no error if not found)

  ```py
  my_set = {1, 2, 3}
  my_set.discard(4)
  print(my_set)  # {1, 2, 3}
  ```

- Using `pop()` (removes arbitrary element)

  ```py
  my_set = {1, 2, 3}
  print(my_set.pop())  # 1 (or any element)
  ```

- Using `clear()` (remove all items)

  ```py
  my_set = {1, 2, 3}
  my_set.clear()
  print(my_set)  # set()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Operations on Set

- Union (`|` or `union()`)

  ```py
  set1 = {1, 2, 3}
  set2 = {3, 4, 5}
  print(set1 | set2)        # {1, 2, 3, 4, 5}
  print(set1.union(set2))   # {1, 2, 3, 4, 5}
  ```

- Intersection (`&` or `intersection()`)

  ```py
  set1 = {1, 2, 3}
  set2 = {2, 3, 4}
  print(set1 & set2)             # {2, 3}
  print(set1.intersection(set2)) # {2, 3}
  ```

- Difference (` -` or `difference()`)

  ```py
  set1 = {1, 2, 3}
  set2 = {2, 3, 4}
  print(set1 - set2)            # {1}
  print(set1.difference(set2))  # {1}
  ```

- Symmetric Difference (`^` or `symmetric_difference()`)

  ```py
  set1 = {1, 2, 3}
  set2 = {3, 4, 5}
  print(set1 ^ set2)                        # {1, 2, 4, 5}
  print(set1.symmetric_difference(set2))   # {1, 2, 4, 5}
  ```

- Membership Testing (`in`, `not in`)

  ```py
  s = {1, 2, 3}
  print(2 in s)      # True
  print(5 not in s)  # True
  ```

- Iteration on Set

  - Using for loop

    ```py
    my_set = {1, 2, 3}
    for item in my_set:
        print(item)
    # Output may vary in order, e.g., 1 2 3
    ```

  - Using set comprehension

    ```py
    my_set = {1, 2, 3, 4}
    squared = {x**2 for x in my_set}
    print(squared)  # {1, 4, 9, 16}
    ```

- Subset (`<=`, `issubset()`)

  ```py
  set1 = {1, 2}
  set2 = {1, 2, 3}
  print(set1 <= set2)           # True
  print(set1.issubset(set2))    # True
  ```

- Superset (`>=`, `issuperset()`)

  ```py
  set1 = {1, 2, 3}
  set2 = {1, 2}
  print(set1 >= set2)           # True
  print(set1.issuperset(set2))  # True
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Set Methods

- `add()` ‚Äì Add a single element

  ```py
  s = {1, 2}
  s.add(3)
  print(s)  # {1, 2, 3}
  ```

- `update()` ‚Äì Add multiple elements

  ```py
  s = {1, 2}
  s.update([3, 4, 5])
  print(s)  # {1, 2, 3, 4, 5}
  ```

- `remove()` ‚Äì Remove an element (raises error if not found)

  ```py
  s = {1, 2, 3}
  s.remove(2)
  print(s)  # {1, 3}
  ```

- `discard()` ‚Äì Remove an element (no error if not found)

  ```py
  s = {1, 2, 3}
  s.discard(4)
  print(s)  # {1, 2, 3}
  ```

- `pop()` ‚Äì Remove and return an arbitrary element

  ```py
  s = {1, 2, 3}
  print(s.pop())  # 1 (or any element)
  print(s)        # Remaining elements
  ```

- `clear()` ‚Äì Remove all elements

  ```py
  s = {1, 2, 3}
  s.clear()
  print(s)  # set()
  ```

- `copy()` ‚Äì Return a shallow copy of the set

  ```py
  s1 = {1, 2, 3}
  s2 = s1.copy()
  print(s2)  # {1, 2, 3}
  ```

- `union()` ‚Äì Return a new set with all elements from both sets

  ```py
  s1 = {1, 2}
  s2 = {2, 3}
  print(s1.union(s2))  # {1, 2, 3}
  ```

- `intersection()` ‚Äì Return common elements

  ```py
  s1 = {1, 2, 3}
  s2 = {2, 3, 4}
  print(s1.intersection(s2))  # {2, 3}
  ```

- `intersection_update()` ‚Äì Update set to keep only common elements

  ```py
  s1 = {1, 2, 3}
  s2 = {2, 3, 4}
  s1.intersection_update(s2)
  print(s1)  # {2, 3}
  ```

- `difference()` ‚Äì Elements in first set but not in second

  ```py
  s1 = {1, 2, 3}
  s2 = {2, 3, 4}
  print(s1.difference(s2))  # {1}
  ```

- `difference_update()` ‚Äì Remove elements found in another set

  ```py
  s1 = {1, 2, 3}
  s2 = {2, 3}
  s1.difference_update(s2)
  print(s1)  # {1}
  ```

- `symmetric_difference()` ‚Äì Elements in either set but not both

  ```py
  s1 = {1, 2, 3}
  s2 = {3, 4, 5}
  print(s1.symmetric_difference(s2))  # {1, 2, 4, 5}
  ```

- `symmetric_difference_update()` ‚Äì Update set with symmetric difference

  ```py
  s1 = {1, 2, 3}
  s2 = {3, 4, 5}
  s1.symmetric_difference_update(s2)
  print(s1)  # {1, 2, 4, 5}
  ```

- `issubset()` ‚Äì Check if set is subset of another

  ```py
  s1 = {1, 2}
  s2 = {1, 2, 3}
  print(s1.issubset(s2))  # True
  ```

- `issuperset()` ‚Äì Check if set is superset of another

  ```py
  s1 = {1, 2, 3}
  s2 = {1, 2}
  print(s1.issuperset(s2))  # True
  ```

- `isdisjoint()` ‚Äì Check if sets have no elements in common

  ```py
  s1 = {1, 2}
  s2 = {3, 4}
  print(s1.isdisjoint(s2))  # True
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Set Functions

- `len()` ‚Äì Length of the set

  ```py
  s = {1, 2, 3}
  print(len(s))  # 3
  ```

- `max()` ‚Äì Maximum element

  ```py
  s = {5, 2, 8}
  print(max(s))  # 8
  ```

- `min()` ‚Äì Minimum element

  ```py
  s = {5, 2, 8}
  print(min(s))  # 2
  ```

- `sum()` ‚Äì Sum of elements

  ```py
  s = {1, 2, 3, 4}
  print(sum(s))  # 10
  ```

- `any()` ‚Äì Returns True if any element is truthy

  ```py
  s = {0, False, 5}
  print(any(s))  # True
  ```

- `all()` ‚Äì Returns True if all elements are truthy

  ```py
  s = {1, 2, 3}
  print(all(s))  # True
  ```

- `sorted()` ‚Äì Return sorted elements as a list

  ```py
  s = {3, 1, 2}
  print(sorted(s))  # [1, 2, 3]
  ```

- `type()` ‚Äì Check the type**

  ```py
  s = {1, 2, 3}
  print(type(s))  # <class 'set'>
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Frozenset in Python

- An immutable version of a set.
- Elements cannot be added or removed once created.
- Created using `frozenset()`.

  ```py
  fs = frozenset([1, 2, 3, 3])
  print(fs)  # frozenset({1, 2, 3})
  ```

- Operations Allowed
  - Can perform union, intersection, difference, symmetric difference

    ```py
    fs1 = frozenset([1, 2, 3])
    fs2 = frozenset([2, 3, 4])
    print(fs1.union(fs2))  # frozenset({1, 2, 3, 4})
    print(fs1.intersection(fs2))  # frozenset({2, 3})
    ```

- Not Allowed
  - No `add()`, `remove()`, `pop()`, or `clear()` methods.

[‚¨ÜÔ∏è Go to Context](#context)

### Set Comprehension

- A concise way to create a set using expressions inside curly braces `{}`.

  ```py
  s = {x*2 for x in range(5)}
  print(s)  # {0, 2, 4, 6, 8}
  ```

- With Condition

  ```py
  s = {x for x in range(10) if x%2 == 0}
  print(s)  # {0, 2, 4, 6, 8}
  ```

- From Another Collection

  ```py
  lst = [1, 2, 2, 3, 4]
  s = {x for x in lst}
  print(s)  # {1, 2, 3, 4}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Using `zip()` with Sets

- `zip()` can combine multiple iterables element-wise.
- When used with sets, the iteration order is **arbitrary** because sets are unordered.

    ```py
    s1 = {1, 2, 3}
    s2 = {'a', 'b', 'c'}
    zipped = zip(s1, s2)
    print(list(zipped))  # Example output: [(1, 'b'), (2, 'a'), (3, 'c')]
    ```

- **Iterating Directly**

  ```py
  s1 = {1, 2, 3}
  s2 = {'x', 'y', 'z'}
  for num, char in zip(s1, s2):
      print(num, char)
  # Output order may vary because sets are unordered
  ```

- **Unzipping**

  ```py
  zipped = [(1, 'a'), (2, 'b'), (3, 'c')]
  s1, s2 = zip(*zipped)
  print(s1)  # (1, 2, 3)
  print(s2)  # ('a', 'b', 'c')
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Dictionary**

- A dictionary is an **unordered**, **mutable**, and **key-value pair** collection.
- Keys must be **unique and immutable** (strings, numbers, tuples, etc.).
- Values can be **any data type** and duplicates are allowed.
- Created using **curly braces `{}`** or the **dict()** constructor.

- **Characteristics**
  - **Unordered** ‚Äî Items have no fixed position (Python 3.7+ preserves insertion order as implementation detail)
  - **Mutable** ‚Äî Can add, modify, or delete items
  - **Key-Value Pairs** ‚Äî Data stored in key:value format
  - **Unique Keys** ‚Äî Duplicate keys are not allowed
  - **Heterogeneous** ‚Äî Keys and values can be of different data types
  - **Dynamic** ‚Äî Can grow or shrink as needed
  - **Nested Structures Allowed** ‚Äî Dictionaries can contain lists, tuples, or other dictionaries

    ```py
    my_dict = {"name": "TT", "age": 25, "country": "Bangladesh"}
    print(my_dict)  # {'name': 'TT', 'age': 25, 'country': 'Bangladesh'}
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Creating a Dictionary

- Using curly braces

  ```py
  my_dict = {"name": "TT", "age": 25}
  ```

- Using `dict()` constructor

  ```py
  my_dict = dict(name="TT", age=25)
  ```

- Empty dictionary

  ```py
  my_dict = {}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Accessing Items in Dictionary

- Using `key`

  ```py
  my_dict = {"name": "TT", "age": 25}
  print(my_dict["name"])  # TT
  ```

- Using `get()`

  ```py
  print(my_dict.get("age"))  # 25
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Editing Items in Dictionary

- Modifying value

  ```py
  my_dict["age"] = 26
  print(my_dict)  # {'name': 'TT', 'age': 26}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Adding Items in Dictionary

- Adding new key-value pair

  ```py
  my_dict["country"] = "Bangladesh"
  print(my_dict)  # {'name': 'TT', 'age': 26, 'country': 'Bangladesh'}
  ```

- Using `update()`

  ```py
  my_dict.update({"city": "Dhaka"})
  print(my_dict)  # {'name': 'TT', 'age': 26, 'country': 'Bangladesh', 'city': 'Dhaka'}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Deleting Items in Dictionary

- Using `pop()`

  ```py
  my_dict.pop("city")
  print(my_dict)  # {'name': 'TT', 'age': 26, 'country': 'Bangladesh'}
  ```

- Using `popitem()` (removes last inserted item)

  ```py
  my_dict.popitem()
  print(my_dict)  # {'name': 'TT', 'age': 26}
  ```

- Using `del`

  ```py
  del my_dict["age"]
  print(my_dict)  # {'name': 'TT'}
  ```

- Using `clear()` (removes all items)

  ```py
  my_dict.clear()
  print(my_dict)  # {}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Operations on Dictionary

- Membership Testing (`in`, `not in`)

  ```py
  my_dict = {"name": "TT", "age": 25}
  print("name" in my_dict)      # True
  print("country" not in my_dict)  # True
  ```

- Iteration over Keys

  ```py
  my_dict = {"name": "TT", "age": 25}
  for key in my_dict:
      print(key)
  # Output: name, age
  ```

- Iteration over Values

  ```py
  for value in my_dict.values():
      print(value)
  # Output: TT, 25
  ```

- Iteration over Items (key-value pairs)

  ```py
  for key, value in my_dict.items():
      print(key, value)
  # Output: name TT, age 25
  ```

- Length (`len()`)

  ```py
  print(len(my_dict))  # 2
  ```

- Copying Dictionary

  ```py
  new_dict = my_dict.copy()
  print(new_dict)  # {'name': 'TT', 'age': 25}
  ```

- Merging Dictionaries (update)

  ```py
  dict1 = {"a": 1, "b": 2}
  dict2 = {"b": 3, "c": 4}
  dict1.update(dict2)
  print(dict1)  # {'a': 1, 'b': 3, 'c': 4}
  ```

- Get with Default

  ```py
  print(my_dict.get("country", "Not Found"))  # Not Found
  ```

- Keys, Values, Items

  ```py
  print(my_dict.keys())    # dict_keys(['name', 'age'])
  print(my_dict.values())  # dict_values(['TT', 25])
  print(my_dict.items())   # dict_items([('name', 'TT'), ('age', 25)])
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Dictionary Methods

- `clear()` ‚Äì Remove all items

  ```py
  my_dict = {"name": "TT", "age": 25}
  my_dict.clear()
  print(my_dict)  # {}
  ```

- `copy()` ‚Äì Return a shallow copy

  ```py
  my_dict = {"name": "TT", "age": 25}
  new_dict = my_dict.copy()
  print(new_dict)  # {'name': 'TT', 'age': 25}
  ```

- `fromkeys()` ‚Äì Create dictionary with keys and default value

  ```py
  keys = ["a", "b", "c"]
  new_dict = dict.fromkeys(keys, 0)
  print(new_dict)  # {'a': 0, 'b': 0, 'c': 0}
  ```

- `get()` ‚Äì Return value of key (default if key not found)

  ```py
  my_dict = {"name": "TT"}
  print(my_dict.get("name"))       # TT
  print(my_dict.get("age", 0))     # 0
  ```

- `items()` ‚Äì Return key-value pairs

  ```py
  my_dict = {"name": "TT", "age": 25}
  print(my_dict.items())  # dict_items([('name', 'TT'), ('age', 25)])
  ```

- `keys()` ‚Äì Return keys

  ```py
  print(my_dict.keys())  # dict_keys(['name', 'age'])
  ```

- `values()` ‚Äì Return values

  ```py
  print(my_dict.values())  # dict_values(['TT', 25])
  ```

- `pop()` ‚Äì Remove item by key

  ```py
  my_dict.pop("age")
  print(my_dict)  # {'name': 'TT'}
  ```

- `popitem()` ‚Äì Remove last inserted item

  ```py
  my_dict.popitem()
  print(my_dict)  # {}
  ```

- `setdefault()` ‚Äì Return value if key exists, else set default

  ```py
  my_dict = {"name": "TT"}
  print(my_dict.setdefault("age", 20))  # 20
  print(my_dict)  # {'name': 'TT', 'age': 20}
  ```

- `update()` ‚Äì Update dictionary with key-value pairs

  ```py
  my_dict.update({"name": "John", "country": "BD"})
  print(my_dict)  # {'name': 'John', 'age': 20, 'country': 'BD'}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Dictionary Functions

- `len()` ‚Äì Number of items

  ```py
  my_dict = {"name": "TT", "age": 25}
  print(len(my_dict))  # 2
  ```

- `type()` ‚Äì Type of the object

  ```py
  print(type(my_dict))  # <class 'dict'>
  ```

- `all()` ‚Äì True if all keys are truthy

  ```py
  my_dict = {"a": 1, "b": 2}
  print(all(my_dict))  # True
  ```

- `any()` ‚Äì True if any key is truthy

  ```py
  my_dict = {"a": 0, "b": 2}
  print(any(my_dict))  # True
  ```

- `sorted()` ‚Äì Return sorted list of keys

  ```py
  my_dict = {"c": 3, "a": 1, "b": 2}
  print(sorted(my_dict))  # ['a', 'b', 'c']
  ```

- `sum()` ‚Äì Sum of keys if numeric

  ```py
  my_dict = {1: "a", 2: "b", 3: "c"}
  print(sum(my_dict))  # 6
  ```

- `max()` ‚Äì Maximum key

  ```py
  print(max(my_dict))  # 3
  ```

- `min()` ‚Äì Minimum key

  ```py
  print(min(my_dict))  # 1
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Dictionary Unpacking

- Extract keys and values directly into variables.

  ```py
  my_dict = {"name": "TT", "age": 25}
  k, v = list(my_dict.items())[0]
  print(k, v)  # name TT
  ```

- Using `**` to merge dictionaries

  ```py
  dict1 = {"a": 1, "b": 2}
  dict2 = {"c": 3, "d": 4}
  merged = {**dict1, **dict2}
  print(merged)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Using `zip()` with Dictionary

- Combine two iterables into key-value pairs.

  ```py
  keys = ["name", "age", "country"]
  values = ["TT", 25, "Bangladesh"]
  my_dict = dict(zip(keys, values))
  print(my_dict)  # {'name': 'TT', 'age': 25, 'country': 'Bangladesh'}
  ```

- Iterating with zip()

  ```py
  for k, v in zip(keys, values):
      print(k, v)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Dictionary Comprehension

- Create dictionaries using a single expression inside `{}`.

  ```py
  squares = {x: x**2 for x in range(5)}
  print(squares)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
  ```

- With condition

  ```py
  even_squares = {x: x**2 for x in range(10) if x % 2 == 0}
  print(even_squares)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}
  ```

- From two lists

  ```py
  keys = ["a", "b", "c"]
  values = [1, 2, 3]
  my_dict = {k: v for k, v in zip(keys, values)}
  print(my_dict)  # {'a': 1, 'b': 2, 'c': 3}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Simple Project Using Dictionary

- Restaurant Management

  ```py
  menu = {
      "Coffee": 2,
      "Pasta": 3,
      "Pizza": 5,
      "Burger": 6,
      "Chicken": 10
  }
  print(
      """
      Welcome to Inception's Restaurant. Please Order Food!

      Coffee: $2
      Pasta: $3
      Pizza: $5
      Burger: $6
      Chicken: $10

      """
  )

  item1 = input("Enter the name of the item you want to order: ")
  total_price = 0
  if item1 in menu:
      total_price += menu[item1]
      print(f"You ordered {item1}. Your total order is ${total_price}")
  else:
      print("Invalid item, Please order something from the Menu")
  another_order = input("Do you want to add another item? (Yes/No): ").lower()
  if another_order == "yes":
      item2 = input("Enter the name of the 2nd item you want to order: ")
      if item2 in menu:
          total_price += menu[item2]
          print(f"You ordered {item2}. Your total order is ${total_price}")
      else:
          print("Invalid item, Please order something from the Menu")
  print(f"Your total amount is ${total_price}. Thank you!")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 09 - Functions in Python**

## **Functions in Python**

- A function is a reusable block of code that performs a specific task.
- Created using the `def` keyword.
- Can take inputs (parameters) and return outputs.

[‚¨ÜÔ∏è Go to Context](#context)

### Characteristics of Function

- Defined using the 'def' keyword.
- Executes only when it is called.
- Can accept inputs (parameters).
- Can return outputs using '`return`'.
- Helps avoid code repetition.
- Improves code readability and organization.
- Can be built-in (print, len) or user-defined.
- Supports default parameter values.
- Supports variable arguments (`*args`,`**kwargs`).
- Has its own local scope separate from global scope.
- May or may not return a value.
- Can be nested (function inside another).
- Can be passed as arguments or stored in variables (first-class functions).

[‚¨ÜÔ∏è Go to Context](#context)

### Creating a Function

- Defined using the 'def' keyword

  ```py
  def greet():
      print("Hello, TT!")
  greet()
  ```

- Function with Parameters

  ```py
  def add(a, b):
      return a + b

  print(add(5, 3))  # 8
  ```

- Function with Default Parameter

  ```py
  def greet(name="TT"):
      print("Hello,", name)

  greet()         # Hello, TT
  greet("John")   # Hello, John
  ```

- Function with Return Value

    ```py
    def square(n):
        return n * n

    print(square(4))  # 16
    ```

- Keyword Arguments

  ```py
  def info(name, age):
      print(name, age)

  info(age=25, name="TT")
  ```

- Variable-Length Arguments (`*args`)

  ```py
  def total(*nums):
      print(sum(nums))

  total(1, 2, 3, 4)  # 10
  ```

- Variable-Length Keyword Arguments (`**kwargs`)

  ```py
  def show(**data):
      print(data)

  show(name="TT", age=25)
  ```

- Lambda (Anonymous Function)

  ```py
  double = lambda x: x * 2
  print(double(5))  # 10
  ```

- Pass Statement

  ```py
  def todo():
      pass  # empty function
  ```

- Docstring - A string used to describe what a function does, placed at the beginning of the function

  ```py
  def add(a, b):
      """Returns the sum of two numbers."""
      return a + b

  print(add.__doc__)
  ```

- Calling Functions

  ```py
  def hello():
      print("Hi!")

  hello()
  ```

- Deleting Functions

  ```py
  def hello():
      print("Hi!")

  del hello
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Parameter vs Argument

- **Parameter** ‚Äì Variable defined in the function to accept input

  ```py
  def greet(name, age):  # name and age are parameters
      print(f"Hello {name}, you are {age} years old")
  ```

- **Argument** ‚Äì Actual value passed to the function when calling it

  ```py
  greet("TT", 25)  # "TT" and 25 are arguments
  ```

- **Key Difference** ‚Äì Parameters exist in function definition, arguments exist in function call

  ```py
  # Parameters: name, age
  # Arguments: "TT", 25
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Types of Arguments

- **Positional Arguments** ‚Äì Passed in order

  ```py
  def greet(name, age):
      print(f"Hello {name}, you are {age} years old")

  greet("TT", 25)  # Hello TT, you are 25 years old
  ```

- **Keyword Arguments** ‚Äì Passed using parameter names

  ```py
  greet(age=25, name="TT")  # Hello TT, you are 25 years old
  ```

- **Default Arguments** ‚Äì Use default value if not provided

  ```py
  def greet(name, age=18):
      print(f"Hello {name}, you are {age} years old")

  greet("TT")  # Hello TT, you are 18 years old
  ```

- **Variable-length Arguments (`*args`)** ‚Äì Accepts any number of positional arguments

  ```py
  def add(*numbers):
      print(sum(numbers))

  add(1, 2, 3, 4)  # 10
  ```

- **Variable-length Keyword Arguments (`**kwargs`)** ‚Äì Accepts any number of keyword arguments

  ```py
  def info(**details):
      print(details)

  info(name="TT", age=25)  # {'name': 'TT', 'age': 25}
  ```

- **Required Arguments** ‚Äì Must be provided, no default

  ```py
  def greet(name, age):
      print(f"Hello {name}, you are {age}")

  # greet("TT")  # Error: missing required argument 'age'
  ```

- **Positional-only Arguments (Python 3.8+)** ‚Äì Must be passed by position

  ```py
  def greet(name, /, age):
      print(f"{name} is {age}")

  greet("TT", age=25)  # TT is 25
  ```

- **Keyword-only Arguments** ‚Äì Must be passed by keyword

  ```py
  def greet(*, name, age):
      print(f"{name} is {age}")

  greet(name="TT", age=25)  # TT is 25
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### `*args` vs `**kwargs`

- **`*args`** ‚Äì Accepts any number of positional arguments as a tuple

  ```py
  def add(*numbers):
      print(numbers)
      print(sum(numbers))

  add(1, 2, 3, 4)
  # Output:
  # (1, 2, 3, 4)
  # 10
  ```

- **`**kwargs`** ‚Äì Accepts any number of keyword arguments as a dictionary

  ```py
  def info(**details):
      print(details)

  info(name="TT", age=25)
  # Output:
  # {'name': 'TT', 'age': 25}
  ```

- **Key Difference**
  - `*args` ‚Üí positional arguments, tuple
  - `**kwargs` ‚Üí keyword arguments, dictionary

[‚¨ÜÔ∏è Go to Context](#context)

### Variable Scope in Functions

- **Local Scope** ‚Äì Variables defined inside a function, accessible only within that function

  ```py
  def my_func():
      x = 10  # local variable
      print(x)

  my_func()  # 10
  # print(x)  # Error: x is not defined
  ```

- **Global Scope** ‚Äì Variables defined outside all functions, accessible anywhere

  ```py
  y = 20  # global variable

  def show():
      print(y)

  show()  # 20
  print(y)  # 20
  ```

- **Using `global` Keyword** ‚Äì Modify global variables inside a function

  ```py
  count = 0

  def increment():
      global count
      count += 1

  increment()
  print(count)  # 1
  ```

- **Enclosing / Nonlocal Scope** ‚Äì Variables in outer (enclosing) function, accessible in nested function

  ```py
  def outer():
      a = 5
      def inner():
          nonlocal a
          a += 1
          print(a)
      inner()
      print(a)

  outer()
  # Output:
  # 6
  # 6
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Nested Functions

- **Nested Function** ‚Äì A function defined inside another function

  ```py
  def outer():
      print("This is the outer function")

      def inner():
          print("This is the inner function")

      inner()  # Calling inner function inside outer

  outer()
  # Output:
  # This is the outer function
  # This is the inner function
  ```

- **Accessing Outer Variable** ‚Äì Inner function can access variables from outer function

  ```py
  def outer():
      x = 10
      def inner():
          print(f"Value from outer: {x}")
      inner()

  outer()
  # Output:
  # Value from outer: 10
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Functions are First-Class Citizens

- Functions in Python can be treated like any other object: assigned to variables, passed as arguments, and returned from other functions.

- **Assigning Function to a Variable**

  ```py
  def greet():
      print("Hello TT")

  say_hello = greet  # assigning function to a variable
  say_hello()  # Hello TT
  ```

- **Passing Function as Argument**

  ```py
  def greet():
      print("Hello TT")

  def call_func(func):
      func()

  call_func(greet)  # Hello TT
  ```

- **Returning Function from Another Function**

  ```py
  def outer():
      def inner():
          print("Inside inner function")
      return inner

  my_func = outer()
  my_func()  # Inside inner function
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Benefits of Using a Function

- **Code Modularity** ‚Äì Breaks program into smaller, manageable parts

  ```py
  def calculate_area(radius):
      return 3.14 * radius * radius

  def calculate_circumference(radius):
      return 2 * 3.14 * radius
  ```

- **Code Readability** ‚Äì Improves clarity and understanding of the program

  ```py
  def greet_user(name):
      print(f"Hello {name}, welcome!")
  ```

- **Code Reusability** ‚Äì Functions can be reused multiple times without rewriting code

  ```py
  def add(a, b):
      return a + b

  print(add(5, 10))
  print(add(20, 30))
  ```


[‚¨ÜÔ∏è Go to Context](#context)

### Lambda Function

- A small anonymous function defined using the `lambda` keyword, usually for simple operations

  ```py
  # Syntax: lambda arguments: expression

  square = lambda x: x ** 2
  print(square(5))  # 25
  ```

- **Multiple Arguments**

  ```py
  add = lambda a, b: a + b
  print(add(10, 20))  # 30
  ```

- **Used with `map()`**

  ```py
  nums = [1, 2, 3, 4]
  squared = list(map(lambda x: x**2, nums))
  print(squared)  # [1, 4, 9, 16]
  ```

- **Used with `filter()`**

  ```py
  nums = [1, 2, 3, 4, 5]
  even = list(filter(lambda x: x % 2 == 0, nums))
  print(even)  # [2, 4]
  ```

- **Used with `sorted()`**

  ```py
  points = [(1, 2), (3, 1), (5, 0)]
  sorted_points = sorted(points, key=lambda x: x[1])
  print(sorted_points)  # [(5, 0), (3, 1), (1, 2)]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Lambda vs Normal Function

- **Normal Function** ‚Äì Defined using `def`, can have multiple statements, name is mandatory

  ```py
  def add(a, b):
      result = a + b
      return result

  print(add(5, 10))  # 15
  ```

- **Lambda Function** ‚Äì Anonymous function using `lambda`, limited to a single expression

  ```py
  add = lambda a, b: a + b
  print(add(5, 10))  # 15
  ```

- **Key Differences**

  - Normal Function:
    - Defined with 'def'
    - Can contain multiple statements
    - Has a function name
    - Can include loops, conditions, etc.

  - Lambda Function:
    - Defined with 'lambda'
    - Single expression only
    - Anonymous (no name, unless assigned)
    - Mostly used for short, simple operations

[‚¨ÜÔ∏è Go to Context](#context)

### Higher-Order Functions

- Functions that can take other functions as arguments and/or return functions as results

- **Passing Function as Argument**

  ```py
  def greet():
      print("Hello TT")

  def call_func(func):
      func()  # function passed as argument

  call_func(greet)  # Hello TT
  ```

- **Returning Function from Another Function**

  ```py
  def outer():
      def inner():
          print("Inside inner function")
      return inner  # returning function

  my_func = outer()
  my_func()  # Inside inner function
  ```

- **Built-In Higher Order Functions**

- **`map()`** ‚Äì Applies a function to all items in an iterable

  ```py
  nums = [1, 2, 3, 4]
  squared = list(map(lambda x: x**2, nums))
  print(squared)  # [1, 4, 9, 16]
  ```

- **`filter()`** ‚Äì Filters items in an iterable based on a function

  ```py
  nums = [1, 2, 3, 4, 5]
  even = list(filter(lambda x: x % 2 == 0, nums))
  print(even)  # [2, 4]
  ```

- **`reduce()`** ‚Äì Applies a function cumulatively to items (from `functools`)

  ```py
  from functools import reduce
  nums = [1, 2, 3, 4]
  total = reduce(lambda x, y: x + y, nums)
  print(total)  # 10
  ```

- **`sorted()`** ‚Äì Can take a key function for custom sorting

  ```py
  points = [(1, 2), (3, 1), (5, 0)]
  sorted_points = sorted(points, key=lambda x: x[1])
  print(sorted_points)  # [(5, 0), (3, 1), (1, 2)]
  ```

- **`any()` and `all()`** ‚Äì Can be combined with functions in comprehension or `map`

  ```py
  nums = [0, 1, 2, 3]
  print(all(map(lambda x: x > 0, nums)))  # False
  print(any(map(lambda x: x > 0, nums)))  # True
  ```

- **`zip()` with function** ‚Äì Combine iterables and apply function using `map`

  ```py
  a = [1, 2, 3]
  b = [4, 5, 6]
  sum_list = list(map(lambda x: x[0]+x[1], zip(a, b)))
  print(sum_list)  # [5, 7, 9]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### `enumerate()` Function

- Adds a counter to an iterable and returns it as an `enumerate` object, which can be converted to a list or tuple

  ```py
  fruits = ["apple", "banana", "cherry"]
  for index, fruit in enumerate(fruits):
      print(index, fruit)

  # Output:
  # 0 apple
  # 1 banana
  # 2 cherry
  ```

- **Start Index** ‚Äì You can specify a starting index

  ```py
  fruits = ["apple", "banana", "cherry"]
  for index, fruit in enumerate(fruits, start=1):
      print(index, fruit)

  # Output:
  # 1 apple
  # 2 banana
  # 3 cherry
  ```

- **Usage with List Conversion**

  ```py
  fruits = ["apple", "banana", "cherry"]
  enum_list = list(enumerate(fruits))
  print(enum_list)  # [(0, 'apple'), (1, 'banana'), (2, 'cherry')]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 10 - Virtual Environment & Requirements**

## **Virtual Environment**

### Create Conda Environment

- Create an environment in current folder (`-p`) or ` -n` for conda default path

  ```sh
  conda create -p .venv
  ```

- Activate Environment

  ```sh
  conda activate ./.venv
  ```

- Install Python in Environment

  ```sh
  conda install python=3.13
  ```

- Install Packages

  ```sh
  conda install numpy pandas
  ```

- Deactivate Environment

  ```sh
  conda deactivate
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### List and Remove Conda Environments

- List All Environments ‚Äì Shows all conda environments

  ```sh
  conda env list
  # or
  conda info --envs
  ```

- Remove Environment by Name

  ```sh
  conda remove --name my_env --all
  ```

- Remove Environment by Path

  ```sh
  conda remove -p ./my_env --all
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Requirements**

### `requirements.txt` file

- A plain text file listing all Python packages and versions required for a project

  ```txt
  # Example contents of requirements.txt
  numpy==1.26.0
  pandas==2.1.0
  matplotlib==3.8.0
  scikit-learn==1.3.0
  django==5.2.0
  ```

- Install Packages from `requirements.txt`

  ```sh
  pip install -r requirements.txt
  ```

- Generate `requirements.txt` from Current Environment

  ```sh
  pip freeze > requirements.txt
  ```

- Check Installed Packages

  ```sh
  pip list
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# [**Assignment 03**](./Assignments/Assignment%2003/)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 11 - File Handling, Exception Handling and Logging**

## **File Handling**

### What is File Handling?

- A way to read from and write to files using Python‚Äôs built-in functions.
- To store data permanently.
- To read/write logs, configs, reports, user data, etc.

---

- Types of data used for I/O:
  - Text - '12345' as a sequence of unicode chars
  - Binary - 12345 as a sequence of bytes of its binary equivalent

- Hence there are 2 file types to deal with
  - Text files - All program files are text files
  - Binary Files - Images,music,video,exe files

- How File I/O is done in most programming languages
  - Open a file
  - Read/Write data
  - Close the file

[‚¨ÜÔ∏è Go to Context](#context)

### File Modes

- '`r`'  ‚Üí read (default)
- '`w`'  ‚Üí write (overwrites file)
- '`a`'  ‚Üí append (adds to file)
- '`x`'  ‚Üí create error if file exists
- '`b`'  ‚Üí binary mode (images, videos)
- '`t`'  ‚Üí text mode (default)
- Combinations: '`rb`', '`wb`', '`ab`', etc.

[‚¨ÜÔ∏è Go to Context](#context)

### File Handling Using `Open` All Modes

- '`r`'  ‚Üí Read mode (default)
  - Opens file for reading.
  - Raises error if file does not exist.

    ```py
    f = open("data.txt", "r")
    content = f.read()
    f.close()
    ```

- '`w`'  ‚Üí Write mode
  - Creates file if missing.
  - Overwrites file if exists.

    ```py
      f = open("data.txt", "w")
      f.write("Hello World")
      f.close()
      ```

- '`a`'  ‚Üí Append mode
  - Creates file if missing.
  - Adds new data at the end (does not overwrite).

    ```py
    f = open("data.txt", "a")
    f.write("\nNew Line Added")
    f.close()
    ```

- '`x`'  ‚Üí Exclusive creation mode
  - Creates new file.
  - Error if file already exists.

    ```py
    f = open("newfile.txt", "x")
    f.write("Created using x mode")
    f.close()
    ```

- '`b`'  ‚Üí Binary mode
  - Used for images, videos, audio, PDFs.
  - Must combine with r/w/a.

    ```py
    f = open("image.jpg", "rb")
    data = f.read()
    f.close()
    ```

- '`t`'  ‚Üí Text mode (default)
  - Handles normal text files.

    ```py
    f = open("notes.txt", "rt")
    print(f.read())
    f.close()
    ```

- '`rb`'  ‚Üí Read Binary

  ```py
  f = open("file.bin", "rb")
  data = f.read()
  f.close()
  ```

- '`wb`'  ‚Üí Write Binary

  ```py
  f = open("file.bin", "wb")
  f.write(b"Binary Data")
  f.close()
  ```

- '`ab`'  ‚Üí Append Binary

  ```py
  f = open("file.bin", "ab")
  f.write(b"\nMore Binary Data")
  f.close()
  ```

- '`rt`'  ‚Üí Read Text (same as 'r')

  ```py
  f = open("info.txt", "rt")
  ```

- '`wt`'  ‚Üí Write Text (same as 'w')

  ```py
  f = open("info.txt", "wt")
  ```

- '`at`'  ‚Üí Append Text (same as 'a')

  ```py
  f = open("info.txt", "at")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### File Handling Using `with` All Modes

- '`r`' ‚Üí Read mode (default)
  - Opens file for reading.
  - Automatically closes file after block ends.

    ```py
    with open("data.txt", "r") as f:
        content = f.read()
        print(content)
    ```

- '`w`' ‚Üí Write mode
  - Creates file if missing.
  - Overwrites file if it exists.

    ```py
    with open("data.txt", "w") as f:
        f.write("Hello World")
    ```

- '`a`' ‚Üí Append mode
  - Creates file if missing.
  - Adds new data at the end.

    ```py
    with open("data.txt", "a") as f:
        f.write("\nNew Line Added")
    ```

- '`x`' ‚Üí Exclusive creation mode
  - Creates new file.
  - Error if file already exists.

    ```py
    with open("newfile.txt", "x") as f:
        f.write("Created using x mode")
    ```

- '`b`' ‚Üí Binary mode
  - Used for images, PDFs, videos.
  - Must combine with r/w/a.

    ```py
    with open("image.jpg", "rb") as f:
        data = f.read()
    ```

- '`t`' ‚Üí Text mode (default)
  - For normal text files.

    ```py
    with open("notes.txt", "rt") as f:
        print(f.read())
    ```

- '`rb`' ‚Üí Read Binary

    ```py
    with open("file.bin", "rb") as f:
        data = f.read()
    ```

- '`wb`' ‚Üí Write Binary

    ```py
    with open("file.bin", "wb") as f:
        f.write(b"Binary Data")
    ```

- '`ab`' ‚Üí Append Binary

    ```py
    with open("file.bin", "ab") as f:
        f.write(b"\nMore Binary Data")
    ```

- '`rt`' ‚Üí Read Text (same as 'r')

    ```py
    with open("info.txt", "rt") as f:
        print(f.read())
    ```

- '`wt`' ‚Üí Write Text (same as 'w')

    ```py
    with open("info.txt", "wt") as f:
        f.write("Hello!")
    ```

- '`at`' ‚Üí Append Text (same as 'a')

    ```py
    with open("info.txt", "at") as f:
        f.write("\nAppended text")
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### `Open` vs `With` in Python

- **Using `open()`**
  - Must manually close the file using `close()`.
  - If an error occurs, file may remain open (resource leak).
  - More lines of code and less safe.

    ```py
    f = open("data.txt", "r")
    content = f.read()
    f.close()
    ```

- **Using `with`**
  - Automatically closes the file after block ends.
  - Prevents resource leaks even if errors occur.
  - Cleaner, safer, and recommended.

    ```py
    with open("data.txt", "r") as f:
        content = f.read()
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Serialization and Deserialization

- **Serialization**
  - Process of converting Python data types into JSON format.
  - Useful for storing or transmitting data.

    ```py
    import json

    data = {"name": "TT", "age": 25, "city": "Dhaka"}
    json_str = json.dumps(data)  # Python dict ‚Üí JSON string
    print(json_str)  # '{"name": "TT", "age": 25, "city": "Dhaka"}'
    ```

- **Deserialization**
  - Process of converting JSON data back into Python data types.

    ```py
    import json

    json_str = '{"name": "TT", "age": 25, "city": "Dhaka"}'
    data = json.loads(json_str)  # JSON string ‚Üí Python dict
    print(data)  # {'name': 'TT', 'age': 25, 'city': 'Dhaka'}
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Pickling in Python

- **Pickling**
  - Process of converting Python objects into a byte stream.
  - Can also pickle functions for later use (if defined at top level).

    ```py
    import pickle

    def display_info():
        return "Hi my name is Tansen and I am a Programmer"

    with open("func.pkl", "wb") as f:
        pickle.dump(display_info, f)
    ```

- **Unpickling**
  - Process of converting byte stream back into Python objects.
  - Can call the unpickled function like normal.

    ```py
    import pickle

    with open("func.pkl", "rb") as f:
        func = pickle.load(f)

    print(func())  # Hi my name is Tansen and I am a Programmer
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### JSON Dump vs Pickling

- **JSON Dump**
  - Converts Python objects to JSON string format.
  - Text-based, human-readable.
  - Can be shared across different programming languages.
  - Supports basic Python types (dict, list, str, int, float, bool, None).
  - Cannot serialize custom Python objects or functions directly.

    ```py
    import json

    def display_info():
        return "Hi my name is Tansen and I am a Programmer"

    data = {"name": "Tansen", "age": 25, "info": "Programmer"}
    json_str = json.dumps(data)  # Serialize Python dict
    print(json_str)  # '{"name": "Tansen", "age": 25, "info": "Programmer"}'
    ```

- **Pickling**
  - Converts Python objects to byte stream.
  - Binary format, not human-readable.
  - Python-specific, cannot be directly used in other languages.
  - Can serialize almost any Python object including custom classes and functions.

    ```py
    import pickle

    def display_info():
        return "Hi my name is Tansen and I am a Programmer"

    with open("func.pkl", "wb") as f:
        pickle.dump(display_info, f)  # Serialize function

    with open("func.pkl", "rb") as f:
        func = pickle.load(f)

    print(func())  # Hi my name is Tansen and I am a Programmer
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### File Handling Using `os` Module

- Importing OS Module

  ```py
  import os
  ```

- Check if File or Directory Exists

  ```py
  os.path.exists("data.txt")        # True if file or folder exists
  os.path.isfile("data.txt")        # True if it is a file
  os.path.isdir("my_folder")        # True if it is a directory
  ```

- Create a Directory

  ```py
  os.mkdir("my_folder")             # Single directory
  os.makedirs("parent/child")       # Nested directories
  ```

- Remove/Delete a Directory

  ```py
  os.rmdir("my_folder")             # Only empty directories
  os.removedirs("parent/child")     # Nested empty directories
  ```

- Remove/Delete a File

  ```py
  os.remove("data.txt")
  ```

- Rename a File or Directory

  ```py
  os.rename("old_name.txt", "new_name.txt")
  ```

- List Files and Directories

  ```py
  os.listdir(".")                    # List current directory
  os.listdir("/path/to/folder")      # List specific folder
  ```

- Get Current Working Directory

  ```py
  cwd = os.getcwd()
  print(cwd)
  ```

- Change Directory

  ```py
  os.chdir("my_folder")
  print(os.getcwd())
  ```

- Join Paths

  ```py
  full_path = os.path.join("folder", "file.txt")
  print(full_path)                   # folder/file.txt (or folder\file.txt in Windows)
  ```

- Get Absolute Path

  ```py
  abs_path = os.path.abspath("data.txt")
  print(abs_path)
  ```

- Split Path

  ```py
  folder, file = os.path.split("/path/to/data.txt")
  print(folder, file)
  ```

- Get File Name and Extension

  ```py
  name, ext = os.path.splitext("data.txt")
  print(name, ext)                   # data .txt
  ```

- Check Access Permissions

  ```py
  os.access("data.txt", os.R_OK)    # True if readable
  os.access("data.txt", os.W_OK)    # True if writable
  os.access("data.txt", os.X_OK)    # True if executable
  ```

- File Size

  ```py
  size = os.path.getsize("data.txt")
  print(size)
  ```

- Modification and Creation Time

  ```py
  import time
  mod_time = os.path.getmtime("data.txt")
  print(time.ctime(mod_time))
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Exception Handling in Python**

- Mechanism to handle runtime errors.
- Prevents program from crashing.

[‚¨ÜÔ∏è Go to Context](#context)

### Try and Except

  ```py
  try:
      x = 10 / 0
  except ZeroDivisionError:
      print("Cannot divide by zero")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Try, Except with Multiple Exceptions

  ```py
  try:
      num = int("abc")
      x = 10 / 0
  except ValueError:
      print("Invalid value")
  except ZeroDivisionError:
      print("Cannot divide by zero")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Try, Except with Generic Exception

  ```py
  try:
      x = 10 / 0
  except Exception as e:
      print("Error:", e)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Else Block

- Executes if no exception occurs.

  ```py
  try:
      x = 10 / 2
  except ZeroDivisionError:
      print("Error")
  else:
      print("No error, result is", x)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Finally Block

- Executes regardless of exception.

  ```py
  try:
      x = 10 / 0
  except ZeroDivisionError:
      print("Error")
  finally:
      print("Always runs")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Raising Exceptions

- Manually trigger an exception.

  ```py
  age = -5
  if age < 0:
      raise ValueError("Age cannot be negative")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Custom Exception

  ```py
  class CustomError(Exception):
      pass

  raise CustomError("This is a custom exception")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Try-Except-Else-Finally Complete Structure

  ```py
  try:
      x = int(input("Enter a number: "))
      result = 10 / x
  except ValueError:
      print("Invalid input")
  except ZeroDivisionError:
      print("Cannot divide by zero")
  else:
      print("Result is", result)
  finally:
      print("End of program")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Logging in Python**

- Logging records events, errors, and messages during program execution.
- Useful for debugging and monitoring applications.

[‚¨ÜÔ∏è Go to Context](#context)

### Import Logging Module

  ```py
  import logging
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Basic Configuration (Console Logging)

  ```py
  logging.basicConfig(level=logging.DEBUG)
  logging.debug("This is a debug message")
  logging.info("Informational message")
  logging.warning("Warning message")
  logging.error("Error occurred")
  logging.critical("Critical issue")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Logging to a File

  ```py
  log_path = "app.log"
  logging.basicConfig(
      filename=log_path,
      format="[ %(asctime)s ] %(name)s - %(levelname)s - %(message)s",
      level=logging.INFO
  )

  logging.info("This will be written to a file with timestamp and format")
  logging.warning("This is a warning")
  logging.error("This is an error")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Logging Levels

- `DEBUG` ‚Üí Detailed information, for development.
- `INFO` ‚Üí General events, program flow.
- `WARNING` ‚Üí Indicates a potential problem.
- `ERROR` ‚Üí Serious problem that prevents a function from running.
- `CRITICAL` ‚Üí Very serious error, may stop program.

[‚¨ÜÔ∏è Go to Context](#context)

### Custom Logger

  ```py
  logger = logging.getLogger("myLogger")
  logger.setLevel(logging.DEBUG)
  logger.info("Using custom logger")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Advanced Format

  ```py
  logging.basicConfig(format='%(levelname)s:%(name)s:%(message)s', level=logging.INFO)
  logging.info("Custom formatted log")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Exception Logging

  ```py
  try:
      x = 10 / 0
  except ZeroDivisionError:
      logging.exception("Exception occurred")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 12 - Building an Iron Man JARVIS System**

- JARVIS is a Python-based voice assistant that can interact with the user through speech recognition, perform tasks like opening applications, searching on Google or Wikipedia, playing music randomly, telling jokes, and having small talk.

- This project uses speech recognition and text-to-speech (TTS) to provide a hands-free assistant experience similar to Iron Man's JARVIS.

[‚¨ÜÔ∏è Go to Context](#context)

## **Features in JARVIS System**

- Greet the user according to the time of day (morning, afternoon, evening)
- Recognize voice commands using Google Speech Recognition
- Speak responses using pyttsx3
- Time & Date announcements
- Wikipedia search with spoken summary
- Open websites like Google, Facebook, YouTube
- Play random music from a specified folder
- Open system applications: Calculator, Notepad, CMD
- Open Calendar (Google Calendar via browser)
- Tell jokes and respond to basic small talk
- Exit gracefully with a voice command

[‚¨ÜÔ∏è Go to Context](#context)

## **JARVIS System Setup**

- Python `3.13` or higher
- Packages

  ```sh
  PyAudio==0.2.14
  pyttsx3==2.99
  SpeechRecognition==3.14.4
  wikipedia==1.4.0
  ```

- Create [virtual env](#create-conda-environment) then install package and run [jarvis.py](./Day%2012%20-%20Building%20an%20Iron%20Man%20JARVIS%20System/jarvis.py)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 13 - Multilingual AI Assistant**

## Extending Jarvis Chatbot

- Add new requirement `google-generativeai` to use gemini flash model `gemini-2.5-flash`
- And `python-dotenv` for loading secrete variable from `.env` like API key

  ```sh
  PyAudio==0.2.14
  pyttsx3==2.99
  SpeechRecognition==3.14.4
  wikipedia==1.4.0
  google-generativeai==0.8.5
  python-dotenv==1.2.1
  ```

- Get Free API from [Google AI Studio](https://aistudio.google.com/api-keys)
- Apply it in [jarvis.py](./Day%2013%20-%20Multilingual%20AI%20Assistant/jarvis.py)
- Use it for others query from user
- Run [jarvis.py](./Day%2013%20-%20Multilingual%20AI%20Assistant/jarvis.py)

[‚¨ÜÔ∏è Go to Context](#context)

# **Assignment 04**

- [Jarvis AI Project](https://github.com/aatansen/Jarvis-AI/)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 14 - Additional Topics, Regex**

## **Additional Topics**

### Python Code In Text Files

- We can execute a [text file](./Day%2014%20-%20Additional%20Topics,%20Regex/text_file.txt) that contains python code
  - `python text_file.txt`

[‚¨ÜÔ∏è Go to Context](#context)

### Command Line Utility

- Normal function

  ```py
  def calculator(a, b, operation):
      if operation == 'add':
          return a + b
      elif operation == 'subtract':
          return a - b
      elif operation == 'multiply':
          return a * b
      elif operation == 'divide':
          if b != 0:
              return a / b
          else:
              return "Error: Division by zero."
      else:
          return "Error: Invalid operation."

  result=calculator(3,5,'multiply')
  print(result)
  ```

- Command line utility

  ```py
  import argparse
  import sys

  def calculator(args):
      if args.o == 'add':
          return args.a + args.b
      elif args.o == 'sub':
          return args.a - args.b
      elif args.o == 'mul':
          return args.a * args.b
      elif args.o == 'div':
          if args.b != 0:
              return args.a / args.b
          else:
              return "Error: Division by zero."
      else:
          return "Error: Invalid operation."

  parser = argparse.ArgumentParser()
  parser.add_argument("--a", type=float, default=1.0)
  parser.add_argument("--b", type=float, default=2.0)
  parser.add_argument("--o", type=str, default="add")

  # args = parser.parse_args()
  # sys.stdout.write(str(calculator(args)))

  args = parser.parse_args()
  result = calculator(args)
  print(result)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Regular Expression (Regex)**

- Regular expressions, or "regex" for short, are a powerful tool for working with strings and text data in Python. They allow you to match and manipulate strings based on patterns, making it easy to perform complex string operations with just a few lines of code.
  - [Meta characters in regular expressions](https://www.ibm.com/docs/en/rational-clearquest/9.0.1?topic=tags-meta-characters-in-regular-expressions)

- **Basic Matching** ‚Äì Check if a pattern exists in a string

  ```py
  import re

  text = "I love Python"
  result = re.search("Python", text)

  print(bool(result))  # True
  ```

- **Find All Matches** ‚Äì Get all occurrences of a pattern

  ```py
  import re

  text = "cat bat rat cat"
  matches = re.findall("cat", text)

  print(matches)  # ['cat', 'cat']
  ```

- **Match at Beginning** ‚Äì Check pattern only at start of string

  ```py
  import re

  text = "Python is powerful"
  result = re.match("Python", text)

  print(bool(result))  # True
  ```

- **Character Classes** ‚Äì Match digits, words, or whitespace

  ```py
  import re

  text = "Order ID: 4598"
  digits = re.findall(r"\d+", text)

  print(digits)  # ['4598']
  ```

- **Wildcard (.)** ‚Äì Match any single character

  ```py
  import re

  text = "cat bat rat"
  matches = re.findall(".at", text)

  print(matches)  # ['cat', 'bat', 'rat']
  ```

- **Repetition (*, +, ?)** ‚Äì Control how many times a pattern repeats

  ```py
  import re

  text = "ha hahaha hahahaha"
  laughs = re.findall(r"ha+", text)

  print(laughs)  # ['ha', 'hahaha', 'hahahaha']
  ```

- **Anchors (^, $)** ‚Äì Match start or end of string

  ```py
  import re

  text = "hello"
  print(bool(re.search("^he", text)))  # True
  print(bool(re.search("lo$", text)))  # True
  ```

- **Replace Text (sub)** ‚Äì Replace matching patterns

  ```py
  import re

  text = "My number is 12345"
  masked = re.sub(r"\d", "*", text)

  print(masked)  # My number is *****
  ```

- **Split String** ‚Äì Split text using regex pattern

  ```py
  import re

  text = "apple,banana;orange"
  parts = re.split(r"[,;]", text)

  print(parts)  # ['apple', 'banana', 'orange']
  ```

- **Common Validation Example (Email)** ‚Äì Simple email format check

  ```py
  import re

  email = "test@example.com"
  pattern = r"^[\w\.-]+@[\w\.-]+\.\w+$"

  print(bool(re.match(pattern, email)))  # True
  ```

- **finditer()** ‚Äì Iterate over all matches with position details

  ```py
  text = '''Cyclone Dumazile was a strong tropical cyclone in
  the South-West Indian Ocean that affected Madagascar
  and R√©union in early March 2018. Dumazile originated
  from a Cyclone low-pressure Dyclone Pyclone area that formed
  near Agal√©ga on 27 February. It became a tropical
  disturbance on 2 March, and was named the next day
  after attaining tropical storm status.
  '''

  match_iteam = re.finditer(pattern, text)
  for match in match_iteam:
      index = match.span()
      print(text[index[0]: index[1]])
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Email Extract Using Regex

  ```py
  text = '''Cyclone Dumazile was a strong tropical cyclone in
  the South-West Indian Ocean that affected Madagascar
  and R√©union in early March 2018. Dumazile originated
  from a Cyclone low-pressure bappy@gmail.com area that formed
  near Agal√©ga on 27 February. It became a tropical
  disturbance on 2 March, and was named the next day
  after attaining tropical storm status. contact to
  contact77@gmail.com and alex.gray@amazon.co.uk
  '''
  pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
  emails = re.findall(pattern, text)
  print(emails)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Organize Files Using Python**

  ```py
  import os
  import shutil

  path = input("Enter the path: ")
  files = os.listdir(path)

  for file in files:
      filename, extension = os.path.splitext(file)
      extension = extension[1:]
      if os.path.exists(path+"/"+extension):
          shutil.move(path+"/"+file, path+"/"+extension+"/"+file)
      else:
          os.makedirs(path+"/"+extension)
          shutil.move(path+"/"+file, path+"/"+extension+"/"+file)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 15 - Introduction to OOP**

## **The Robot Problem**

- Using function

  ```py
  # Robot 1
  def movement_1():
    print("Its Robot 1")
  def fire_detection_1():
    print("Its Robot 1")
  def wheel_control_1():
    print("Its Robot 1")

  ## Robot 2
  def movement_2():
    print("Its Robot 2")
  def fire_detection_2():
    print("Its Robot 2")
  def wheel_control_2():
    print("Its Robot 2")

  movement_1()
  movement_2()
  ```

- Solution using OOP

  ```py
  # using OOP

  class Robot:

    def __init__(self, robot_number):
      self.robot_number = robot_number

    def movement(self):
      print(f"Its Robot {self.robot_number}")


    def fire_detection(self):
      print(f"Its Robot {self.robot_number}")

    def wheel_controll(self):
      print(f"Its Robot {self.robot_number}")


    def ai_intelligence(self):
      print(f"Its Robot {self.robot_number}")

  # Robot 1
  robot1 = Robot(robot_number = 1)
  robot1.movement()

  # Robot 2
  robot2 = Robot(robot_number = 2)
  robot2.movement()
  ```

- In OOP `__init__` function is contructor. In construction data properties are defined
- And methods are called functional properties

[‚¨ÜÔ∏è Go to Context](#context)

### Class & Object

- **Class** - Blueprint for creating objects

  ```py
  class Person:
      pass
  ```

- **Object** - Instance of a class

  ```py
  p = Person()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Constructor (`__init__`)

- **Basic Constructor**

  ```py
  class Person:
      def __init__(self):
          print("Object created")

  p = Person()
  ```

- **Constructor with Parameters**

  ```py
  class Person:
      def __init__(self, name, age):
          self.name = name
          self.age = age

  p = Person("Rahim", 20)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### `self` Keyword

- Refers to the **current object**

  ```py
  class Student:
      def __init__(self, name):
          self.name = name

  s = Student("Ayesha")
  print(s.name)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Instance Variables

- Variables unique to each object

  ```py
  class User:
      def __init__(self, username):
          self.username = username

  u1 = User("admin")
  u2 = User("guest")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Class Variables

- Shared among all objects

  ```py
  class Company:
      name = "Google"

  c1 = Company()
  c2 = Company()
  print(c1.name)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Instance Methods

- Methods that work with object data

  ```py
  class Car:
      def start(self):
          print("Car started")

  c = Car()
  c.start()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Class vs Object**

[‚¨ÜÔ∏è Go to Context](#context)

### Class

- A class is a **blueprint / template**
- It defines **properties (variables)** - and **behaviors (methods)**

- **Purpose**
  - Used to create multiple objects
  - Does not occupy memory until object is created

- **Example**

  ```py
  class Car:
      def start(self):
          print("Car started")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Object

- An object is a **real instance*- of a class
- Created from a class

- **Purpose**
  - Used to access class variables and methods
  - Occupies memory

- **Example**

  ```py
  c1 = Car()
  c1.start()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Key Differences in Class and Object

- **Blueprint vs Real Thing**

  - Class ‚Üí Design of a house
  - Object ‚Üí Actual house built from the design

- **Memory**

  - Class ‚Üí No memory allocation
  - Object ‚Üí Memory allocated

- **Creation**

  - Class ‚Üí Created using `class` keyword
  - Object ‚Üí Created using `ClassName()`

- **Quantity**

  - Class ‚Üí One
  - Object ‚Üí Can be many

[‚¨ÜÔ∏è Go to Context](#context)

### Multiple Objects from One Class

- **Same class, different objects**

  ```py
  class Student:
      def __init__(self, name):
          self.name = name

  s1 = Student("Rahim")
  s2 = Student("Karim")
  ```

- Class ‚Üí Logical entity
- Object ‚Üí Physical entity
- Class ‚Üí Defines methods
- Object ‚Üí Uses methods
- Class creates objects
- Objects use class features

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 16 - Writing our first Class in OOP**

## **ATM Machine Using OOP**

  ```py
  class AtmMachine:
    # constructor (special function) --> super power
    def __init__(self):
      self.pin = ""
      self.balance = 0
      self.menu()

    def menu(self):
      user_input = input(
              """
              Hi how can i help you?

              1. Press 1 to create pin
              2. Press 2 to change pin
              3. Press 3 to check balence
              4. Press 4 to withdraw
              5. Anything to exit
              """
          )

      if user_input == "1":
        # create a pin
        self.create_pin()
      elif user_input == "2":
        # change pin
        self.change_pin()
      elif user_input == "3":
        # check balence
        self.check_balance()
      elif user_input == "4":
        # withdraw
        self.withraw_balance()
      else:
        exit()

    def create_pin(self):
      user_pin = input("Enter your pin: ")
      self.pin = user_pin

      user_balance = float(input("Enter your balance: "))
      self.balance = user_balance

      print("Pin Created Successfully!")

      self.menu()

    def change_pin(self):
      old_pin = input("Enter your old pin: ")
      if old_pin == self.pin:
        new_pin = input("Enter your new pin: ")
        self.pin = new_pin
        print("Pin changed successfully!")
        self.menu()
      else:
        print("Incorrect pin!")
        self.menu()

    def check_balance(self):
      user_pin = input("Enter your pin: ")
      if user_pin == self.pin:
        print("Your balance is: ", self.balance)

      else:
        print("Your pin is incorrect, please try again!")

      self.menu()

    def withraw_balance(self):
      user_pin = input("Enter your pin: ")
      if user_pin == self.pin:
        amount = float(input("Enter the amount to withdraw: "))
        if amount <= self.balance:
          self.balance -= amount
          print(f"You have withdrawn {amount}. Your new balance is {self.balance}")
        else:
          print("Insufficient balance!")
      else:
        print("Your pin is incorrect, please try again!")

      self.menu()

  atm = AtmMachine()

  # Similarly more object can be created
  islamibank = AtmMachine()
  primebank = AtmMachine()
  citybank = AtmMachine()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 17 - Self & Encapsulation in OOP**

## **Magic Method/Dunder Method**

- Special methods with double underscore: `__method__`
- Automatically called by Python
- Used to control class behavior
- **Common Magic Methods**

  ```py
  class Test:
      def __init__(self):
          print("Object created")

      def __str__(self):
          return "Test Object"

  t = Test()
  print(t)
  ```

- **Usecase**

  - Object creation ‚Üí `__init__`
  - Object printing ‚Üí `__str__`
  - Object deletion ‚Üí `__del__`

[‚¨ÜÔ∏è Go to Context](#context)

## **Concept of **self** keyword in OOP**

- `self` refers to the **current object**
- Used to access object variables and methods
- **Why `self` is needed**
  - To differentiate object data from local variables

  ```py
  class Person:
      def set_name(self, name):
          self.name = name

  p = Person()
  p.set_name("Rahim")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **How objects access attributes in OOP**

- **Using dot (`.`) operator**

  ```py
  class Student:
      def __init__(self):
          self.name = "Ayesha"

  s = Student()
  print(s.name)
  ```

- **Access order**
  - Object ‚Üí Instance variables
  - Class ‚Üí Class variables

[‚¨ÜÔ∏è Go to Context](#context)

## **Reference Variable in OOP**

- Variable that points to an object in memory
- Object can have multiple reference variables

  ```py
  class Demo:
      pass

  a = Demo()
  b = a   # both refer to same object
  ```

- **Key point**

  - Object is not copied
  - Only reference is shared

[‚¨ÜÔ∏è Go to Context](#context)

## **Pass by reference**

- Python passes **object references**
- Changes inside function affect original object (if mutable)

  ```py
  def update(lst):
      lst.append(4)

  nums = [1, 2, 3]
  update(nums)
  print(nums)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Mutability of object in OOP**

- Can be changed after creation
- List, Dictionary, Set, Class Objects

  ```py
  lst = [1, 2]
  lst.append(3)
  ```

- **Immutable Objects**
  - Cannot be changed
  - int, float, string, tuple

  ```py
  x = 10
  x = 20
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **What is instance variable**

- Variable that belongs to an **object**
- Different for each object
- **Created inside constructor**

  ```py
  class User:
      def __init__(self, name):
          self.name = name

  u1 = User("Admin")
  u2 = User("Guest")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Encapsulation in OOP**

- Wrapping data and methods together
- Protecting data from direct access

[‚¨ÜÔ∏è Go to Context](#context)

### Types of Access Control

- **Public Variable**

  ```py
  self.name = "Rahim"
  ```

- **Protected Variable**- (`_var`)
  - Should not be accessed directly (by convention)

  ```py
  self._email = "test@mail.com"
  ```

- **Private Variable**- (`__var`)
  - Cannot be accessed directly outside class

  ```py
  self.__password = "1234"
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Getter & Setter (Encapsulation Tool)

- **Safe access to private data**

  ```py
  class Account:
      def __init__(self):
          self.__balance = 0

      def get_balance(self):
          return self.__balance

      def set_balance(self, amount):
          self.__balance = amount
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Name Mangling (Private Variable Internals)

- **How Python stores private variables**

  ```py
  print(account._Account__balance)
  ```

- **Why**
  - Prevent accidental access
  - Not true security, but protection
- **Encapsulation Benefits**
  - Data protection
  - Controlled access
  - Easier maintenance
  - Better code structure
- **Summary**
  - `self` ‚Üí current object
  - Dunder methods ‚Üí automatic behavior
  - Reference variable ‚Üí points to object
  - Mutable ‚Üí changeable
  - Instance variable ‚Üí object-specific
  - Encapsulation ‚Üí data protection

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 18 - Inheritance in OOP**

## **Collection Of Class Objects**

A collection of class objects allows you to manage multiple instances of the same class (or related classes) as a single unit. This is fundamental for modeling groups of real-world entities.

- **Homogeneous Collection:** Typically, the collection holds objects of the same class type (e.g., a list of `Employee` objects).
- **Iteration:** You can easily loop through the collection to access and process the data/methods of each individual object.
- **Encapsulation:** While the collection manages the group, each object maintains its own unique state (attributes).

**Python Example (Using a List):**

  ```py
  class Person:

    def __init__(self, name, country):
      self.name = name
      self.country = country

  p1 = Person("Bappy", "UK")
  p2 = Person("Alex", "USA")
  p3 = Person("Ahmed", "india")

  L = [p1, p2, p3]
  print(L)

  for i in L:
    print(i.name, i.country)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Static Variable in OOP**

A static variable (also commonly called a **class variable** in languages like Python) is a variable that is shared across all instances (objects) of a class. Unlike instance variables, which are unique to each object, the static variable maintains a single, persistent copy in memory for the entire class.

- **Single Copy:** Only one memory location is allocated for the static variable, no matter how many objects you create.
- **Shared State:** Any object can access and modify this single value. A change made by one object is immediately visible to all other objects.
- **Access Method:** It is typically accessed and modified using the **Class Name** directly, rather than through an object instance.
- **Common Use Case:** Counting the total number of objects created, storing a global constant specific to the class (e.g., maximum size), or logging class-wide activity.

  ```py
  class Atm:

    #static variable
    __customer_id = 0

    #constructor(special function) - superpower
    def __init__(self):
      self.pin = ""
      self.balance = 0
      Atm.__customer_id += 1
      print(Atm.__customer_id)
    ...

  obj1 = Atm() # 1
  obj2 = Atm() # 2
  ```

- For safety we define the static as private variable `__customer_id`
- To get value of static we use static method decorator

  ```py
  @staticmethod
  def get_customer_id():
    print(Atm.__customer_id)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Instance vs Static Variable in OOP**

The key difference between an Instance Variable and a Static (or Class) Variable lies in **ownership, memory allocation, and sharing** among the objects of a class.

- **Ownership:** Belongs to the **object** (instance) of the class.
- **Definition:** Declared inside the class, typically within the constructor (`__init__` in Python) and associated with the `self` or `this` keyword.
- **Memory:** A **separate copy** of the variable is created in **Heap Memory** for **every object** created from the class.
- **Sharing:** They are **not shared**. Changes made to an instance variable in one object do not affect the value in any other object.
- **Purpose:** To store data that is unique and specific to each instance (e.g., an employee's name, a car's color).
- **Access:** Accessed using the object reference (e.g., `object_name.instance_var`).

| Feature         | Instance Variable                                            | Static Variable (Class Variable)                                |
| :-------------- | :----------------------------------------------------------- | :-------------------------------------------------------------- |
| **Ownership**   | Belongs to the **object (instance)**.                        | Belongs to the **class**.                                       |
| **Memory**      | A **separate copy** for every object (in Heap Memory).       | **One single copy** shared by all objects (at the class level). |
| **Declaration** | Inside the class, typically in the constructor (`__init__`). | Inside the class, but outside all methods.                      |
| **Access**      | Requires an object reference (`obj.instance_var`).           | Accessed via the class name (`Class.static_var`).               |
| **Uniqueness**  | **Unique** value for each object.                            | **Same** shared value for all objects.                          |
| **Lifetime**    | Exists as long as the object exists.                         | Exists as long as the class is loaded (program lifetime).       |

[‚¨ÜÔ∏è Go to Context](#context)

## **Aggregation**

- Non-private attribute
- Non-private methods
- Aggregation method is deprecated currently used `Inheritance`

  ```py
  class Customer:
      def __init__(self,name,gender,address):
          self.name = name
          self.gender = gender
          self.address = address

      def print_info(self):
          print(f"Name: {self.name}, Gender: {self.gender}, Address: {self.address.city}, {self.address.pin}, {self.address.state}")



  class Address:
      def __init__(self, city, pin, state):
          self.city = city
          self.pin = pin
          self.state = state

  adds = Address("Dhaka", 1230, "Bangladesh")
  cus = Customer("Bappy", "Male",adds)
  cus.print_info()
  ```

- Aggregation Diagram

  ![aggregation diagram](https://i.imgur.com/Pz1o1SY.png)

[‚¨ÜÔ∏è Go to Context](#context)

## **DRY Principle**

DRY stands for **"Don't Repeat Yourself."** It is a fundamental software development principle that aims to reduce redundancy and repetition of information, logic, or knowledge within a system.

Every piece of knowledge must have a **single, unambiguous, authoritative representation** within the system.

| Benefit             | Description                                                                                                                                                            |
| :------------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Maintainability** | When a piece of logic needs updating, you only change it in **one central place**, reducing effort and time.                                                           |
| **Fewer Bugs**      | By centralizing logic, you eliminate the risk of introducing inconsistencies or bugs that occur when a fix is applied in one duplicated location but missed in others. |
| **Readability**     | Less repetitive code is shorter, more organized, and easier for other developers (and your future self) to read and understand.                                        |
| **Consistency**     | Ensures that a specific functionality or calculation behaves exactly the same way every time it is used.                                                               |

[‚¨ÜÔ∏è Go to Context](#context)

## **Inheritance**

Inheritance allows us to define a class that inherits all the methods and properties from another class. Parent class is the class being inherited from, also called base class. Child class is the class that inherits from another class, also called derived class.

- Non-private attribute
- Non-private methods

  ```py
  class User: #parent class
    def __init__(self):
      self.name = "Bappy"
      self.gender = "Male"
    def login(self):
      print("Login Done!")
    def register(self):
      print("register Done!")

  class Student(User): #child class
    def __init__(self):
      self.rollno = 12
    def enroll(self):
      print("Enrolled the course!")
    def review(self):
      print("Reviewing the course!")

  class Instructor(User): #child class
    def __init__(self):
      self.idno = 120
    def create(self):
      print("created the course!")
    def reply(self):
      print("Reply to student!")

  s = Student()
  s.enroll()
  s.register()
  s.login()

  I = Instructor()
  I.create()
  I.login()
  I.register()
  ```

- When a child class is instantiated and does not define its own `__init__`, Python automatically and implicitly calls the Parent class's `__init__`.
- When the child class defines its own `__init__`, it **overrides** the parent's `__init__`.
- The `super()` function allows you to explicitly call methods from the parent class, primarily the parent's constructor.

  ```py
  class User: #parent class
    def __init__(self):
      self.name = "Bappy"
      self.gender = "Male"
    def login(self):
      print("Login Done!")
    def register(self):
      print("register Done!")

  class Student(User): #child class
    def __init__(self):
      self.rollno = 12
    def enroll(self):
      print("Enrolled the course!")

  s = Student()
  s.name # error as child has constructor `self.rollno = 12`
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 19 - Polymorphism, Abstraction & Modular Coding**

## **Types of Inheritance**

### Single Inheritance

- One child inherits from **one parent**.

  ```py
  class Parent:
      def show(self):
          print("Parent class")

  class Child(Parent):
      pass

  obj = Child()
  obj.show()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Multilevel Inheritance

- A class inherits from a class that already inherits from another class.

  ```py
  class A:
      def a(self):
          print("A")

  class B(A):
      def b(self):
          print("B")

  class C(B):
      def c(self):
          print("C")

  obj = C()
  obj.a()
  obj.b()
  obj.c()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Multiple Inheritance

- A class inherits from **more than one parent class**.

  ```py
  class Father:
      def skill(self):
          print("Driving")

  class Mother:
      def talent(self):
          print("Cooking")

  class Child(Father, Mother):
      pass

  obj = Child()
  obj.skill()
  obj.talent()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Hierarchical Inheritance

- Multiple child classes inherit from **one parent**.

  ```py
  class Animal:
      def sound(self):
          print("Animal sound")

  class Dog(Animal):
      pass

  class Cat(Animal):
      pass

  Dog().sound()
  Cat().sound()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Hybrid Inheritance

- Combination of **two or more** inheritance types.

  ```py
  class A:
      def a(self):
          print("A")

  class B(A):
      def b(self):
          print("B")

  class C(A):
      def c(self):
          print("C")

  class D(B, C):
      def d(self):
          print("D")

  obj = D()
  obj.a()
  obj.b()
  obj.c()
  obj.d()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Diamond Problem (Special Case)

- Occurs in multiple inheritance when a class inherits from two classes that share a common parent.

  ```py
  class A:
      def show(self):
          print("A")

  class B(A):
      def show(self):
          print("B")

  class C(A):
      def show(self):
          print("C")

  class D(B, C):
      pass

  obj = D()
  obj.show()
  print(D.mro())
  ```

> [!NOTE]
>
> - Single        ‚Üí One parent, one child
> - Multilevel    ‚Üí Parent ‚Üí Child ‚Üí Grandchild
> - Multiple      ‚Üí Multiple parents, one child
> - Hierarchical  ‚Üí One parent, multiple children
> - Hybrid        ‚Üí Combination of inheritance types

[‚¨ÜÔ∏è Go to Context](#context)

## **Method Overriding**

- Method overriding happens when a child class provides its own implementation of a method that already exists in the parent class
  - It allows a child class to change or extend the behavior of a parent class method while keeping the same method name.
  - A feature of inheritance
  - Same method name
  - Same parameters
  - Defined in parent and child class
  - Child method replaces parent method behavior
- When we inherite the parant class the child class also need those argument when child class object is created

  ```py
  class Phone:
    def __init__(self, price, brand, camera):
      print("Inside Phone constructor")
      self.__price = price
      self.brand = brand
      self.camera = camera

    def get_price(self):
      return self.__price

    def buy(self):
      print("Buying a Phone inside Phone constructor")

  class SmartPhone(Phone):
    def buy(self):
      print("Buying a Phone inside SmartPhone constructor")

  S  = SmartPhone(200000, "apple", 3) # output: Inside Phone constructor
  S.buy() # overriding parent buy() output: Buying a Phone inside SmartPhone constructor
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Super Keyword in OOP**

- `super()` allows a child class to safely access parent class methods and constructors, especially powerful in multiple inheritance.
  - Built-in function in Python
  - Refers to the parent (super) class
  - Used inside child class
  - Commonly used in method overriding

  ```py
  class Parent:
      def show(self):
          print("This is Parent class")

  class Child(Parent):
      def show(self):
          super().show()   # call parent method
          print("This is Child class")

  obj = Child()
  obj.show()
  ```

- Accessing parent constructor properties

  ```py
  class Person:
      def __init__(self, name):
          self.name = name

  class Student(Person):
      def __init__(self, name, roll):
          super().__init__(name)   # call parent constructor
          self.roll = roll

  s = Student("Rahim", 101)
  print(s.name, s.roll)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Multilevel Inheritance**

- Inheritance allows one class to acquire properties and methods from another class. In multilevel inheritance, a class is derived from a class that is already derived from another class.
  - Involves more than two classes
  - Each class inherits from the previous class
  - Forms a hierarchy
  - Common in real-world modeling

  ```py
  class GrandParent:
      def house(self):
          print("Owns a house")

  class Parent(GrandParent):
      def car(self):
          print("Owns a car")

  class Child(Parent):
      def bike(self):
          print("Owns a bike")

  c = Child()
  c.house()
  c.car()
  c.bike()
  ```

  ```py
  class Device:
      def power_on(self):
          print("Device powered on")

  class Mobile(Device):
      def call(self):
          print("Calling...")

  class SmartPhone(Mobile):
      def internet(self):
          print("Browsing internet")

  phone = SmartPhone()
  phone.power_on()
  phone.call()
  phone.internet()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Polymorphism**

- In Object-Oriented Programming, different objects may need to respond to the same method name in different ways.
  - One interface, many forms
  - Same method name, different behavior
  - Achieved at runtime in Python
  - Strongly linked with inheritance

  ```py
  class Animal:
      def speak(self):
          print("Animal makes a sound")

  class Dog(Animal):
      def speak(self):
          print("Dog barks")

  class Cat(Animal):
      def speak(self):
          print("Cat meows")

  animals = [Dog(), Cat()]

  for a in animals:
      a.speak()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Abstraction**

- In large systems, exposing all internal details makes code complex and hard to maintain.
  - Hides internal implementation
  - Shows essential features only
  - Focuses on what an object does, not how
  - Achieved using abstract classes & interfaces (conceptually)

  ```py
  from abc import ABC, abstractmethod

  class Payment(ABC):
      @abstractmethod
      def pay(self):
          pass

  class Bkash(Payment):
      def pay(self):
          print("Payment using bKash")

  class Card(Payment):
      def pay(self):
          print("Payment using Card")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Modular Coding**

- Breaking a large program into smaller modules
- Each module is a separate file
- Modules can contain functions, classes, or variables
- Modules are imported where needed
- Improves readability
- Easier maintenance
- Encourages reuse
- Simplifies testing
- Supports team collaboration
- Example
  - `calculator.py` file content

    ```py
    # calculator.py
    def add(a, b):
        return a + b

    def sub(a, b):
        return a - b
    ```

  - Using `calculator.py` function in `main.py`

    ```py
    # main.py
    import calculator

    print(calculator.add(10, 5))
    print(calculator.sub(10, 5))
    ```

- Project structure of [ATM Machine](./Day%2019%20-%20Polymorphism,%20Abstraction%20&%20Modular%20Coding/atm_project/)

  ```txt
  atm_project
  ‚îú‚îÄ‚îÄ üìÅ core
  ‚îÇ   ‚îú‚îÄ‚îÄ üêç __init__.py
  ‚îÇ   ‚îú‚îÄ‚îÄ üêç auth.py
  ‚îÇ   ‚îú‚îÄ‚îÄ üêç database.py
  ‚îÇ   ‚îî‚îÄ‚îÄ üêç transactions.py
  ‚îú‚îÄ‚îÄ üìù README.md
  ‚îî‚îÄ‚îÄ üêç main.py
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 20 - Mega OOP Project**

## Gemini CLI Text Analyzer (NLP)

A simple **Python command-line application*- that uses **Google Gemini (Generative AI)*- to perform basic NLP tasks like sentiment analysis, language translation, and language detection.

The app also includes a **basic in-memory user registration and login system**.

- Features
  - User Registration & Login (in-memory)
  - Sentiment Analysis
  - Language Translation (English ‚Üí Bangla)
  - Language Detection
  - Uses Google Gemini API (`gemini-2.5-flash`)
  - Environment variable support using `python-dotenv`

- Tech Stack
  - Python
  - google-generativeai (Gemini)
  - python-dotenv

- Project Structure
  - `BaseModel`
    - Handles Gemini API configuration
    - Returns the AI model instance
  - `AppFeatures`
    - User authentication (register/login)
    - Menu-based CLI navigation
    - NLP features using Gemini

- Requirements
  - Python 3.9+
  - Google Gemini API Key

- Installation

  ```sh
  pip install google-generativeai python-dotenv
  ```

- Environment Setup

  - Create a `.env` file in the root directory and add:

  ```env
  GEMINI_API_KEY=your_api_key_here
  ```

- Run The App

  ```sh
  python app.py
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 21 - Decorator, Iterators & Generator**

## **Namespaces**

- A **mapping of names to objects**
- Prevents naming conflicts
- Determines **where** a name is accessible

  ```py
  x = 10
  ```

Here, `x` exists in a namespace.

[‚¨ÜÔ∏è Go to Context](#context)

### Types of Namespaces in Python

#### 1. Built-in Namespace

- Contains built-in functions and keywords
- Available everywhere

Examples:

```py
print()
len()
int()
```

[‚¨ÜÔ∏è Go to Context](#context)

#### 2. Global Namespace

- Created when a module is loaded
- Names defined at the top level of a file

  ```py
  x = 100   # global namespace

  def show():
      pass
  ```

[‚¨ÜÔ∏è Go to Context](#context)

#### 3. Local Namespace

- Created when a function is called
- Exists only inside that function

  ```py
  def demo():
      y = 50   # local namespace
      print(y)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Namespace Lifetime

- Built-in ‚Üí Exists until interpreter exits
- Global   ‚Üí Exists until module execution ends
- Local    ‚Üí Exists during function call

[‚¨ÜÔ∏è Go to Context](#context)

### LEGB Rule (Name Resolution Order)

- L ‚Üí Local
- E ‚Üí Enclosing (nested functions)
- G ‚Üí Global
- B ‚Üí Built-in

  ```py
  x = "global"

  def outer():
      x = "enclosing"
      def inner():
          x = "local"
          print(x)
      inner()

  outer()
  ```

- **Output**

  ```txt
  local
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Global Keyword

  ```py
  x = 10

  def change():
      global x
      x = 20

  change()
  print(x)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Nonlocal Keyword

  ```py
  def outer():
      x = 5
      def inner():
          nonlocal x
          x = 10
      inner()
      print(x)

  outer()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Checking Namespaces

  ```py
  print(globals())
  print(locals())
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Namespace vs Scope

- Namespace ‚Üí Where names are stored
- Scope     ‚Üí Where names are accessible

[‚¨ÜÔ∏è Go to Context](#context)

## **Decorator**

- A **function that modifies another function**
- Uses the `@decorator_name` syntax
- Works because **functions are first-class objects**
- Commonly used for logging, authentication, timing, caching
- Code reusability
- Cleaner function logic
- Separation of concerns
- Easy to apply/remove behavior

- Basic Decorator Example

  ```py
  def my_decorator(func):
      def wrapper():
          print("Before function call")
          func()
          print("After function call")
      return wrapper

  @my_decorator
  def say_hello():
      print("Hello!")

  say_hello()
  ```

- **Output**

  ```txt
  Before function call
  Hello!
  After function call
  ```

- Decorator Without `@` Syntax

  ```py
  def say_hi():
      print("Hi")

  say_hi = my_decorator(say_hi)
  say_hi()
  ```

- Decorator with Arguments

  ```py
  def my_decorator(func):
      def wrapper(*args, **kwargs):
          print("Before function")
          return func(*args, **kwargs)
      return wrapper

  @my_decorator
  def add(a, b):
      return a + b

  print(add(2, 3))
  ```

- Using `functools.wraps` (Best Practice)

  ```py
  from functools import wraps

  def my_decorator(func):
      @wraps(func)
      def wrapper(*args, **kwargs):
          return func(*args, **kwargs)
      return wrapper
  ```

- Preserves function name and docstring
- Important for debugging and documentation

- Authentication using Decorator

  ```py
  def login_required(func):
      def wrapper(user):
          if not user:
              print("Login required")
              return
          return func(user)
      return wrapper

  @login_required
  def dashboard(user):
      print("Welcome to dashboard")

  dashboard(None)
  dashboard("Admin")
  ```

- Decorators with Parameters

  ```py
  def repeat(n):
      def decorator(func):
          def wrapper(*args, **kwargs):
              for _ in range(n):
                  func(*args, **kwargs)
          return wrapper
      return decorator

  @repeat(3)
  def greet():
      print("Hello")

  greet()
  ```

- Class-Based Decorator

  ```py
  class MyDecorator:
      def __init__(self, func):
          self.func = func

      def __call__(self):
          print("Before call")
          self.func()
          print("After call")

  @MyDecorator
  def hello():
      print("Hello")

  hello()
  ```

- Common Built-in Decorators

  ```py
  @staticmethod
  @classmethod
  @property
  ```

- Example

  ```py
  class Demo:
      @staticmethod
      def show():
          print("Static method")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Iterators**

- **Iteration**: Iteration is a general term for taking each item of something, one after another. Any time you use a loop, explicit or implicit, to go over a group of items, that is iteration.

  ```py
  num = [1,2,3]

  for i in num:
    print(i)
  ```

- **Iterator**: An Iterator is an object that allows the programmer to traverse through a sequence of data without having to store the entire data in the memory. It produce values one at a time during iteration and remember their current state.

  ```py
  nums = [1, 2, 3]
  it = iter(nums)

  print(next(it))
  print(next(it))
  print(next(it))
  ```

- **Iterables**: Iterables are objects that can be looped over and provide an iterator when passed to the iter() function.
  - `list`
  - `tuple`
  - `set`
  - `string`
  - `dictionary`
  - `range`

- Iterable vs Iterator
  - Iterable
    - Can be iterated over
    - Returns a new iterator
    - Has `__iter__()`
    - Example: `list`, `tuple`, `string`
  - Iterator
    - Produces values
    - Remembers state
    - Has `__iter__()` and `__next__()`
    - Example: `iter(list)`

> [!NOTE]
>
> - Iterable ‚Üí Object you can loop over (list, tuple, set, string)
> - Iterator ‚Üí Object that produces values using `__next__()`

[‚¨ÜÔ∏è Go to Context](#context)

## **Generators**

- A **generator** is a function that:
  - Returns an iterator
  - Uses `yield` instead of `return`
  - It **pauses execution**, remembers state, and resumes later
- Generators are a way to create **iterators** easily
- It allow us to **produce values one at a time**, instead of storing everything in memory
- Especially useful for:
  - Large data processing
  - Streams
  - Infinite sequences
  - Performance-critical code

  ```py
  def count_up():
      yield 1
      yield 2
      yield 3
  ```

- Calling the function does **not** run it immediately

  ```py
  g = count_up()
  ```

- Values are produced only when requested

  ```py
  print(next(g))  # 1
  print(next(g))  # 2
  print(next(g))  # 3
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Generator vs Normal Function

- Normal Function

  ```py
  def get_numbers():
      return [1, 2, 3]
  ```

- Executes fully
- Returns all values at once
- Uses memory to store everything

- Generator Function

  ```py
  def get_numbers():
      yield 1
      yield 2
      yield 3
  ```

- Executes lazily
- Produces values one by one
- Very memory efficient

[‚¨ÜÔ∏è Go to Context](#context)

### `yield` Keyword Explained

- `yield`:

  - Sends a value to the caller
  - Pauses the function
  - Saves local variables & execution state

- Execution Flow

  ```py
  def demo():
      print("Start")
      yield 1
      print("Middle")
      yield 2
      print("End")
  ```

- Calling step-by-step

  ```py
  g = demo()
  next(g)  # prints "Start", returns 1
  next(g)  # prints "Middle", returns 2
  next(g)  # prints "End", StopIteration raised
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Generator is an Iterator

- Generators:

  - Implement `__iter__()`
  - Implement `__next__()`
- Can be used in loops directly

  ```py
  for value in count_up():
      print(value)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Generator Expression

- Produces values lazily
- Uses far less memory
- Similar to list comprehensions
- Use `()` instead of `[]`

  ```py
  nums = (x * 2 for x in range(5))
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### `yield` vs `return`

- `return`
  - Ends function execution
- `yield`
  - Pauses function
  - Can be used multiple times

  ```py
  def test():
      yield 1
      return
      yield 2  # never runs
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Where To Use Generators

- Data is large
- Don‚Äôt need random access
- Avoid generators when need to reuse values multiple times
- Prefer generator expressions for simple transformations
- Always close resources properly

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 22 - User Interface (UI) Creation**

## **Design simple UI**

- Official docs: [Streamlit Fundamentals](https://docs.streamlit.io/get-started/fundamentals/main-concepts)
- Transform CLI interface of [Day 20 - Mega OOP Project](./Day%2020%20-%20Mega%20OOP%20Project/) to [Day 22 - User Interface (UI) Creation](./Day%2022%20-%20User%20Interface%20(UI)%20Creation/) GUI interface
- To save data locally `st.session_state` is used
- Full code can be found in [Day 22 - User Interface (UI) Creation/app.py](./Day%2022%20-%20User%20Interface%20(UI)%20Creation/app.py)

[‚¨ÜÔ∏è Go to Context](#context)

# **Assignment 05**

- [Personal AI Project](https://github.com/aatansen/Personal-AI-Assistant/)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 23 - PyPI Package Discussion**

## **PyPI Package**

- **PyPI (Python Package Index)** is the official repository where Python developers publish and share reusable Python packages.
- Website: pypi.org
- Similar idea to
  - npm for JavaScript
  - Maven Central for Java

[‚¨ÜÔ∏è Go to Context](#context)

### What is a Python Package?

- A **package** is a collection of Python modules bundled together.
- Used to:
  - Reuse code
  - Avoid writing everything from scratch
  - Share solutions with others
- Examples:
  - requests ‚Üí HTTP requests
  - numpy ‚Üí numerical computing
  - django ‚Üí web framework

[‚¨ÜÔ∏è Go to Context](#context)

### Package Manager: `pip`

- `pip` is the tool used to install packages from PyPI.

- Common commands:
  - `pip install package_name`
  - `pip uninstall package_name`
  - `pip list`
  - `pip show package_name`
  - `pip install --upgrade package_name`

[‚¨ÜÔ∏è Go to Context](#context)

### Requirements File

- Used to manage dependencies `requirements.txt`

  ```txt
  django==4.2.3
  requests>=2.28
  numpy
  ```

- Installation
  - `pip install -r requirements.txt`

[‚¨ÜÔ∏è Go to Context](#context)

### Virtual Environments

- Isolate project dependencies.
- Prevent version conflicts.
  - `python -m venv venv`
  - `venv\Scripts\activate`

[‚¨ÜÔ∏è Go to Context](#context)

### How a Package is Structured

- Basic structure:

  ```txt
  mypackage/
    ‚îú‚îÄ‚îÄ mypackage/
    ‚îÇ    ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ    ‚îî‚îÄ‚îÄ core.py
    ‚îú‚îÄ‚îÄ setup.py / pyproject.toml
    ‚îú‚îÄ‚îÄ README.md
    ‚îî‚îÄ‚îÄ LICENSE
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Publishing a Package to PyPI

- Create account on PyPI
- Prepare package metadata
- Build distribution
- Upload using `twine`
- Modern tools
  - `setuptools`
  - `poetry`
  - `flit`

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 24,25 - Publish Package to PyPI**

## **Youtube Notebook Embed Package**

### Day 24 - Project Setup

- Create `.venv`
- Generate project structure by running `template.py`
- Add required packages in `requirements.txt` and `requirements-dev.txt`
- Write `setup.py` and `setup.cfg`
- Now define `pyproject.toml`
- Install `requirements-dev.txt`
- Define `logger.py` and `custom_exception.py` inside `src/ytnb-embed` path
- Write test run in `tox.ini` and create `tests/integration/test_int.py` & `tests/unit/test_unit.py` files
- Now to integrate CI/CD create `.github/workflows/ci.yml` for CI integration
- Push to github to see the github action running

[‚¨ÜÔ∏è Go to Context](#context)

### Day 25 - Publish to PyPI

- Add youtube embed functionality in `src/ytnb_embed/youtube.py`
- Now create [PyPI account](https://pypi.org/account/register/)
- Get API
- Setup secrete in Github Action secrete
  - [https://github.com/aatansen/REPO_NAME/settings/secrets/actions](https://github.com/aatansen/REPO_NAME/settings/secrets/actions)
  - Add `PYPI_API_TOKEN` in New repository secret
- Now in every push it will test using `tox` and in every release it will release it to the `PyPI`

> [!NOTE]
>
> - Final Project Repository --> [ytnb-embed](https://github.com/aatansen/ytnb-embed)

[‚¨ÜÔ∏è Go to Context](#context)