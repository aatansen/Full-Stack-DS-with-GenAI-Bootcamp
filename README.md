<div align="center">
<h1>Full Stack DS with GenAI Bootcamp</h1>

> *Notes, Assignments of Full Stack DS with GenAI Bootcamp*
</div>

# **Context**
- [**Context**](#context)
- [**Day 01 - Induction Session**](#day-01---induction-session)
  - [**Session and Overview**](#session-and-overview)
    - [Introduction](#introduction)
- [**Day 02 - Introduction to AI \& System Setup**](#day-02---introduction-to-ai--system-setup)
  - [**Introduction to AI**](#introduction-to-ai)
    - [What is AI?](#what-is-ai)
    - [What is Data Science?](#what-is-data-science)
    - [Career Opportunities](#career-opportunities)
    - [Importance of DS](#importance-of-ds)
    - [Application of AI](#application-of-ai)
    - [Venn Diagram](#venn-diagram)
    - [AI Project Development Life Cycle](#ai-project-development-life-cycle)
    - [Different Roles in AI](#different-roles-in-ai)
  - [**System Setup Tools**](#system-setup-tools)
- [**Day 03 - Introduction And Basic Of Python**](#day-03---introduction-and-basic-of-python)
  - [**Introduction to Python \& Setup**](#introduction-to-python--setup)
  - [**Write our first Program in Python**](#write-our-first-program-in-python)
    - [print() Function Parameters in Python](#print-function-parameters-in-python)
  - [**Operators in Python**](#operators-in-python)
  - [**Python Data Types \& Comments**](#python-data-types--comments)
  - [**Variables, Keywords \& Identifiers in Python**](#variables-keywords--identifiers-in-python)
    - [Variables](#variables)
    - [Keywords](#keywords)
    - [Identifiers](#identifiers)
  - [**Python Input**](#python-input)
  - [**Type Conversion in Python**](#type-conversion-in-python)
  - [**Literals in Python**](#literals-in-python)
- [**Day 04 - Conditional Statements, Pip, Modules \& Loops**](#day-04---conditional-statements-pip-modules--loops)
  - [**Conditional Statements**](#conditional-statements)
  - [**PIP (Pip Installs Packages)**](#pip-pip-installs-packages)
  - [**Modules in Python**](#modules-in-python)
  - [**Loops in Python**](#loops-in-python)
- [**Assignment 01**](#assignment-01)
- [**Day 05 - Loops in Python**](#day-05---loops-in-python)
  - [**Loops Recap**](#loops-recap)
  - [**Loop Control Statements**](#loop-control-statements)
  - [**Code Visualization Tool**](#code-visualization-tool)
- [**Day 06 - Strings in Python**](#day-06---strings-in-python)
  - [**Strings in Python**](#strings-in-python)
    - [Creating Strings](#creating-strings)
    - [Accessing Strings](#accessing-strings)
    - [Adding Chars to Strings](#adding-chars-to-strings)
    - [Editing Strings](#editing-strings)
    - [Deleting Strings](#deleting-strings)
    - [Operations on Strings](#operations-on-strings)
    - [String Functions](#string-functions)
    - [String Methods](#string-methods)
  - [**Strings Exercise**](#strings-exercise)
    - [Find the length of a given string without using the len() function](#find-the-length-of-a-given-string-without-using-the-len-function)
    - [Extract username from a given email](#extract-username-from-a-given-email)
- [**Day 07 - List in Python**](#day-07---list-in-python)
  - [**List in Python**](#list-in-python)
    - [What are Lists?](#what-are-lists)
    - [Lists Vs Arrays](#lists-vs-arrays)
    - [Characteristics of a List](#characteristics-of-a-list)
    - [How to create a list](#how-to-create-a-list)
    - [Access items from a List](#access-items-from-a-list)
    - [List Methods](#list-methods)
    - [List Functions](#list-functions)
    - [Editing items in a List](#editing-items-in-a-list)
    - [Deleting items from a List](#deleting-items-from-a-list)
    - [Operations on Lists](#operations-on-lists)
    - [List comprehension](#list-comprehension)
    - [`zip()` Function in Python](#zip-function-in-python)
- [**Assignment 02**](#assignment-02)
- [**Day 08 - Tuples, Sets \& Dictionary**](#day-08---tuples-sets--dictionary)
  - [**Tuples**](#tuples)
    - [Creating a Tuple](#creating-a-tuple)
    - [Accessing Items in Tuple](#accessing-items-in-tuple)
    - [Editing Items in Tuple](#editing-items-in-tuple)
    - [Adding Items in Tuple](#adding-items-in-tuple)
    - [Deleting Items in Tuple](#deleting-items-in-tuple)
    - [Operations on Tuples](#operations-on-tuples)
    - [Tuple Methods](#tuple-methods)
    - [Tuple Functions](#tuple-functions)
    - [Tuple Unpacking](#tuple-unpacking)
    - [Using `zip()` with Tuples](#using-zip-with-tuples)
    - [Tuple Comprehension](#tuple-comprehension)
    - [List vs Tuple](#list-vs-tuple)
  - [**Sets**](#sets)
    - [Creating a Set](#creating-a-set)
    - [Accessing Items in Set](#accessing-items-in-set)
    - [Editing Items in Set](#editing-items-in-set)
    - [Adding Items in Set](#adding-items-in-set)
    - [Deleting Items in Set](#deleting-items-in-set)
    - [Operations on Set](#operations-on-set)
    - [Set Methods](#set-methods)
    - [Set Functions](#set-functions)
    - [Frozenset in Python](#frozenset-in-python)
    - [Set Comprehension](#set-comprehension)
    - [Using `zip()` with Sets](#using-zip-with-sets)
  - [**Dictionary**](#dictionary)
    - [Creating a Dictionary](#creating-a-dictionary)
    - [Accessing Items in Dictionary](#accessing-items-in-dictionary)
    - [Editing Items in Dictionary](#editing-items-in-dictionary)
    - [Adding Items in Dictionary](#adding-items-in-dictionary)
    - [Deleting Items in Dictionary](#deleting-items-in-dictionary)
    - [Operations on Dictionary](#operations-on-dictionary)
    - [Dictionary Methods](#dictionary-methods)
    - [Dictionary Functions](#dictionary-functions)
    - [Dictionary Unpacking](#dictionary-unpacking)
    - [Using `zip()` with Dictionary](#using-zip-with-dictionary)
    - [Dictionary Comprehension](#dictionary-comprehension)
    - [Simple Project Using Dictionary](#simple-project-using-dictionary)
- [**Day 09 - Functions in Python**](#day-09---functions-in-python)
  - [**Functions in Python**](#functions-in-python)
    - [Characteristics of Function](#characteristics-of-function)
    - [Creating a Function](#creating-a-function)
    - [Parameter vs Argument](#parameter-vs-argument)
    - [Types of Arguments](#types-of-arguments)
    - [`*args` vs `**kwargs`](#args-vs-kwargs)
    - [Variable Scope in Functions](#variable-scope-in-functions)
    - [Nested Functions](#nested-functions)
    - [Functions are First-Class Citizens](#functions-are-first-class-citizens)
    - [Benefits of Using a Function](#benefits-of-using-a-function)
    - [Lambda Function](#lambda-function)
    - [Lambda vs Normal Function](#lambda-vs-normal-function)
    - [Higher-Order Functions](#higher-order-functions)
    - [`enumerate()` Function](#enumerate-function)
- [**Day 10 - Virtual Environment \& Requirements**](#day-10---virtual-environment--requirements)
  - [**Virtual Environment**](#virtual-environment)
    - [Create Conda Environment](#create-conda-environment)
    - [List and Remove Conda Environments](#list-and-remove-conda-environments)
  - [**Requirements**](#requirements)
    - [`requirements.txt` file](#requirementstxt-file)
- [**Assignment 03**](#assignment-03)
- [**Day 11 - File Handling, Exception Handling and Logging**](#day-11---file-handling-exception-handling-and-logging)
  - [**File Handling**](#file-handling)
    - [What is File Handling?](#what-is-file-handling)
    - [File Modes](#file-modes)
    - [File Handling Using `Open` All Modes](#file-handling-using-open-all-modes)
    - [File Handling Using `with` All Modes](#file-handling-using-with-all-modes)
    - [`Open` vs `With` in Python](#open-vs-with-in-python)
    - [Serialization and Deserialization](#serialization-and-deserialization)
    - [Pickling in Python](#pickling-in-python)
    - [JSON Dump vs Pickling](#json-dump-vs-pickling)
    - [File Handling Using `os` Module](#file-handling-using-os-module)
  - [**Exception Handling in Python**](#exception-handling-in-python)
    - [Try and Except](#try-and-except)
    - [Try, Except with Multiple Exceptions](#try-except-with-multiple-exceptions)
    - [Try, Except with Generic Exception](#try-except-with-generic-exception)
    - [Else Block](#else-block)
    - [Finally Block](#finally-block)
    - [Raising Exceptions](#raising-exceptions)
    - [Custom Exception](#custom-exception)
    - [Try-Except-Else-Finally Complete Structure](#try-except-else-finally-complete-structure)
  - [**Logging in Python**](#logging-in-python)
    - [Import Logging Module](#import-logging-module)
    - [Basic Configuration (Console Logging)](#basic-configuration-console-logging)
    - [Logging to a File](#logging-to-a-file)
    - [Logging Levels](#logging-levels)
    - [Custom Logger](#custom-logger)
    - [Advanced Format](#advanced-format)
    - [Exception Logging](#exception-logging)
- [**Day 12 - Building an Iron Man JARVIS System**](#day-12---building-an-iron-man-jarvis-system)
  - [**Features in JARVIS System**](#features-in-jarvis-system)
  - [**JARVIS System Setup**](#jarvis-system-setup)
- [**Day 13 - Multilingual AI Assistant**](#day-13---multilingual-ai-assistant)
  - [Extending Jarvis Chatbot](#extending-jarvis-chatbot)
- [**Assignment 04**](#assignment-04)
- [**Day 14 - Additional Topics, Regex**](#day-14---additional-topics-regex)
  - [**Additional Topics**](#additional-topics)
    - [Python Code In Text Files](#python-code-in-text-files)
    - [Command Line Utility](#command-line-utility)
  - [**Regular Expression (Regex)**](#regular-expression-regex)
    - [Email Extract Using Regex](#email-extract-using-regex)
  - [**Organize Files Using Python**](#organize-files-using-python)
- [**Day 15 - Introduction to OOP**](#day-15---introduction-to-oop)
  - [**The Robot Problem**](#the-robot-problem)
    - [Class \& Object](#class--object)
    - [Constructor (`__init__`)](#constructor-__init__)
    - [`self` Keyword](#self-keyword)
    - [Instance Variables](#instance-variables)
    - [Class Variables](#class-variables)
    - [Instance Methods](#instance-methods)
  - [**Class vs Object**](#class-vs-object)
    - [Class](#class)
    - [Object](#object)
    - [Key Differences in Class and Object](#key-differences-in-class-and-object)
    - [Multiple Objects from One Class](#multiple-objects-from-one-class)
- [**Day 16 - Writing our first Class in OOP**](#day-16---writing-our-first-class-in-oop)
  - [**ATM Machine Using OOP**](#atm-machine-using-oop)
- [**Day 17 - Self \& Encapsulation in OOP**](#day-17---self--encapsulation-in-oop)
  - [**Magic Method/Dunder Method**](#magic-methoddunder-method)
  - [**Concept of **self** keyword in OOP**](#concept-of-self-keyword-in-oop)
  - [**How objects access attributes in OOP**](#how-objects-access-attributes-in-oop)
  - [**Reference Variable in OOP**](#reference-variable-in-oop)
  - [**Pass by reference**](#pass-by-reference)
  - [**Mutability of object in OOP**](#mutability-of-object-in-oop)
  - [**What is instance variable**](#what-is-instance-variable)
  - [**Encapsulation in OOP**](#encapsulation-in-oop)
    - [Types of Access Control](#types-of-access-control)
    - [Getter \& Setter (Encapsulation Tool)](#getter--setter-encapsulation-tool)
    - [Name Mangling (Private Variable Internals)](#name-mangling-private-variable-internals)
- [**Day 18 - Inheritance in OOP**](#day-18---inheritance-in-oop)
  - [**Collection Of Class Objects**](#collection-of-class-objects)
  - [**Static Variable in OOP**](#static-variable-in-oop)
  - [**Instance vs Static Variable in OOP**](#instance-vs-static-variable-in-oop)
  - [**Aggregation**](#aggregation)
  - [**DRY Principle**](#dry-principle)
  - [**Inheritance**](#inheritance)
- [**Day 19 - Polymorphism, Abstraction \& Modular Coding**](#day-19---polymorphism-abstraction--modular-coding)
  - [**Types of Inheritance**](#types-of-inheritance)
    - [Single Inheritance](#single-inheritance)
    - [Multilevel Inheritance](#multilevel-inheritance)
    - [Multiple Inheritance](#multiple-inheritance)
    - [Hierarchical Inheritance](#hierarchical-inheritance)
    - [Hybrid Inheritance](#hybrid-inheritance)
    - [Diamond Problem (Special Case)](#diamond-problem-special-case)
  - [**Method Overriding**](#method-overriding)
  - [**Super Keyword in OOP**](#super-keyword-in-oop)
  - [**Multilevel Inheritance**](#multilevel-inheritance-1)
  - [**Polymorphism**](#polymorphism)
  - [**Abstraction**](#abstraction)
  - [**Modular Coding**](#modular-coding)
- [**Day 20 - Mega OOP Project**](#day-20---mega-oop-project)
  - [Gemini CLI Text Analyzer (NLP)](#gemini-cli-text-analyzer-nlp)
- [**Day 21 - Decorator, Iterators \& Generator**](#day-21---decorator-iterators--generator)
  - [**Namespaces**](#namespaces)
    - [Types of Namespaces in Python](#types-of-namespaces-in-python)
      - [1. Built-in Namespace](#1-built-in-namespace)
      - [2. Global Namespace](#2-global-namespace)
      - [3. Local Namespace](#3-local-namespace)
    - [Namespace Lifetime](#namespace-lifetime)
    - [LEGB Rule (Name Resolution Order)](#legb-rule-name-resolution-order)
    - [Global Keyword](#global-keyword)
    - [Nonlocal Keyword](#nonlocal-keyword)
    - [Checking Namespaces](#checking-namespaces)
    - [Namespace vs Scope](#namespace-vs-scope)
  - [**Decorator**](#decorator)
  - [**Iterators**](#iterators)
  - [**Generators**](#generators)
    - [Generator vs Normal Function](#generator-vs-normal-function)
    - [`yield` Keyword Explained](#yield-keyword-explained)
    - [Generator is an Iterator](#generator-is-an-iterator)
    - [Generator Expression](#generator-expression)
    - [`yield` vs `return`](#yield-vs-return)
    - [Where To Use Generators](#where-to-use-generators)
- [**Day 22 - User Interface (UI) Creation**](#day-22---user-interface-ui-creation)
  - [**Design simple UI**](#design-simple-ui)
- [**Assignment 05**](#assignment-05)
- [**Day 23 - PyPI Package Discussion**](#day-23---pypi-package-discussion)
  - [**PyPI Package**](#pypi-package)
    - [What is a Python Package?](#what-is-a-python-package)
    - [Package Manager: `pip`](#package-manager-pip)
    - [Requirements File](#requirements-file)
    - [Virtual Environments](#virtual-environments)
    - [How a Package is Structured](#how-a-package-is-structured)
    - [Publishing a Package to PyPI](#publishing-a-package-to-pypi)
- [**Day 24,25 - Publish Package to PyPI**](#day-2425---publish-package-to-pypi)
  - [**Youtube Notebook Embed Package**](#youtube-notebook-embed-package)
    - [Day 24 - Project Setup](#day-24---project-setup)
    - [Day 25 - Publish to PyPI](#day-25---publish-to-pypi)
- [**Day 26 - MongoDB with Python**](#day-26---mongodb-with-python)
  - [**SQL vs NoSQL**](#sql-vs-nosql)
  - [**MongoDB Diagram**](#mongodb-diagram)
  - [**MongoDB Setup And Operations**](#mongodb-setup-and-operations)
- [**Day 27 - MySQL Using Python**](#day-27---mysql-using-python)
  - [**Setup MySQL**](#setup-mysql)
  - [**MySQL Diagram**](#mysql-diagram)
  - [**MySQL Operations**](#mysql-operations)
- [**Day 28 - Jarvis Using Arduino**](#day-28---jarvis-using-arduino)
  - [**JARVIS Smart Home Controller**](#jarvis-smart-home-controller)
  - [**Smart Home Features**](#smart-home-features)
  - [**Arduino Jarvis System Diagram**](#arduino-jarvis-system-diagram)
  - [**JARVIS Smart Home Setup and Usage**](#jarvis-smart-home-setup-and-usage)
  - [**How to Run JARVIS Smart Home**](#how-to-run-jarvis-smart-home)
- [**Day 29 - Flask API**](#day-29---flask-api)
  - [**Flask and Postman Setup**](#flask-and-postman-setup)
  - [**Flask Usages**](#flask-usages)
  - [**Flask Implementation**](#flask-implementation)
  - [**Project Structure of Flask**](#project-structure-of-flask)
- [**Day 30 - FastAPI**](#day-30---fastapi)
  - [**FastAPI Setup**](#fastapi-setup)
  - [**FastAPI Usages**](#fastapi-usages)
  - [**FastAPI Implementation**](#fastapi-implementation)
  - [**Project Structure of FastAPI**](#project-structure-of-fastapi)
- [**Day 31 - Pandas for Data Science**](#day-31---pandas-for-data-science)
  - [**Pandas Setup**](#pandas-setup)
  - [**Pandas Intro**](#pandas-intro)
  - [**Loading DataFrames from Files**](#loading-dataframes-from-files)
  - [**Viewing \& Sampling Data**](#viewing--sampling-data)
  - [**Accessing Data with loc and iloc**](#accessing-data-with-loc-and-iloc)
  - [**Index Manipulation**](#index-manipulation)
  - [**Setting \& Updating Values**](#setting--updating-values)
  - [**Column Access Techniques**](#column-access-techniques)
  - [**Sorting Data**](#sorting-data)
  - [**Iterating Over DataFrame (Not Recommended for Big Data)**](#iterating-over-dataframe-not-recommended-for-big-data)
  - [**Filtering Data**](#filtering-data)
  - [**Adding, Removing \& Renaming Columns**](#adding-removing--renaming-columns)
  - [**Date \& Time Handling**](#date--time-handling)
  - [**Exporting Data**](#exporting-data)
  - [**Row-wise Logic with apply()**](#row-wise-logic-with-apply)
  - [**Merging \& Joining DataFrames**](#merging--joining-dataframes)
  - [**Handling Missing (NaN) Values**](#handling-missing-nan-values)
  - [**Aggregation \& Grouping**](#aggregation--grouping)
  - [**Pivot Tables (Reshaping Data)**](#pivot-tables-reshaping-data)
- [**Day 32 - Numpy for Data Science**](#day-32---numpy-for-data-science)
  - [**NumPy Setup**](#numpy-setup)
  - [**Creating NumPy Arrays**](#creating-numpy-arrays)
  - [**Array Attributes**](#array-attributes)
  - [**Common Array Creation Methods**](#common-array-creation-methods)
  - [**Random Numbers**](#random-numbers)
  - [**Array Indexing**](#array-indexing)
  - [**Array Slicing**](#array-slicing)
  - [**Boolean Indexing**](#boolean-indexing)
  - [**Array Operations (Vectorization)**](#array-operations-vectorization)
  - [**Mathematical Functions**](#mathematical-functions)
  - [**Reshaping Arrays**](#reshaping-arrays)
  - [**Broadcasting**](#broadcasting)
  - [**Copy vs View**](#copy-vs-view)
  - [**Sorting \& Searching**](#sorting--searching)
  - [**Stacking \& Splitting**](#stacking--splitting)
  - [**Linear Algebra**](#linear-algebra)
  - [**File I/O with NumPy**](#file-io-with-numpy)
  - [**NumPy vs Python Lists**](#numpy-vs-python-lists)
  - [**When to Use NumPy**](#when-to-use-numpy)

# **Day 01 - Induction Session**

## **Session and Overview**

### Introduction

- Overview on
  - Github
  - Linkedin
  - Email
  - Assignment Submission

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 02 - Introduction to AI & System Setup**

## **Introduction to AI**

### What is AI?

- Artificial Intelligence (AI) is the creation of computer systems that can simulate human intelligence to perform tasks.
- In short, AI allows machines to:
  - Learn from data.
  - Reason and solve problems.
  - Make decisions or take actions (like recognizing speech or driving a car)

[‚¨ÜÔ∏è Go to Context](#context)

### What is Data Science?

- Data Science is an interdisciplinary field that uses scientific methods, processes,algorithms, and systems to extract knowledge and insights from vast amounts of structured and unstructured data, in order to inform human decision-making and strategy.
- In simpler terms: It's the entire process of getting useful, actionable knowledge out of raw data.

[‚¨ÜÔ∏è Go to Context](#context)

### Career Opportunities

- "The rise of AI/Data Science needs will create roughly 11.5 million job openings
- by 2026" US Bureau of Labour Statistics "By 2026, AI/Data Scientists and Analysts will become the number one emerging role in the world." World Economic Forum
- Data Science and Artificial Intelligence are amongst the hottest fields of the 21st century that will impact all segments of daily life by 2025, from transport and logistics to healthcare and customer service.

[‚¨ÜÔ∏è Go to Context](#context)

### Importance of DS

- Data science helps brands to understand their customers in a much enhanced and empowered manner.
- It allows brands to communicate their story in such a engaging and powerful manner.
- Data is a new field that is constantly growing and evolving.
- Its findings and results can be applied to almost any sector like travel, healthcare and education among others.
- Data science is accessible to almost all sectors.

[‚¨ÜÔ∏è Go to Context](#context)

### Application of AI

- **Healthcare** ‚Äì AI helps in disease detection, medical imaging, drug discovery, and robotic surgery.
- **Finance** ‚Äì Used for fraud detection, stock prediction, automated trading, and credit risk analysis.
- **Education** ‚Äì Powers personalized learning, grading automation, and virtual tutoring systems.
- **Transportation** ‚Äì Enables self-driving cars, route optimization, and predictive vehicle maintenance.
- **Manufacturing** ‚Äì Improves production efficiency, defect detection, and supply chain optimization.
- **Retail** ‚Äì Provides product recommendations, demand forecasting, and customer behavior analysis.
- **Agriculture** ‚Äì Supports crop monitoring, soil analysis, pest control, and smart irrigation.
- **Cybersecurity** ‚Äì Detects anomalies, prevents intrusions, and strengthens network defenses.
- **Entertainment** ‚Äì Generates AI-driven music, movies, games, and content personalization.
- **Customer Service** ‚Äì Automates responses through chatbot and voice assistants for 24/7 support.

[‚¨ÜÔ∏è Go to Context](#context)

### Venn Diagram

![venn diagram](https://i.imgur.com/6e3FSxF.png)

[‚¨ÜÔ∏è Go to Context](#context)

### AI Project Development Life Cycle

![ai project development life cycle](https://i.imgur.com/r3L7rpk.png)

[‚¨ÜÔ∏è Go to Context](#context)

### Different Roles in AI

- **Data Analyst** - Data analysis + AI insights
- **Machine Learning Engineer** - Predictive models, pipelines
- **Deep Learning Engineer** - Neural networks, CV, NLP
- **NLP Engineer / LLM Engineer** - Text, chatbot, RAG, fine-tuning
- **Computer Vision Engineer** - Images, video, 3D data
- **Generative AI Engineer** - Image/audio/text generation/RAG/Agents/MCP
- **MLOps Engineer** - Model optimization/deployment & monitoring
- **AI Engineer/Data Scientist** - Full AI stack (ML, DL, LLMs, MLOps)
- **AI Research Engineer** - Develop new algorithms & architectures

[‚¨ÜÔ∏è Go to Context](#context)

## **System Setup Tools**

- [Anaconda](https://www.anaconda.com/download/success)
- [VS Code](https://code.visualstudio.com/)
- [Git](https://git-scm.com/install/windows)
- [GitHub](https://github.com/)
- [Salary Range](https://www.glassdoor.com/)

> VS Code Extension - Python, Code Runner, Jupyter, Git, Graph, Git Lens.

[‚¨ÜÔ∏è Go to Context](#context)

# [**Day 03 - Introduction And Basic Of Python**](./Day%2003%20-%20Introduction%20And%20Basic%20Of%20Python/)

## **Introduction to Python & Setup**

- What is Python?
  - Python is a high-level, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation.

- Why Python?
  - Easy to learn
  - Design Philosophy
  - Batteries Included
  - General Purpose
  - Libraries & Community

- Installation & Environment Setup
  - [Python](https://www.python.org/downloads/)
  - [Anaconda](https://www.anaconda.com/download/success)
  - [Google Colab](https://colab.research.google.com/)

[‚¨ÜÔ∏è Go to Context](#context)

## **Write our first Program in Python**

```py
print("Hello World")
```

### print() Function Parameters in Python

- `objects`: Values to print (can be multiple)
  - Example: `print("Hello", "World") ‚Üí Hello World`
- `sep`: Separator between multiple objects (default = `' '`)
  - Example: `print("Hello", "World", sep="-") ‚Üí Hello-World`
- `end`: String added after the output (default = `'\n'`)
  - Example: `print("Hello", end="!") ‚Üí Hello!`
- `file`: Output stream to write (default = `sys.stdout`)
  - Example: `print("Hello", file=sys.stderr)`
- `flush`: Whether to forcibly flush the stream (default = `False`)
  - Example: `print("Processing...", flush=True)`

[‚¨ÜÔ∏è Go to Context](#context)

## **Operators in Python**

- Arithmetic Operators
  - Addition (`+ `): `5 + 3 ‚Üí 8`
  - Subtraction (`- `): `5 - 3 ‚Üí 2`
  - Multiplication (`*`): `5 * 3 ‚Üí 15`
  - Division (`/`): `5 / 2 ‚Üí 2.5`
  - Floor Division (`//`): `5 // 2 ‚Üí 2`
  - Modulus (`%`): `5 % 2 ‚Üí 1`
  - Exponentiation (`**`): `2 ** 3 ‚Üí 8`

- Comparison Operators
  - Equal to (`==`): `5 == 3 ‚Üí False`
  - Not equal to (` !=`): `5 != 3 ‚Üí True`
  - Greater than (`>`): `5 > 3 ‚Üí True`
  - Less than (`<`): `5 < 3 ‚Üí False`
  - Greater than or equal to (`>=`): `5 >= 3 ‚Üí True`
  - Less than or equal to (`<=`): `5 <= 3 ‚Üí False`

- Assignment Operators
  - Assign (`=`): `x = 5`
  - Add and assign (` +=`): `x += 3 ‚Üí x = x + 3`
  - Subtract and assign (`-=`): `x -= 3 ‚Üí x = x - 3`
  - Multiply and assign (`*=`): `x *= 3 ‚Üí x = x * 3`
  - Divide and assign (`/=`): `x /= 3 ‚Üí x = x / 3`
  - Floor divide and assign (`//=`): `x //= 3 ‚Üí x = x // 3`
  - Modulus and assign (`%=`): `x %= 3 ‚Üí x = x % 3`
  - Exponentiate and assign (`**=`): `x **= 3 ‚Üí x = x ** 3`

- Logical Operators
  - Logical AND (`and`): `True and False ‚Üí False`
  - Logical OR (`or`): `True or False ‚Üí True`
  - Logical NOT (`not`): `not True ‚Üí False`

- Bitwise Operators
  - Bitwise AND (`&`): `5 & 3 ‚Üí 1`
  - Bitwise OR (`|`): `5 | 3 ‚Üí 7`
  - Bitwise XOR (`^`): `5 ^ 3 ‚Üí 6`
  - Bitwise NOT (`~`): `~5 ‚Üí -6`
  - Left shift (`<<`): `5 << 1 ‚Üí 10`
  - Right shift (`>>`): `5 >> 1 ‚Üí 2`

- Membership Operators
  - In (`in`): `'a' in 'apple' ‚Üí True`
  - Not in (`not in`): `'b' not in 'apple' ‚Üí True`

- Identity Operators
  - Is (`is`): `x is y`
  - Is not (`is not`): `x is not y`

[‚¨ÜÔ∏è Go to Context](#context)

## **Python Data Types & Comments**

- Data Types in Python
  - Integer (`int`) - Whole numbers: `x = 10`
  - Float (`float`) - Decimal numbers: `y = 3.14`
  - Complex (`complex`) - Complex numbers: `z = 2 + 3j`
  - String (`str`) - Text: `s = "Hello"`
  - Boolean (`bool`) - True or False: `flag = True`
  - List (`list`) - Ordered, mutable collection: `lst = [1, 2, 3]`
  - Tuple (`tuple`) - Ordered, immutable collection: `tup = (1, 2, 3)`
  - Set (`set`) - Unordered, unique elements: `st = {1, 2, 3}`
  - Dictionary (`dict`) - Key-value pairs: `d = {"a": 1, "b": 2}`
  - NoneType (`None`) - Represents no value: `x = None`

- Comments in Python
  - Single-line comment (`#`): `# This is a comment`
  - Multi-line comment (triple quotes `''' '''` or `""" """`)

    ```py
    '''
    This is
    a multi-line comment
    '''
    ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Variables, Keywords & Identifiers in Python**

### Variables

- Variable Binding in Python
  - Static Binding: Variable type is fixed at **compile time** (not typical in Python, seen in languages like C/C++)

    ```py
    int x = 10;  // x is always integer
    ```

  - Dynamic Binding: Variable type is determined at **runtime** (Python uses this)

    ```py
    x = 10      # x is int
    x = "Hello" # x now becomes str
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Keywords

- Boolean Literals
  - `True`: Boolean true value
  - `False`: Boolean false value
  - `None`: Represents absence of value

- Conditional / Decision Making
  - `if`: Conditional execution
  - `elif`: Else-if condition
  - `else`: Default condition
  - `assert`: Check condition, raise error if false
  - `not`: Logical NOT
  - `and`: Logical AND
  - `or`: Logical OR
  - `in`: Membership check
  - `is`: Identity check

- Loops
  - `for`: For loop
  - `while`: While loop
  - `break`: Exit loop
  - `continue`: Skip current iteration
  - `else`: Optional else block in loops

- Functions & Classes
  - `def`: Define a function
  - `return`: Return value from function
  - `lambda`: Anonymous function
  - `class`: Define a class
  - `nonlocal`: Modify variable in outer (but non-global) scope
  - `global`: Declare global variable

- Exception Handling
  - `try`: Start exception block
  - `except`: Handle exception
  - `finally`: Execute code regardless of exception
  - `raise`: Raise an exception

- Modules & Imports
  - `import`: Import module
  - `from`: Import specific names from module
  - `as`: Alias for module or variable

- Asynchronous Programming
  - `async`: Define asynchronous function
  - `await`: Wait for asynchronous operation

- Others / Flow Control
  - `pass`: Do nothing (placeholder)
  - `del`: Delete variable or object
  - `yield`: Produce generator value

[‚¨ÜÔ∏è Go to Context](#context)

### Identifiers

- Names given to variables, functions, classes, or objects to identify them.
  - Rules for Python Identifiers:
    - Can contain letters (`a-z`, `A-Z`), digits (`0-9`), and underscore (`_`)
    - Must **start with a letter or underscore**, not a digit
    - Case-sensitive (`myVar` ‚â† `myvar`)
    - Cannot be a **keyword** (like `if`, `for`, `class`)
    - No spaces or special characters allowed

  - Examples:
    - Valid: `my_var`, `_counter`, `Data123`, `userName`
    - Invalid: `123data`, `my-var`, `for`, `user name`

  - Naming Conventions:
    - Variables / functions: `snake_case` ‚Üí `my_variable`
    - Classes: `PascalCase` ‚Üí `MyClass`
    - Constants: `UPPER_CASE` ‚Üí `PI_VALUE`

[‚¨ÜÔ∏è Go to Context](#context)

## **Python Input**

- Input in Python

  - `input()`: Reads a line of text from the user (always returns a string)
    - Example: `name = input("Enter your name: ")`

[‚¨ÜÔ∏è Go to Context](#context)

## **Type Conversion in Python**

- `int()`: Convert to integer
  - Example: `x = int(3.14) ‚Üí 3`

- `float()`: Convert to float
  - Example: `y = float(5) ‚Üí 5.0`

- `str()`: Convert to string
  - Example: `s = str(100) ‚Üí "100"`

- `bool()`: Convert to boolean
  - Example: `flag = bool(0) ‚Üí False`

- `complex()`: Convert to complex number
  - Example: `c = complex(2, 3) ‚Üí (2+3j)`

- `list()`: Convert to list
  - Example: `lst = list("abc") ‚Üí ['a','b','c']`

- `tuple()`: Convert to tuple
  - Example: `tup = tuple([1,2,3]) ‚Üí (1,2,3)`

- `set()`: Convert to set
  - Example: `st = set([1,2,2,3]) ‚Üí {1,2,3}`

- `dict()`: Convert to dictionary (from iterable of key-value pairs)
  - Example: `d = dict([("a",1),("b",2)]) ‚Üí {'a':1,'b':2}`

- `ord()`: Convert character to ASCII/Unicode integer
  - Example: `num = ord('A') ‚Üí 65`

- `chr()`: Convert ASCII/Unicode integer to character
  - Example: `ch = chr(65) ‚Üí 'A'`

[‚¨ÜÔ∏è Go to Context](#context)

## **Literals in Python**

- Literals in Python : Literals are **fixed values** assigned directly in the code that represent data. They are not computed or changed during execution.

  - String Literals
    - Example: `s = "Hello World"`

  - Numeric Literals
    - Integer
      - Example: `x = 10`
    - Float
      - Example: `y = 3.14`
    - Complex
      - Example: `z = 2 + 3j`

  - Boolean Literals
    - Example: `flag = True` / `flag = False`

  - None Literal
    - Example: `x = None`

  - Collection Literals
    - List
      - Example: `lst = [1, 2, 3]`
    - Tuple
      - Example: `tup = (1, 2, 3)`
    - Set
      - Example: `st = {1, 2, 3}`
    - Dictionary
      - Example: `d = {"a":1, "b":2}`

  - Bytes Literals
    - Example: `b = b"Hello"`

[‚¨ÜÔ∏è Go to Context](#context)

# [**Day 04 - Conditional Statements, Pip, Modules & Loops**](./Day%2004%20-%20Conditional%20Statements,%20Pip,%20Modules%20&%20Loops/)

## **Conditional Statements**

- Conditional Statements in Python : Conditional statements are used to make decisions in code based on whether a condition is **True** or **False**.

  - `if` Statement

    ```py
    x = 10
    if x > 5:
        print("x is greater than 5")
    ```

  - `if-else` Statement

    ```py
    x = 3
    if x > 5:
        print("x is greater than 5")
    else:
        print("x is not greater than 5")
    ```

  - `if-elif-else` Statement

    ```py
    x = 0
    if x > 0:
        print("Positive")
    elif x < 0:
        print("Negative")
    else:
        print("Zero")
    ```

  - Nested `if` Statement

    ```py
    x = 15
    if x > 0:
        if x % 2 == 0:
            print("Positive Even")
        else:
            print("Positive Odd")
    ```

  - Conditional Expression (Ternary Operator)

    ```py
    x = 10
    result = "Even" if x % 2 == 0 else "Odd"
    print(result)
    ```

[‚¨ÜÔ∏è Go to Context](#context)

## **PIP (Pip Installs Packages)**

- PIP (Pip Installs Packages) : `pip` is the **package manager for Python** used to install, upgrade, and manage external Python libraries and dependencies.

- Check pip version
  - `pip --version`

- Install a package
  - `pip install package_name`

- Install specific version
  - `pip install package_name==1.2.3`

- Upgrade a package
  - `pip install --upgrade package_name`

- Uninstall a package
  - `pip uninstall package_name`

- Show installed packages
  - `pip list`

- Show details of a package
  - `pip show package_name`

- Save installed packages to a requirements file
  - `pip freeze > requirements.txt`

- Install packages from a requirements file
  - `pip install -r requirements.txt`

[‚¨ÜÔ∏è Go to Context](#context)

## **Modules in Python**

- Modules in Python : A **module** in Python is a file containing Python code (functions, variables, or classes) that can be imported and reused in other programs.

  - Types of Modules
    - Built-in Modules: Pre-installed with Python (e.g., `math`, `os`, `sys`)
    - User-defined Modules: Created by the user as `.py` files
    - External Modules: Installed using `pip` (e.g., `requests`, `numpy`)

  - Importing a Module

    ```py
    import math
    print(math.sqrt(16))
    ```

  - Importing Specific Function

    ```pt
    from math import sqrt
    print(sqrt(25))
    ```

  - Importing with Alias

    ```py
    import math as m
    print(m.pi)
    ```

  - Importing All Contents (not recommended)

    ```py
    from math import *
    print(factorial(5))
    ```

  - Creating a User-defined Module

    - File: `my_module.py`

      ```py
      def greet(name):
          return f"Hello, {name}!"
      ```

    - Usage:

      ```py
      import my_module
      print(my_module.greet("Tansen"))
      ```

  - Checking Module Search Path

    ```py
    import sys
    print(sys.path)
    ```

  - Re-importing a Modified Module

    ```py
    import importlib
    importlib.reload(my_module)
    ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Loops in Python**

- Loops in Python : Loops are used to **execute a block of code repeatedly** until a certain condition is met.

  - Types of Loops
    - `for` loop
    - `while` loop

  - `for` Loop
    - Used to iterate over a sequence (list, tuple, string, range, etc.)

      ```py
      for i in range(5):
          print(i)
      ```

  - `while` Loop
    - Executes as long as the condition is `True`

      ```py
      x = 0
      while x < 5:
          print(x)
          x += 1
      ```

  - `break` Statement
    - Used to **exit** the loop immediately

      ```py
      for i in range(10):
          if i == 5:
              break
          print(i)
      ```

  - `continue` Statement
    - Skips the current iteration and continues with the next

      ```py
      for i in range(5):
          if i == 2:
              continue
          print(i)
      ```

  - `else` with Loop
    - The `else` block executes **only if the loop completes normally** (without `break`)

      ```py
      for i in range(3):
          print(i)
      else:
          print("Loop finished")
      ```

  - Nested Loops
    - A loop inside another loop

      ```py
      for i in range(2):
          for j in range(3):
              print(i, j)
      ```

  - Infinite Loop
    - A loop that runs forever until a `break` condition occurs

      ```py
      while True:
          print("Running...")
          break
      ```

[‚¨ÜÔ∏è Go to Context](#context)

# [**Assignment 01**](./Assignments/Assignment%2001/)

[‚¨ÜÔ∏è Go to Context](#context)

# [**Day 05 - Loops in Python**](./Day%2005%20-%20Loops%20in%20Python/)

## **Loops Recap**

- `while` Loop: Repeats code **while a condition is True**

  ```py
  x = 0
  while x < 3:
      print("Count:", x)
      x += 1
  ```

- `for` Loop: Iterates over a sequence (list, string, range, etc.)

  ```py
  for i in range(3):
      print("Index:", i)
  ```

- Program to print multiplication table

  ```py
  number = int(input("Enter a number: "))
  i=1
  while i<=10:
      print(f"{number} * {i} = {number*i}")
      i+=1
  ```

- Guess the number game

  ```py
  """
  - Genera a random number (1-100)
  - Take an input from user -> guess the number
  - Compare / match the num
  - if user guess>generate number -> guess a lower num
  - if guess < generate num-> guess a higher num
  - if num correct show result
  """
  import random
  random_num=random.randint(1, 100)
  num = int(input("Guess the number: "))
  counter =1

  while num!=random_num:
      if num>random_num:
          print("Guess a lower num")
      elif num<random_num:
          print("Guess a higher num")
      num = int(input("Guess the number: "))
      counter+=1
  else:
      print(f"Total attempt: {counter}")
      print("You guess the correct number")
  ```

- Range print using list

  ```py
  list(range(1,11))
  ```

- For loop range with skip steps

  ```py
  for i in range(1,11,2):
      print(i)
  ```

- Reverse loop

  ```py
  for i in range(11,-1,-1):
      print(i)
  ```

- Triangle pattern using nested loop

  ```py
  # triangle pattern using nested for loop
  for i in range(1,6):
      for j in range(1,i+1):
          print("*", end="")
      print("")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Loop Control Statements**

- `break`

  ```py
  # break
  for i in range(1,11):
      if i==5:
          break
      print(i)
  ```

- `continue`

  ```py
  # continue
  for i in range(1,10):
      if i==5:
          continue
      print(i)
  ```

- `pass`

  ```py
  # pass
  for i in range(1,11):
      pass
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Code Visualization Tool**

- [Python Tutor](https://pythontutor.com/python-compiler.html)
- [Thonny](https://thonny.org/)

[‚¨ÜÔ∏è Go to Context](#context)

# [**Day 06 - Strings in Python**](./Day%2006%20-%20Strings%20in%20Python/)

## **Strings in Python**

### Creating Strings

- Single and multiline string

  ```py
  s = 'hello'
  s = "hello"

  # multiline strings
  s = '''hello'''
  s = """hello"""
  s = str('hello')
  print(s)
  ```

- String explicit type conversion (int to str)

  ```py
  a = 34
  str(a)
  ```

- `SyntaxError: unterminated string literal`

  - Use double quotes:

    ```py
    print("it's my birthday")
    ```

  - Escape the single quote:

    ```py
    print('it\'s my birthday')
    ```

  - Use triple quotes:

    ```py
    print('''it's my birthday''')
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Accessing Strings

- By Index (0-based)

  ```py
  s = "Python"
  print(s[0])  # P
  print(s[5])  # n
  ```

- Negative Indexing (from end)

  ```py
  s = "Python"
  print(s[-1])  # n
  print(s[-3])  # h
  ```

- String Slicing

  ```py
  s = "Python"
  print(s[0:3])   # Pyt
  print(s[2:])    # thon
  print(s[:4])    # Pyth
  print(s[::2])   # Pto
  ```

- Accessing Characters with Loop

  ```py
  s = "AI"
  for ch in s:
      print(ch)
  ```

- Index access

  ```py
  intro = "My name is Tansen"
  intro.index("T") - len(intro)
  ```

- Positive and negative index access (Multiple)

- Positive index using list comprehension

  ```py
  indices  = [i for i,c in enumerate(intro) if c =="n"]
  indices
  ```

- Negative index using list comprehension

  ```py
  neg_indices = [i - len(intro) for i in indices]
  neg_indices
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Adding Chars to Strings

- Using Concatenation (`+`)

  ```py
  s = "Hello"
  s = s + " World"
  print(s)  # Hello World
  ```

- Using `join()`

  ```py
  s = "-".join(["A", "B", "C"])
  print(s)  # A-B-C
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Editing Strings

- Strings are **immutable**, cannot change directly
- Using slicing and concatenation

  ```py
  s = "Hello"
  s = "J" + s[1:]
  print(s)  # Jello
  ```

- Using `replace()`

  ```py
  s = "Hello"
  s = s.replace("H", "J")
  print(s)  # Jello
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Deleting Strings

- Using `del` to remove entire string

  ```py
  s = "Hello"
  del s
  # print(s) ‚Üí Error: s is not defined
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Operations on Strings

- Arithmetic Operations
  - Concatenation (` +`)

    ```py
    s1 = "Hello"
    s2 = "World"
    s3 = s1 + " " + s2
    print(s3)  # Hello World
    ```

  - Repetition (`*`)

    ```py
    s = "Hi! " * 3
    print(s)  # Hi! Hi! Hi!
    ```

- Relational Operations
  - Comparison (`==`, ` !=`, `<`, `>`, `<=`, `>=`)

    ```py
    s1 = "apple"
    s2 = "banana"
    print(s1 == s2)  # False
    print(s1 < s2)   # True
    ```

- Logical Operations
  - `and`, `or`, `not` on boolean results of comparisons

    ```py
    s1 = "apple"
    s2 = "banana"
    print(s1 < s2 and s2 > "aardvark")  # True
    print(not(s1 == s2))                 # True
    ```

- Loops on Strings
  - Iterating over characters

    ```py
    s = "Python"
    for ch in s:
        print(ch)
    ```

- Membership Operations
  - `in` and `not in`

    ```py
    s = "Python"
    print("P" in s)     # True
    print("z" not in s) # True
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### String Functions

- `len()`: Get length of string

  ```py
  s = "Python"
  print(len(s))  # 6
  ```

- `ord()`: Get ASCII/Unicode value of character

  ```py
  print(ord('A'))  # 65
  ```

- `chr()`: Get character from ASCII/Unicode value

  ```py
  print(chr(65))  # 'A'
  ```

- `max()`: Get character with maximum ASCII value

  ```py
  s = "Python"
  print(max(s))  # y
  ```

- `min()`: Get character with minimum ASCII value

  ```py
  s = "Python"
  print(min(s))  # P
  ```

- `sorted()`: Return sorted list of characters

  ```py
  s = "Python"
  print(sorted(s))  # ['P', 'h', 'n', 'o', 't', 'y']
  ```

- `reversed()`: Return iterator to reverse string

  ```py
  s = "Python"
  print(''.join(reversed(s)))  # nohtyP
  ```

- `type()`: Get type of object

  ```py
  s = "Python"
  print(type(s))  # <class 'str'>
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### String Methods

- `upper()`: Convert string to uppercase

  ```py
  s = "hello"
  print(s.upper())  # HELLO
  ```

- `lower()`: Convert string to lowercase

  ```py
  s = "HELLO"
  print(s.lower())  # hello
  ```

- `capitalize()`: Capitalize first character

  ```py
  s = "hello"
  print(s.capitalize())  # Hello
  ```

- `title()`: Capitalize first character of each word

  ```py
  s = "hello world"
  print(s.title())  # Hello World
  ```

- `strip()`: Remove leading and trailing whitespace

  ```py
  s = "  hello  "
  print(s.strip())  # hello
  ```

- `replace()`: Replace substring with another

  ```py
  s = "Hello World"
  print(s.replace("World", "Python"))  # Hello Python
  ```

- `split()`: Split string into list by separator

  ```py
  s = "a,b,c"
  print(s.split(","))  # ['a', 'b', 'c']
  ```

- `join()`: Join list of strings with separator

  ```py
  lst = ["a","b","c"]
  print("-".join(lst))  # a-b-c
  ```

- `find()`: Find index of substring (-1 if not found)

  ```py
  s = "Python"
  print(s.find("t"))  # 2
  ```

- `count()`: Count occurrences of substring

  ```py
  s = "banana"
  print(s.count("a"))  # 3
  ```

- `startswith()`: Check if string starts with substring

  ```py
  s = "Python"
  print(s.startswith("Py"))  # True
  ```

- `endswith()`: Check if string ends with substring

  ```py
  s = "Python"
  print(s.endswith("on"))  # True
  ```

- `isalpha()`: Check if all characters are alphabetic

  ```py
  s = "Python"
  print(s.isalpha())  # True
  ```

- `isalnum()`: Check if all characters are number

  ```py
  s = "123"
  print(s.isalnum())  # True
  ```

- `isdigit()`: Check if all characters are digits

  ```py
  s = "123"
  print(s.isdigit())  # True
  ```

- `isspace()`: Check if string contains only whitespace

  ```py
  s = "   "
  print(s.isspace())  # True
  ```

- `isidentifier()`: Checks if a string is a **valid Python identifier** (variable, function, class name).


  ```py
  s1 = "variable1"
  s2 = "1variable"
  print(s1.isidentifier())  # True
  print(s2.isidentifier())  # False
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Strings Exercise**

### Find the length of a given string without using the len() function

```py
s = input("Enter a String: ")

counter = 1
for i in s:
    counter += 1

print(counter)
```

### Extract username from a given email

- If the email is `aatansen@gmail.com`
- Then the username should be `aatansen`

  ```py
  # email = "aatansen@gmail.com"
  email = input("Enter your email: ")
  pos = email.index("@")
  print(email[0:pos])
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# [**Day 07 - List in Python**](./Day%2007%20-%20List%20in%20Python/)

## **List in Python**

### What are Lists?

- List is a data type where you can store multiple items under 1 name. More technically, lists act like dynamic arrays which means you can add more items on the fly.

  - A list is an **ordered**, **mutable**, and **dynamic** collection of elements.
  - Created using **square brackets `[]`** or the **list()** constructor.

- **Characteristics**
  - **Ordered** ‚Äî Maintains insertion order
  - **Mutable / Changeable** ‚Äî Elements can be modified
  - **Heterogeneous** ‚Äî Can store different data types
  - **Allows Duplicates** ‚Äî Repeated values are allowed
  - **Dynamic Size** ‚Äî Can grow or shrink automatically
  - **Index-Based Access** ‚Äî Supports positive and negative indexing
  - **Can Be Nested** ‚Äî Lists can contain other lists
  - **Can Store Any Python Object** ‚Äî Numbers, strings, functions, classes, etc.
  - **More Memory Usage** than tuples
  - **Slower** compared to tuples due to mutability

    ```py
    my_list = [10, "Hello", 3.14, True]
    print(my_list)
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Lists Vs Arrays

- **Lists**
  - Can store elements of **different data types**
  - Part of **core Python**
  - Flexible but slower for large numeric data

    ```py
    my_list = [1, "two", 3.0, True]
    print(my_list)
    ```

- **Arrays**
  - Can store elements of **same data type only**
  - Need to import from **array module** or **NumPy**
  - More **memory-efficient** for numeric operations

    ```py
    import array
    arr = array.array('i', [1, 2, 3, 4])
    print(arr)
    ```

  - **Key Differences**
    - **Data Type:** Lists ‚Üí Heterogeneous | Arrays ‚Üí Homogeneous
    - **Speed:** Arrays are faster for numeric operations
    - **Size:** Lists ‚Üí Dynamic | Arrays ‚Üí Fixed (unless NumPy array)
    - **Memory:** Arrays use less memory than lists
    - **Usage:** Lists are flexible | Arrays are optimized for computation

    ```mermaid
    flowchart TD

        %% --- Python List Section ---
        subgraph L1["Python List"]
            direction LR
            L1desc["(Dynamic Array: grows automatically)"]
            L1A["Index 0 ‚Üí 10"]
            L1B["Index 1 ‚Üí 20"]
            L1C["Index 2 ‚Üí 30"]
        end

        %% --- Array Section ---
        subgraph A1["Array Module"]
            direction LR
            A1desc["(Fixed Size: array('i', [10,20,30]))"]
            A1A["Index 0 ‚Üí 10"]
            A1B["Index 1 ‚Üí 20"]
            A1C["Index 2 ‚Üí 30"]
        end

        L1 -->|"append(40)"| L2
        A1 -->|"add new value"| A2

        %% --- After Adding Value (List) ---
        subgraph L2["After append(40)"]
            direction LR
            L2A["üÜï New Memory Block Allocated"]
            L2B["Values Copied: 10, 20, 30, 40"]
        end

        %% --- After Adding Value (Array) ---
        subgraph A2["Array Overflow"]
            direction LR
            A2A["‚ùå Memory Full"]
            A2B["‚úÖ Must create new array and copy values"]
        end

        %% --- Style Definitions ---
        classDef list fill:#2E86C1,stroke:#1B4F72,color:#fff,font-weight:bold;
        classDef array fill:#B9770E,stroke:#873600,color:#fff,font-weight:bold;
        classDef resized fill:#1E8449,stroke:#145A32,color:#fff,font-weight:bold;
        classDef overflow fill:#C0392B,stroke:#641E16,color:#fff,font-weight:bold;

        class L1,L1A,L1B,L1C,L1desc list;
        class A1,A1A,A1B,A1C,A1desc array;
        class L2,L2A,L2B resized;
        class A2,A2A,A2B overflow;
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Characteristics of a List

- **Ordered** ‚Äî Elements maintain their insertion order
- **Changeable / Mutable** ‚Äî Elements can be modified after creation
- **Heterogeneous** ‚Äî Can store elements of different data types
- **Can Have Duplicates** ‚Äî Allows repeated elements
- **Dynamic** ‚Äî Size can grow or shrink as needed
- **Can Be Nested** ‚Äî Lists can contain other lists
- **Index-Based Access** ‚Äî Elements can be accessed using indices
- **Can Contain Any Python Object** ‚Äî Strings, numbers, lists, tuples, functions, etc.

[‚¨ÜÔ∏è Go to Context](#context)

### How to create a list

- Using square brackets `[]`

  ```py
  my_list = [1, 2, 3, 4]
  ```

- Using `list()` constructor

  ```py
  my_list = list((1, 2, 3, 4))
  ```

- Empty list

  ```py
  my_list = []
  ```

- Heterogeneous list

  ```py
  my_list = [1, "Hello", 3.5, True]
  ```

- Nested list

  ```py
  my_list = [[1, 2], [3, 4]]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Access items from a List

- Using index (0-based)

  ```py
  my_list = [10, 20, 30, 40]
  print(my_list[1])  # 20
  ```

- Using negative index (from end)

  ```py
  my_list = [10, 20, 30, 40]
  print(my_list[-1])  # 40
  ```

- Using slicing

  ```py
  my_list = [10, 20, 30, 40, 50]
  print(my_list[1:4])  # [20, 30, 40]
  ```

- Accessing nested list

  ```py
  my_list = [[1, 2], [3, 4]]
  print(my_list[1][0])  # 3
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### List Methods

- `append()` ‚Äî Add an item to the end

  ```py
  my_list = [1, 2, 3]
  my_list.append(4)
  print(my_list)  # [1, 2, 3, 4]
  ```

- `extend()` ‚Äî Add multiple items from another list

  ```py
  my_list = [1, 2, 3]
  my_list.extend([4, 5])
  print(my_list)  # [1, 2, 3, 4, 5]
  ```

- `insert()` ‚Äî Insert item at specific position

  ```py
  my_list = [1, 3, 4]
  my_list.insert(1, 2)
  print(my_list)  # [1, 2, 3, 4]
  ```

- `remove()` ‚Äî Remove first occurrence of an item

  ```py
  my_list = [1, 2, 3, 2]
  my_list.remove(2)
  print(my_list)  # [1, 3, 2]
  ```

- `pop()` ‚Äî Remove and return item by index (default last)

  ```py
  my_list = [1, 2, 3]
  my_list.pop()
  print(my_list)  # [1, 2]
  ```

- `clear()` ‚Äî Remove all elements

  ```py
  my_list = [1, 2, 3]
  my_list.clear()
  print(my_list)  # []
  ```

- `index()` ‚Äî Return index of first occurrence

  ```py
  my_list = [10, 20, 30, 20]
  print(my_list.index(20))  # 1
  ```

- `count()` ‚Äî Count occurrences of item

  ```py
  my_list = [1, 2, 2, 3]
  print(my_list.count(2))  # 2
  ```

- `sort()` ‚Äî Sort list in ascending order

  ```py
  my_list = [3, 1, 2]
  my_list.sort()
  print(my_list)  # [1, 2, 3]
  ```

- `reverse()` ‚Äî Reverse order of list

  ```py
  my_list = [1, 2, 3]
  my_list.reverse()
  print(my_list)  # [3, 2, 1]
  ```

- `copy()` ‚Äî Return shallow copy of list

  ```py
  my_list = [1, 2, 3]
  new_list = my_list.copy()
  print(new_list)  # [1, 2, 3]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### List Functions

- `len()` ‚Äî Returns number of elements in list

  ```py
  my_list = [1, 2, 3]
  print(len(my_list))  # 3
  ```

- `max()` ‚Äî Returns maximum element

  ```py
  my_list = [1, 5, 3]
  print(max(my_list))  # 5
  ```

- `min()` ‚Äî Returns minimum element

  ```py
  my_list = [1, 5, 3]
  print(min(my_list))  # 1
  ```

- `sum()` ‚Äî Returns sum of elements

  ```py
  my_list = [1, 2, 3]
  print(sum(my_list))  # 6
  ```

- `sorted()` ‚Äî Returns sorted list (ascending by default)

  ```py
  my_list = [3, 1, 2]
  print(sorted(my_list))  # [1, 2, 3]
  ```

- `reversed()` ‚Äî Returns iterator to reverse list

  ```py
  my_list = [1, 2, 3]
  print(list(reversed(my_list)))  # [3, 2, 1]
  ```

- `any()` ‚Äî Returns True if any element is True

  ```py
  my_list = [0, 0, 1]
  print(any(my_list))  # True
  ```

- `all()` ‚Äî Returns True if all elements are True

  ```py
  my_list = [1, 2, 3]
  print(all(my_list))  # True
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Editing items in a List

  ```py
  # editing with slicing
  L = [1,2,3,4]
  L[1:4] = [200,300,400]
  print(L)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Deleting items from a List

  ```py
  L = [1,2,3,4]
  del L[0]
  print(L)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Operations on Lists

- **Concatenation (` +`)**

  ```py
  list1 = [1, 2]
  list2 = [3, 4]
  result = list1 + list2
  print(result)  # [1, 2, 3, 4]
  ```

- **Repetition (`*`)**

  ```py
  list1 = [1, 2]
  result = list1 * 3
  print(result)  # [1, 2, 1, 2, 1, 2]
  ```

- **Membership (`in`, `not in`)**

  ```py
  list1 = [1, 2, 3]
  print(2 in list1)     # True
  print(5 not in list1) # True
  ```

- **Iteration / Loops**

  ```py
  list1 = [1, 2, 3]
  for item in list1:
      print(item)
  ```

- **Indexing and Slicing**

  ```py
  list1 = [10, 20, 30, 40]
  print(list1[1])    # 20
  print(list1[1:3])  # [20, 30]
  ```

- **Length (`len()`)**

  ```py
  list1 = [1, 2, 3, 4]
  print(len(list1))  # 4
  ```

- **Minimum and Maximum (`min()`, `max()`)**

  ```py
  list1 = [5, 2, 9]
  print(min(list1))  # 2
  print(max(list1))  # 9
  ```

- **Sum (`sum()`)**

  ```py
  list1 = [1, 2, 3]
  print(sum(list1))  # 6
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### List comprehension

- A concise way to **create lists** using a single line of code with loops and conditions.

- Basic Syntax

  ```py
  [expression for item in iterable if condition]
  ```

- Squares of numbers

  ```py
  squares = [x**2 for x in range(5)]
  print(squares)  # [0, 1, 4, 9, 16]
  ```

- Even numbers only

  ```py
  evens = [x for x in range(10) if x % 2 == 0]
  print(evens)  # [0, 2, 4, 6, 8]
  ```

- Convert strings to uppercase

  ```py
  fruits = ["apple", "banana", "cherry"]
  fruits_upper = [f.upper() for f in fruits]
  print(fruits_upper)  # ['APPLE', 'BANANA', 'CHERRY']
  ```

- Nested List Comprehension

  ```py
  matrix = [[1,2,3],[4,5,6]]
  flat = [num for row in matrix for num in row]
  print(flat)  # [1, 2, 3, 4, 5, 6]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### `zip()` Function in Python

- Combines multiple iterables (lists, tuples, etc.) element-wise into a single iterator of tuples.

- Syntax

  ```py
  zip(iterable1, iterable2, ...)
  ```

- Example ‚Äî Basic usage

  ```py
  list1 = [1, 2, 3]
  list2 = ['a', 'b', 'c']
  zipped = zip(list1, list2)
  print(list(zipped))  # [(1, 'a'), (2, 'b'), (3, 'c')]
  ```

- Example ‚Äî More than two iterables

  ```py
  nums = [1, 2, 3]
  chars = ['x', 'y', 'z']
  bools = [True, False, True]
  zipped = zip(nums, chars, bools)
  print(list(zipped))  # [(1, 'x', True), (2, 'y', False), (3, 'z', True)]
  ```

- Example ‚Äî Iterating directly

  ```py
  for num, char in zip([1,2], ['a','b']):
      print(num, char)
  # Output:
  # 1 a
  # 2 b
  ```

> [!NOTE]
>
> - Stops at the **shortest iterable**
> - Can be combined with `list()`, `dict()`, or unpacking

[‚¨ÜÔ∏è Go to Context](#context)

# [**Assignment 02**](./Assignments/Assignment%2002/)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 08 - Tuples, Sets & Dictionary**

## **Tuples**

- **Tuples in Python**
  - A tuple is an **ordered**, **immutable** collection of elements.
  - Created using **parentheses `()`** or the **tuple()** constructor.

- **Characteristics**
  - **Ordered** ‚Äî Maintains insertion order
  - **Immutable** ‚Äî Cannot be changed after creation
  - **Heterogeneous** ‚Äî Can store different data types
  - **Allows Duplicates** ‚Äî Repeated items are allowed
  - **Index-Based Access** ‚Äî Access elements using indices
  - **Hashable (if all elements are immutable)** ‚Äî Can be used as dictionary keys
  - **Faster than lists** due to immutability
  - **Can be nested** ‚Äî Tuples inside tuples
  - **Uses less memory** than lists

    ```py
    my_tuple = (10, "Hello", 3.14, True)
    print(my_tuple)
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Creating a Tuple

- Using parentheses `()`

  ```py
  t = (1, 2, 3)
  ```

- Without parentheses (tuple packing)

  ```py
  t = 1, 2, 3
  ```

- Single-element tuple (requires comma)

  ```py
  t = (5,)
  ```

- Using `tuple()` constructor

  ```py
  t = tuple([1, 2, 3])
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Accessing Items in Tuple

- Using index

  ```py
  t = (10, 20, 30)
  print(t[1])  # 20
  ```

- Negative indexing

  ```py
  t = (10, 20, 30)
  print(t[-1])  # 30
  ```

- Slicing

  ```py
  t = (1, 2, 3, 4)
  print(t[1:3])  # (2, 3)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Editing Items in Tuple

- Not possible ‚Äî tuples are **immutable**

  ```py
  t = (1, 2, 3)
  # t[0] = 5  ‚Üí Error
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Adding Items in Tuple

- Create a **new tuple** using concatenation

  ```py
  t = (1, 2, 3)
  t = t + (4,)
  print(t)  # (1, 2, 3, 4)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Deleting Items in Tuple

- Delete entire tuple

  ```py
  t = (1, 2, 3)
  del t
  # print(t) ‚Üí Error: t is not defined
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Operations on Tuples

- Concatenation (` +`)

  ```py
  t1 = (1, 2)
  t2 = (3, 4)
  result = t1 + t2
  print(result)  # (1, 2, 3, 4)
  ```

- Repetition (`*`)

  ```py
  t = (1, 2)
  result = t * 3
  print(result)  # (1, 2, 1, 2, 1, 2)
  ```

- Membership (`in`, `not in`)

  ```py
  t = (10, 20, 30)
  print(20 in t)      # True
  print(50 not in t)  # True
  ```

- Indexing & Slicing

  ```py
  t = (5, 10, 15, 20)
  print(t[2])     # 15
  print(t[1:3])   # (10, 15)
  ```

- Iteration

  ```py
  t = ("a", "b", "c")
  for item in t:
      print(item)
  ```

- Length (`len()`)

  ```py
  t = (1, 2, 3)
  print(len(t))  # 3
  ```

- Maximum & Minimum (`max()`, `min()`)

  ```py
  t = (5, 2, 9)
  print(max(t))  # 9
  print(min(t))  # 2
  ```

- Count occurrences (`count()`)

  ```py
  t = (1, 2, 2, 3)
  print(t.count(2))  # 2
  ```

- Find index (`index()`)

  ```py
  t = (10, 20, 30)
  print(t.index(20))  # 1
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Tuple Methods

- **count() ‚Äì Count occurrences of a value**

  ```py
  t = (1, 2, 2, 3, 2)
  print(t.count(2))  # 3
  ```

- **index() ‚Äì Find the index of a value**

  ```py
  t = ("apple", "banana", "mango", "banana")
  print(t.index("banana"))  # 1
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Tuple Functions

- Length (`len()`)

  ```py
  t = (10, 20, 30)
  print(len(t))  # 3
  ```

- Maximum Value (`max()`)

  ```py
  t = (5, 9, 2)
  print(max(t))  # 9
  ```

- Minimum Value (`min()`)

  ```py
  t = (5, 9, 2)
  print(min(t))  # 2
  ```

- Sum of Elements (`sum()`)

  ```py
  t = (1, 2, 3, 4)
  print(sum(t))  # 10
  ```

- Sorting (`sorted()`)

  ```py
  t = (3, 1, 2)
  print(sorted(t))  # [1, 2, 3]
  ```

- Convert to List (`list()`)

  ```py
  t = (1, 2, 3)
  lst = list(t)
  print(lst)  # [1, 2, 3]
  ```

- Convert to Tuple (`tuple()`)

  ```py
  lst = [4, 5, 6]
  t = tuple(lst)
  print(t)  # (4, 5, 6)
  ```

- Check Type (`type()`)

  ```py
  t = (10, 20)
  print(type(t))  # <class 'tuple'>
  ```

- Check if any element is True (`any()`)

  ```py
  t = (0, False, 5)
  print(any(t))  # True
  ```

- Check if all elements are True (`all()`)

  ```py
  t = (1, 2, 3)
  print(all(t))  # True
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Tuple Unpacking

- Basic Unpacking

  ```py
  t = (10, 20, 30)
  a, b, c = t
  print(a, b, c)  # 10 20 30
  ```

- Unpacking with Different Variable Names

  ```py
  person = ("TT", 25, "Bangladesh")
  name, age, country = person
  print(name, age, country)  # TT 25 Bangladesh
  ```

- Unpacking with Asterisk (`*`)

  ```py
  t = (1, 2, 3, 4, 5)
  a, *b = t
  print(a)  # 1
  print(b)  # [2, 3, 4, 5]
  ```

- Asterisk in Middle

  ```py
  t = (10, 20, 30, 40, 50)
  a, *b, c = t
  print(a)  # 10
  print(b)  # [20, 30, 40]
  print(c)  # 50
  ```

- Nested Tuple Unpacking

  ```py
  t = ("TT", (10, 20))
  name, (x, y) = t
  print(name)  # TT
  print(x, y)  # 10 20
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Using `zip()` with Tuples

- Basic Zip

  ```py
  t1 = (1, 2, 3)
  t2 = ('a', 'b', 'c')
  zipped = zip(t1, t2)
  print(tuple(zipped))  # ((1, 'a'), (2, 'b'), (3, 'c'))
  ```

- Zip Multiple Tuples

  ```py
  t1 = (1, 2, 3)
  t2 = ('x', 'y', 'z')
  t3 = (True, False, True)
  zipped = zip(t1, t2, t3)
  print(tuple(zipped))  # ((1, 'x', True), (2, 'y', False), (3, 'z', True))
  ```

- Iterating Over Zipped Tuples

  ```py
  t1 = (1, 2, 3)
  t2 = ('a', 'b', 'c')
  for num, char in zip(t1, t2):
      print(num, char)
  # Output:
  # 1 a
  # 2 b
  # 3 c
  ```

- Unzipping Tuples

  ```py
  zipped = ((1, 'a'), (2, 'b'), (3, 'c'))
  t1, t2 = zip(*zipped)
  print(t1)  # (1, 2, 3)
  print(t2)  # ('a', 'b', 'c')
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Tuple Comprehension

- Python does **not have true tuple comprehensions**. Using parentheses `()` creates a **generator expression**, not a tuple.

  - Example (Generator Expression)

    ```py
    t_gen = (x*2 for x in range(5))
    print(t_gen)  # <generator object ...>
    print(list(t_gen))  # [0, 2, 4, 6, 8]
    ```

  - Convert Generator to Tuple

    ```py
    t = tuple(x*2 for x in range(5))
    print(t)  # (0, 2, 4, 6, 8)
    ```

  - With Condition

    ```py
    t = tuple(x for x in range(10) if x%2==0)
    print(t)  # (0, 2, 4, 6, 8)
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### List vs Tuple

- **Mutability**
  - List ‚Üí Mutable (can modify elements)
  - Tuple ‚Üí Immutable (cannot modify elements)

- **Syntax**
  - List ‚Üí Square brackets `[]`
  - Tuple ‚Üí Parentheses `()`

- **Order**
  - Both are ordered (maintain insertion order)

- **Duplicates**
  - Both allow duplicates

- **Heterogeneity**
  - Both can store heterogeneous elements

- **Memory Usage**
  - List ‚Üí Uses more memory
  - Tuple ‚Üí More memory efficient

- **Speed**
  - List ‚Üí Slower for iteration and operations
  - Tuple ‚Üí Faster due to immutability

- **Methods**
  - List ‚Üí Many methods like append, insert, remove, pop, sort
  - Tuple ‚Üí Only count() and index()

- **Use Cases**
  - List ‚Üí Use when collection may change
  - Tuple ‚Üí Use when data should not change, faster access, can be used as dictionary key

[‚¨ÜÔ∏è Go to Context](#context)

## **Sets**

- **Set in Python**

  - **Definition**
    - A set is an **unordered**, **mutable**, and **unique** collection of elements.
    - Created using **curly braces `{}`** or the **set()** constructor.

  - **Characteristics**
    - **Unordered** ‚Äî Does not maintain insertion order
    - **Mutable** ‚Äî Elements can be added or removed
    - **Unique Elements** ‚Äî Duplicates are automatically removed
    - **Heterogeneous** ‚Äî Can store multiple data types (numbers, strings, tuples, etc.)
    - **Unindexed** ‚Äî Cannot access elements by index
    - **Supports Set Operations** ‚Äî Union, intersection, difference, symmetric difference
    - **Can Be Nested with Immutable Types** ‚Äî Cannot have sets inside sets, but can contain tuples
    - **Faster Membership Testing** than lists or tuples

      ```py
      my_set = {1, 2, 3, 3}
      print(my_set)  # {1, 2, 3}
      ```

[‚¨ÜÔ∏è Go to Context](#context)

### Creating a Set

- Using curly braces

  ```py
  my_set = {1, 2, 3}
  ```

- Using `set()` constructor

  ```py
  my_set = set([1, 2, 3])
  ```

- Empty set

  ```py
  my_set = set()
  ```

### Accessing Items in Set

- Sets are **unordered**, so cannot access by index

  ```py
  my_set = {1, 2, 3}
  for item in my_set:
      print(item)
  ```

### Editing Items in Set

- Not possible directly, but can **remove and add** elements

### Adding Items in Set

- Using `add()`

  ```py
  my_set = {1, 2}
  my_set.add(3)
  print(my_set)  # {1, 2, 3}
  ```

- Using `update()` (multiple items)

  ```py
  my_set = {1, 2}
  my_set.update([3, 4, 5])
  print(my_set)  # {1, 2, 3, 4, 5}
  ```

### Deleting Items in Set

- Using `remove()` (raises error if not found)

  ```py
  my_set = {1, 2, 3}
  my_set.remove(2)
  print(my_set)  # {1, 3}
  ```

- Using `discard()` (no error if not found)

  ```py
  my_set = {1, 2, 3}
  my_set.discard(4)
  print(my_set)  # {1, 2, 3}
  ```

- Using `pop()` (removes arbitrary element)

  ```py
  my_set = {1, 2, 3}
  print(my_set.pop())  # 1 (or any element)
  ```

- Using `clear()` (remove all items)

  ```py
  my_set = {1, 2, 3}
  my_set.clear()
  print(my_set)  # set()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Operations on Set

- Union (`|` or `union()`)

  ```py
  set1 = {1, 2, 3}
  set2 = {3, 4, 5}
  print(set1 | set2)        # {1, 2, 3, 4, 5}
  print(set1.union(set2))   # {1, 2, 3, 4, 5}
  ```

- Intersection (`&` or `intersection()`)

  ```py
  set1 = {1, 2, 3}
  set2 = {2, 3, 4}
  print(set1 & set2)             # {2, 3}
  print(set1.intersection(set2)) # {2, 3}
  ```

- Difference (` -` or `difference()`)

  ```py
  set1 = {1, 2, 3}
  set2 = {2, 3, 4}
  print(set1 - set2)            # {1}
  print(set1.difference(set2))  # {1}
  ```

- Symmetric Difference (`^` or `symmetric_difference()`)

  ```py
  set1 = {1, 2, 3}
  set2 = {3, 4, 5}
  print(set1 ^ set2)                        # {1, 2, 4, 5}
  print(set1.symmetric_difference(set2))   # {1, 2, 4, 5}
  ```

- Membership Testing (`in`, `not in`)

  ```py
  s = {1, 2, 3}
  print(2 in s)      # True
  print(5 not in s)  # True
  ```

- Iteration on Set

  - Using for loop

    ```py
    my_set = {1, 2, 3}
    for item in my_set:
        print(item)
    # Output may vary in order, e.g., 1 2 3
    ```

  - Using set comprehension

    ```py
    my_set = {1, 2, 3, 4}
    squared = {x**2 for x in my_set}
    print(squared)  # {1, 4, 9, 16}
    ```

- Subset (`<=`, `issubset()`)

  ```py
  set1 = {1, 2}
  set2 = {1, 2, 3}
  print(set1 <= set2)           # True
  print(set1.issubset(set2))    # True
  ```

- Superset (`>=`, `issuperset()`)

  ```py
  set1 = {1, 2, 3}
  set2 = {1, 2}
  print(set1 >= set2)           # True
  print(set1.issuperset(set2))  # True
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Set Methods

- `add()` ‚Äì Add a single element

  ```py
  s = {1, 2}
  s.add(3)
  print(s)  # {1, 2, 3}
  ```

- `update()` ‚Äì Add multiple elements

  ```py
  s = {1, 2}
  s.update([3, 4, 5])
  print(s)  # {1, 2, 3, 4, 5}
  ```

- `remove()` ‚Äì Remove an element (raises error if not found)

  ```py
  s = {1, 2, 3}
  s.remove(2)
  print(s)  # {1, 3}
  ```

- `discard()` ‚Äì Remove an element (no error if not found)

  ```py
  s = {1, 2, 3}
  s.discard(4)
  print(s)  # {1, 2, 3}
  ```

- `pop()` ‚Äì Remove and return an arbitrary element

  ```py
  s = {1, 2, 3}
  print(s.pop())  # 1 (or any element)
  print(s)        # Remaining elements
  ```

- `clear()` ‚Äì Remove all elements

  ```py
  s = {1, 2, 3}
  s.clear()
  print(s)  # set()
  ```

- `copy()` ‚Äì Return a shallow copy of the set

  ```py
  s1 = {1, 2, 3}
  s2 = s1.copy()
  print(s2)  # {1, 2, 3}
  ```

- `union()` ‚Äì Return a new set with all elements from both sets

  ```py
  s1 = {1, 2}
  s2 = {2, 3}
  print(s1.union(s2))  # {1, 2, 3}
  ```

- `intersection()` ‚Äì Return common elements

  ```py
  s1 = {1, 2, 3}
  s2 = {2, 3, 4}
  print(s1.intersection(s2))  # {2, 3}
  ```

- `intersection_update()` ‚Äì Update set to keep only common elements

  ```py
  s1 = {1, 2, 3}
  s2 = {2, 3, 4}
  s1.intersection_update(s2)
  print(s1)  # {2, 3}
  ```

- `difference()` ‚Äì Elements in first set but not in second

  ```py
  s1 = {1, 2, 3}
  s2 = {2, 3, 4}
  print(s1.difference(s2))  # {1}
  ```

- `difference_update()` ‚Äì Remove elements found in another set

  ```py
  s1 = {1, 2, 3}
  s2 = {2, 3}
  s1.difference_update(s2)
  print(s1)  # {1}
  ```

- `symmetric_difference()` ‚Äì Elements in either set but not both

  ```py
  s1 = {1, 2, 3}
  s2 = {3, 4, 5}
  print(s1.symmetric_difference(s2))  # {1, 2, 4, 5}
  ```

- `symmetric_difference_update()` ‚Äì Update set with symmetric difference

  ```py
  s1 = {1, 2, 3}
  s2 = {3, 4, 5}
  s1.symmetric_difference_update(s2)
  print(s1)  # {1, 2, 4, 5}
  ```

- `issubset()` ‚Äì Check if set is subset of another

  ```py
  s1 = {1, 2}
  s2 = {1, 2, 3}
  print(s1.issubset(s2))  # True
  ```

- `issuperset()` ‚Äì Check if set is superset of another

  ```py
  s1 = {1, 2, 3}
  s2 = {1, 2}
  print(s1.issuperset(s2))  # True
  ```

- `isdisjoint()` ‚Äì Check if sets have no elements in common

  ```py
  s1 = {1, 2}
  s2 = {3, 4}
  print(s1.isdisjoint(s2))  # True
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Set Functions

- `len()` ‚Äì Length of the set

  ```py
  s = {1, 2, 3}
  print(len(s))  # 3
  ```

- `max()` ‚Äì Maximum element

  ```py
  s = {5, 2, 8}
  print(max(s))  # 8
  ```

- `min()` ‚Äì Minimum element

  ```py
  s = {5, 2, 8}
  print(min(s))  # 2
  ```

- `sum()` ‚Äì Sum of elements

  ```py
  s = {1, 2, 3, 4}
  print(sum(s))  # 10
  ```

- `any()` ‚Äì Returns True if any element is truthy

  ```py
  s = {0, False, 5}
  print(any(s))  # True
  ```

- `all()` ‚Äì Returns True if all elements are truthy

  ```py
  s = {1, 2, 3}
  print(all(s))  # True
  ```

- `sorted()` ‚Äì Return sorted elements as a list

  ```py
  s = {3, 1, 2}
  print(sorted(s))  # [1, 2, 3]
  ```

- `type()` ‚Äì Check the type**

  ```py
  s = {1, 2, 3}
  print(type(s))  # <class 'set'>
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Frozenset in Python

- An immutable version of a set.
- Elements cannot be added or removed once created.
- Created using `frozenset()`.

  ```py
  fs = frozenset([1, 2, 3, 3])
  print(fs)  # frozenset({1, 2, 3})
  ```

- Operations Allowed
  - Can perform union, intersection, difference, symmetric difference

    ```py
    fs1 = frozenset([1, 2, 3])
    fs2 = frozenset([2, 3, 4])
    print(fs1.union(fs2))  # frozenset({1, 2, 3, 4})
    print(fs1.intersection(fs2))  # frozenset({2, 3})
    ```

- Not Allowed
  - No `add()`, `remove()`, `pop()`, or `clear()` methods.

[‚¨ÜÔ∏è Go to Context](#context)

### Set Comprehension

- A concise way to create a set using expressions inside curly braces `{}`.

  ```py
  s = {x*2 for x in range(5)}
  print(s)  # {0, 2, 4, 6, 8}
  ```

- With Condition

  ```py
  s = {x for x in range(10) if x%2 == 0}
  print(s)  # {0, 2, 4, 6, 8}
  ```

- From Another Collection

  ```py
  lst = [1, 2, 2, 3, 4]
  s = {x for x in lst}
  print(s)  # {1, 2, 3, 4}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Using `zip()` with Sets

- `zip()` can combine multiple iterables element-wise.
- When used with sets, the iteration order is **arbitrary** because sets are unordered.

    ```py
    s1 = {1, 2, 3}
    s2 = {'a', 'b', 'c'}
    zipped = zip(s1, s2)
    print(list(zipped))  # Example output: [(1, 'b'), (2, 'a'), (3, 'c')]
    ```

- **Iterating Directly**

  ```py
  s1 = {1, 2, 3}
  s2 = {'x', 'y', 'z'}
  for num, char in zip(s1, s2):
      print(num, char)
  # Output order may vary because sets are unordered
  ```

- **Unzipping**

  ```py
  zipped = [(1, 'a'), (2, 'b'), (3, 'c')]
  s1, s2 = zip(*zipped)
  print(s1)  # (1, 2, 3)
  print(s2)  # ('a', 'b', 'c')
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Dictionary**

- A dictionary is an **unordered**, **mutable**, and **key-value pair** collection.
- Keys must be **unique and immutable** (strings, numbers, tuples, etc.).
- Values can be **any data type** and duplicates are allowed.
- Created using **curly braces `{}`** or the **dict()** constructor.

- **Characteristics**
  - **Unordered** ‚Äî Items have no fixed position (Python 3.7+ preserves insertion order as implementation detail)
  - **Mutable** ‚Äî Can add, modify, or delete items
  - **Key-Value Pairs** ‚Äî Data stored in key:value format
  - **Unique Keys** ‚Äî Duplicate keys are not allowed
  - **Heterogeneous** ‚Äî Keys and values can be of different data types
  - **Dynamic** ‚Äî Can grow or shrink as needed
  - **Nested Structures Allowed** ‚Äî Dictionaries can contain lists, tuples, or other dictionaries

    ```py
    my_dict = {"name": "TT", "age": 25, "country": "Bangladesh"}
    print(my_dict)  # {'name': 'TT', 'age': 25, 'country': 'Bangladesh'}
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Creating a Dictionary

- Using curly braces

  ```py
  my_dict = {"name": "TT", "age": 25}
  ```

- Using `dict()` constructor

  ```py
  my_dict = dict(name="TT", age=25)
  ```

- Empty dictionary

  ```py
  my_dict = {}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Accessing Items in Dictionary

- Using `key`

  ```py
  my_dict = {"name": "TT", "age": 25}
  print(my_dict["name"])  # TT
  ```

- Using `get()`

  ```py
  print(my_dict.get("age"))  # 25
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Editing Items in Dictionary

- Modifying value

  ```py
  my_dict["age"] = 26
  print(my_dict)  # {'name': 'TT', 'age': 26}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Adding Items in Dictionary

- Adding new key-value pair

  ```py
  my_dict["country"] = "Bangladesh"
  print(my_dict)  # {'name': 'TT', 'age': 26, 'country': 'Bangladesh'}
  ```

- Using `update()`

  ```py
  my_dict.update({"city": "Dhaka"})
  print(my_dict)  # {'name': 'TT', 'age': 26, 'country': 'Bangladesh', 'city': 'Dhaka'}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Deleting Items in Dictionary

- Using `pop()`

  ```py
  my_dict.pop("city")
  print(my_dict)  # {'name': 'TT', 'age': 26, 'country': 'Bangladesh'}
  ```

- Using `popitem()` (removes last inserted item)

  ```py
  my_dict.popitem()
  print(my_dict)  # {'name': 'TT', 'age': 26}
  ```

- Using `del`

  ```py
  del my_dict["age"]
  print(my_dict)  # {'name': 'TT'}
  ```

- Using `clear()` (removes all items)

  ```py
  my_dict.clear()
  print(my_dict)  # {}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Operations on Dictionary

- Membership Testing (`in`, `not in`)

  ```py
  my_dict = {"name": "TT", "age": 25}
  print("name" in my_dict)      # True
  print("country" not in my_dict)  # True
  ```

- Iteration over Keys

  ```py
  my_dict = {"name": "TT", "age": 25}
  for key in my_dict:
      print(key)
  # Output: name, age
  ```

- Iteration over Values

  ```py
  for value in my_dict.values():
      print(value)
  # Output: TT, 25
  ```

- Iteration over Items (key-value pairs)

  ```py
  for key, value in my_dict.items():
      print(key, value)
  # Output: name TT, age 25
  ```

- Length (`len()`)

  ```py
  print(len(my_dict))  # 2
  ```

- Copying Dictionary

  ```py
  new_dict = my_dict.copy()
  print(new_dict)  # {'name': 'TT', 'age': 25}
  ```

- Merging Dictionaries (update)

  ```py
  dict1 = {"a": 1, "b": 2}
  dict2 = {"b": 3, "c": 4}
  dict1.update(dict2)
  print(dict1)  # {'a': 1, 'b': 3, 'c': 4}
  ```

- Get with Default

  ```py
  print(my_dict.get("country", "Not Found"))  # Not Found
  ```

- Keys, Values, Items

  ```py
  print(my_dict.keys())    # dict_keys(['name', 'age'])
  print(my_dict.values())  # dict_values(['TT', 25])
  print(my_dict.items())   # dict_items([('name', 'TT'), ('age', 25)])
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Dictionary Methods

- `clear()` ‚Äì Remove all items

  ```py
  my_dict = {"name": "TT", "age": 25}
  my_dict.clear()
  print(my_dict)  # {}
  ```

- `copy()` ‚Äì Return a shallow copy

  ```py
  my_dict = {"name": "TT", "age": 25}
  new_dict = my_dict.copy()
  print(new_dict)  # {'name': 'TT', 'age': 25}
  ```

- `fromkeys()` ‚Äì Create dictionary with keys and default value

  ```py
  keys = ["a", "b", "c"]
  new_dict = dict.fromkeys(keys, 0)
  print(new_dict)  # {'a': 0, 'b': 0, 'c': 0}
  ```

- `get()` ‚Äì Return value of key (default if key not found)

  ```py
  my_dict = {"name": "TT"}
  print(my_dict.get("name"))       # TT
  print(my_dict.get("age", 0))     # 0
  ```

- `items()` ‚Äì Return key-value pairs

  ```py
  my_dict = {"name": "TT", "age": 25}
  print(my_dict.items())  # dict_items([('name', 'TT'), ('age', 25)])
  ```

- `keys()` ‚Äì Return keys

  ```py
  print(my_dict.keys())  # dict_keys(['name', 'age'])
  ```

- `values()` ‚Äì Return values

  ```py
  print(my_dict.values())  # dict_values(['TT', 25])
  ```

- `pop()` ‚Äì Remove item by key

  ```py
  my_dict.pop("age")
  print(my_dict)  # {'name': 'TT'}
  ```

- `popitem()` ‚Äì Remove last inserted item

  ```py
  my_dict.popitem()
  print(my_dict)  # {}
  ```

- `setdefault()` ‚Äì Return value if key exists, else set default

  ```py
  my_dict = {"name": "TT"}
  print(my_dict.setdefault("age", 20))  # 20
  print(my_dict)  # {'name': 'TT', 'age': 20}
  ```

- `update()` ‚Äì Update dictionary with key-value pairs

  ```py
  my_dict.update({"name": "John", "country": "BD"})
  print(my_dict)  # {'name': 'John', 'age': 20, 'country': 'BD'}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Dictionary Functions

- `len()` ‚Äì Number of items

  ```py
  my_dict = {"name": "TT", "age": 25}
  print(len(my_dict))  # 2
  ```

- `type()` ‚Äì Type of the object

  ```py
  print(type(my_dict))  # <class 'dict'>
  ```

- `all()` ‚Äì True if all keys are truthy

  ```py
  my_dict = {"a": 1, "b": 2}
  print(all(my_dict))  # True
  ```

- `any()` ‚Äì True if any key is truthy

  ```py
  my_dict = {"a": 0, "b": 2}
  print(any(my_dict))  # True
  ```

- `sorted()` ‚Äì Return sorted list of keys

  ```py
  my_dict = {"c": 3, "a": 1, "b": 2}
  print(sorted(my_dict))  # ['a', 'b', 'c']
  ```

- `sum()` ‚Äì Sum of keys if numeric

  ```py
  my_dict = {1: "a", 2: "b", 3: "c"}
  print(sum(my_dict))  # 6
  ```

- `max()` ‚Äì Maximum key

  ```py
  print(max(my_dict))  # 3
  ```

- `min()` ‚Äì Minimum key

  ```py
  print(min(my_dict))  # 1
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Dictionary Unpacking

- Extract keys and values directly into variables.

  ```py
  my_dict = {"name": "TT", "age": 25}
  k, v = list(my_dict.items())[0]
  print(k, v)  # name TT
  ```

- Using `**` to merge dictionaries

  ```py
  dict1 = {"a": 1, "b": 2}
  dict2 = {"c": 3, "d": 4}
  merged = {**dict1, **dict2}
  print(merged)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Using `zip()` with Dictionary

- Combine two iterables into key-value pairs.

  ```py
  keys = ["name", "age", "country"]
  values = ["TT", 25, "Bangladesh"]
  my_dict = dict(zip(keys, values))
  print(my_dict)  # {'name': 'TT', 'age': 25, 'country': 'Bangladesh'}
  ```

- Iterating with zip()

  ```py
  for k, v in zip(keys, values):
      print(k, v)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Dictionary Comprehension

- Create dictionaries using a single expression inside `{}`.

  ```py
  squares = {x: x**2 for x in range(5)}
  print(squares)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
  ```

- With condition

  ```py
  even_squares = {x: x**2 for x in range(10) if x % 2 == 0}
  print(even_squares)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}
  ```

- From two lists

  ```py
  keys = ["a", "b", "c"]
  values = [1, 2, 3]
  my_dict = {k: v for k, v in zip(keys, values)}
  print(my_dict)  # {'a': 1, 'b': 2, 'c': 3}
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Simple Project Using Dictionary

- Restaurant Management

  ```py
  menu = {
      "Coffee": 2,
      "Pasta": 3,
      "Pizza": 5,
      "Burger": 6,
      "Chicken": 10
  }
  print(
      """
      Welcome to Inception's Restaurant. Please Order Food!

      Coffee: $2
      Pasta: $3
      Pizza: $5
      Burger: $6
      Chicken: $10

      """
  )

  item1 = input("Enter the name of the item you want to order: ")
  total_price = 0
  if item1 in menu:
      total_price += menu[item1]
      print(f"You ordered {item1}. Your total order is ${total_price}")
  else:
      print("Invalid item, Please order something from the Menu")
  another_order = input("Do you want to add another item? (Yes/No): ").lower()
  if another_order == "yes":
      item2 = input("Enter the name of the 2nd item you want to order: ")
      if item2 in menu:
          total_price += menu[item2]
          print(f"You ordered {item2}. Your total order is ${total_price}")
      else:
          print("Invalid item, Please order something from the Menu")
  print(f"Your total amount is ${total_price}. Thank you!")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 09 - Functions in Python**

## **Functions in Python**

- A function is a reusable block of code that performs a specific task.
- Created using the `def` keyword.
- Can take inputs (parameters) and return outputs.

[‚¨ÜÔ∏è Go to Context](#context)

### Characteristics of Function

- Defined using the 'def' keyword.
- Executes only when it is called.
- Can accept inputs (parameters).
- Can return outputs using '`return`'.
- Helps avoid code repetition.
- Improves code readability and organization.
- Can be built-in (print, len) or user-defined.
- Supports default parameter values.
- Supports variable arguments (`*args`,`**kwargs`).
- Has its own local scope separate from global scope.
- May or may not return a value.
- Can be nested (function inside another).
- Can be passed as arguments or stored in variables (first-class functions).

[‚¨ÜÔ∏è Go to Context](#context)

### Creating a Function

- Defined using the 'def' keyword

  ```py
  def greet():
      print("Hello, TT!")
  greet()
  ```

- Function with Parameters

  ```py
  def add(a, b):
      return a + b

  print(add(5, 3))  # 8
  ```

- Function with Default Parameter

  ```py
  def greet(name="TT"):
      print("Hello,", name)

  greet()         # Hello, TT
  greet("John")   # Hello, John
  ```

- Function with Return Value

    ```py
    def square(n):
        return n * n

    print(square(4))  # 16
    ```

- Keyword Arguments

  ```py
  def info(name, age):
      print(name, age)

  info(age=25, name="TT")
  ```

- Variable-Length Arguments (`*args`)

  ```py
  def total(*nums):
      print(sum(nums))

  total(1, 2, 3, 4)  # 10
  ```

- Variable-Length Keyword Arguments (`**kwargs`)

  ```py
  def show(**data):
      print(data)

  show(name="TT", age=25)
  ```

- Lambda (Anonymous Function)

  ```py
  double = lambda x: x * 2
  print(double(5))  # 10
  ```

- Pass Statement

  ```py
  def todo():
      pass  # empty function
  ```

- Docstring - A string used to describe what a function does, placed at the beginning of the function

  ```py
  def add(a, b):
      """Returns the sum of two numbers."""
      return a + b

  print(add.__doc__)
  ```

- Calling Functions

  ```py
  def hello():
      print("Hi!")

  hello()
  ```

- Deleting Functions

  ```py
  def hello():
      print("Hi!")

  del hello
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Parameter vs Argument

- **Parameter** ‚Äì Variable defined in the function to accept input

  ```py
  def greet(name, age):  # name and age are parameters
      print(f"Hello {name}, you are {age} years old")
  ```

- **Argument** ‚Äì Actual value passed to the function when calling it

  ```py
  greet("TT", 25)  # "TT" and 25 are arguments
  ```

- **Key Difference** ‚Äì Parameters exist in function definition, arguments exist in function call

  ```py
  # Parameters: name, age
  # Arguments: "TT", 25
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Types of Arguments

- **Positional Arguments** ‚Äì Passed in order

  ```py
  def greet(name, age):
      print(f"Hello {name}, you are {age} years old")

  greet("TT", 25)  # Hello TT, you are 25 years old
  ```

- **Keyword Arguments** ‚Äì Passed using parameter names

  ```py
  greet(age=25, name="TT")  # Hello TT, you are 25 years old
  ```

- **Default Arguments** ‚Äì Use default value if not provided

  ```py
  def greet(name, age=18):
      print(f"Hello {name}, you are {age} years old")

  greet("TT")  # Hello TT, you are 18 years old
  ```

- **Variable-length Arguments (`*args`)** ‚Äì Accepts any number of positional arguments

  ```py
  def add(*numbers):
      print(sum(numbers))

  add(1, 2, 3, 4)  # 10
  ```

- **Variable-length Keyword Arguments (`**kwargs`)** ‚Äì Accepts any number of keyword arguments

  ```py
  def info(**details):
      print(details)

  info(name="TT", age=25)  # {'name': 'TT', 'age': 25}
  ```

- **Required Arguments** ‚Äì Must be provided, no default

  ```py
  def greet(name, age):
      print(f"Hello {name}, you are {age}")

  # greet("TT")  # Error: missing required argument 'age'
  ```

- **Positional-only Arguments (Python 3.8+)** ‚Äì Must be passed by position

  ```py
  def greet(name, /, age):
      print(f"{name} is {age}")

  greet("TT", age=25)  # TT is 25
  ```

- **Keyword-only Arguments** ‚Äì Must be passed by keyword

  ```py
  def greet(*, name, age):
      print(f"{name} is {age}")

  greet(name="TT", age=25)  # TT is 25
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### `*args` vs `**kwargs`

- **`*args`** ‚Äì Accepts any number of positional arguments as a tuple

  ```py
  def add(*numbers):
      print(numbers)
      print(sum(numbers))

  add(1, 2, 3, 4)
  # Output:
  # (1, 2, 3, 4)
  # 10
  ```

- **`**kwargs`** ‚Äì Accepts any number of keyword arguments as a dictionary

  ```py
  def info(**details):
      print(details)

  info(name="TT", age=25)
  # Output:
  # {'name': 'TT', 'age': 25}
  ```

- **Key Difference**
  - `*args` ‚Üí positional arguments, tuple
  - `**kwargs` ‚Üí keyword arguments, dictionary

[‚¨ÜÔ∏è Go to Context](#context)

### Variable Scope in Functions

- **Local Scope** ‚Äì Variables defined inside a function, accessible only within that function

  ```py
  def my_func():
      x = 10  # local variable
      print(x)

  my_func()  # 10
  # print(x)  # Error: x is not defined
  ```

- **Global Scope** ‚Äì Variables defined outside all functions, accessible anywhere

  ```py
  y = 20  # global variable

  def show():
      print(y)

  show()  # 20
  print(y)  # 20
  ```

- **Using `global` Keyword** ‚Äì Modify global variables inside a function

  ```py
  count = 0

  def increment():
      global count
      count += 1

  increment()
  print(count)  # 1
  ```

- **Enclosing / Nonlocal Scope** ‚Äì Variables in outer (enclosing) function, accessible in nested function

  ```py
  def outer():
      a = 5
      def inner():
          nonlocal a
          a += 1
          print(a)
      inner()
      print(a)

  outer()
  # Output:
  # 6
  # 6
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Nested Functions

- **Nested Function** ‚Äì A function defined inside another function

  ```py
  def outer():
      print("This is the outer function")

      def inner():
          print("This is the inner function")

      inner()  # Calling inner function inside outer

  outer()
  # Output:
  # This is the outer function
  # This is the inner function
  ```

- **Accessing Outer Variable** ‚Äì Inner function can access variables from outer function

  ```py
  def outer():
      x = 10
      def inner():
          print(f"Value from outer: {x}")
      inner()

  outer()
  # Output:
  # Value from outer: 10
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Functions are First-Class Citizens

- Functions in Python can be treated like any other object: assigned to variables, passed as arguments, and returned from other functions.

- **Assigning Function to a Variable**

  ```py
  def greet():
      print("Hello TT")

  say_hello = greet  # assigning function to a variable
  say_hello()  # Hello TT
  ```

- **Passing Function as Argument**

  ```py
  def greet():
      print("Hello TT")

  def call_func(func):
      func()

  call_func(greet)  # Hello TT
  ```

- **Returning Function from Another Function**

  ```py
  def outer():
      def inner():
          print("Inside inner function")
      return inner

  my_func = outer()
  my_func()  # Inside inner function
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Benefits of Using a Function

- **Code Modularity** ‚Äì Breaks program into smaller, manageable parts

  ```py
  def calculate_area(radius):
      return 3.14 * radius * radius

  def calculate_circumference(radius):
      return 2 * 3.14 * radius
  ```

- **Code Readability** ‚Äì Improves clarity and understanding of the program

  ```py
  def greet_user(name):
      print(f"Hello {name}, welcome!")
  ```

- **Code Reusability** ‚Äì Functions can be reused multiple times without rewriting code

  ```py
  def add(a, b):
      return a + b

  print(add(5, 10))
  print(add(20, 30))
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Lambda Function

- A small anonymous function defined using the `lambda` keyword, usually for simple operations

  ```py
  # Syntax: lambda arguments: expression

  square = lambda x: x ** 2
  print(square(5))  # 25
  ```

- **Multiple Arguments**

  ```py
  add = lambda a, b: a + b
  print(add(10, 20))  # 30
  ```

- **Used with `map()`**

  ```py
  nums = [1, 2, 3, 4]
  squared = list(map(lambda x: x**2, nums))
  print(squared)  # [1, 4, 9, 16]
  ```

- **Used with `filter()`**

  ```py
  nums = [1, 2, 3, 4, 5]
  even = list(filter(lambda x: x % 2 == 0, nums))
  print(even)  # [2, 4]
  ```

- **Used with `sorted()`**

  ```py
  points = [(1, 2), (3, 1), (5, 0)]
  sorted_points = sorted(points, key=lambda x: x[1])
  print(sorted_points)  # [(5, 0), (3, 1), (1, 2)]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Lambda vs Normal Function

- **Normal Function** ‚Äì Defined using `def`, can have multiple statements, name is mandatory

  ```py
  def add(a, b):
      result = a + b
      return result

  print(add(5, 10))  # 15
  ```

- **Lambda Function** ‚Äì Anonymous function using `lambda`, limited to a single expression

  ```py
  add = lambda a, b: a + b
  print(add(5, 10))  # 15
  ```

- **Key Differences**

  - Normal Function:
    - Defined with 'def'
    - Can contain multiple statements
    - Has a function name
    - Can include loops, conditions, etc.

  - Lambda Function:
    - Defined with 'lambda'
    - Single expression only
    - Anonymous (no name, unless assigned)
    - Mostly used for short, simple operations

[‚¨ÜÔ∏è Go to Context](#context)

### Higher-Order Functions

- Functions that can take other functions as arguments and/or return functions as results

- **Passing Function as Argument**

  ```py
  def greet():
      print("Hello TT")

  def call_func(func):
      func()  # function passed as argument

  call_func(greet)  # Hello TT
  ```

- **Returning Function from Another Function**

  ```py
  def outer():
      def inner():
          print("Inside inner function")
      return inner  # returning function

  my_func = outer()
  my_func()  # Inside inner function
  ```

- **Built-In Higher Order Functions**

- **`map()`** ‚Äì Applies a function to all items in an iterable

  ```py
  nums = [1, 2, 3, 4]
  squared = list(map(lambda x: x**2, nums))
  print(squared)  # [1, 4, 9, 16]
  ```

- **`filter()`** ‚Äì Filters items in an iterable based on a function

  ```py
  nums = [1, 2, 3, 4, 5]
  even = list(filter(lambda x: x % 2 == 0, nums))
  print(even)  # [2, 4]
  ```

- **`reduce()`** ‚Äì Applies a function cumulatively to items (from `functools`)

  ```py
  from functools import reduce
  nums = [1, 2, 3, 4]
  total = reduce(lambda x, y: x + y, nums)
  print(total)  # 10
  ```

- **`sorted()`** ‚Äì Can take a key function for custom sorting

  ```py
  points = [(1, 2), (3, 1), (5, 0)]
  sorted_points = sorted(points, key=lambda x: x[1])
  print(sorted_points)  # [(5, 0), (3, 1), (1, 2)]
  ```

- **`any()` and `all()`** ‚Äì Can be combined with functions in comprehension or `map`

  ```py
  nums = [0, 1, 2, 3]
  print(all(map(lambda x: x > 0, nums)))  # False
  print(any(map(lambda x: x > 0, nums)))  # True
  ```

- **`zip()` with function** ‚Äì Combine iterables and apply function using `map`

  ```py
  a = [1, 2, 3]
  b = [4, 5, 6]
  sum_list = list(map(lambda x: x[0]+x[1], zip(a, b)))
  print(sum_list)  # [5, 7, 9]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### `enumerate()` Function

- Adds a counter to an iterable and returns it as an `enumerate` object, which can be converted to a list or tuple

  ```py
  fruits = ["apple", "banana", "cherry"]
  for index, fruit in enumerate(fruits):
      print(index, fruit)

  # Output:
  # 0 apple
  # 1 banana
  # 2 cherry
  ```

- **Start Index** ‚Äì You can specify a starting index

  ```py
  fruits = ["apple", "banana", "cherry"]
  for index, fruit in enumerate(fruits, start=1):
      print(index, fruit)

  # Output:
  # 1 apple
  # 2 banana
  # 3 cherry
  ```

- **Usage with List Conversion**

  ```py
  fruits = ["apple", "banana", "cherry"]
  enum_list = list(enumerate(fruits))
  print(enum_list)  # [(0, 'apple'), (1, 'banana'), (2, 'cherry')]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 10 - Virtual Environment & Requirements**

## **Virtual Environment**

### Create Conda Environment

- Create an environment in current folder (`-p`) or ` -n` for conda default path

  ```sh
  conda create -p .venv
  ```

- Activate Environment

  ```sh
  conda activate ./.venv
  ```

- Install Python in Environment

  ```sh
  conda install python=3.13
  ```

- Install Packages

  ```sh
  conda install numpy pandas
  ```

- Deactivate Environment

  ```sh
  conda deactivate
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### List and Remove Conda Environments

- List All Environments ‚Äì Shows all conda environments

  ```sh
  conda env list
  # or
  conda info --envs
  ```

- Remove Environment by Name

  ```sh
  conda remove --name my_env --all
  ```

- Remove Environment by Path

  ```sh
  conda remove -p ./my_env --all
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Requirements**

### `requirements.txt` file

- A plain text file listing all Python packages and versions required for a project

  ```txt
  # Example contents of requirements.txt
  numpy==1.26.0
  pandas==2.1.0
  matplotlib==3.8.0
  scikit-learn==1.3.0
  django==5.2.0
  ```

- Install Packages from `requirements.txt`

  ```sh
  pip install -r requirements.txt
  ```

- Generate `requirements.txt` from Current Environment

  ```sh
  pip freeze > requirements.txt
  ```

- Check Installed Packages

  ```sh
  pip list
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# [**Assignment 03**](./Assignments/Assignment%2003/)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 11 - File Handling, Exception Handling and Logging**

## **File Handling**

### What is File Handling?

- A way to read from and write to files using Python‚Äôs built-in functions.
- To store data permanently.
- To read/write logs, configs, reports, user data, etc.

---

- Types of data used for I/O:
  - Text - '12345' as a sequence of unicode chars
  - Binary - 12345 as a sequence of bytes of its binary equivalent

- Hence there are 2 file types to deal with
  - Text files - All program files are text files
  - Binary Files - Images,music,video,exe files

- How File I/O is done in most programming languages
  - Open a file
  - Read/Write data
  - Close the file

[‚¨ÜÔ∏è Go to Context](#context)

### File Modes

- '`r`'  ‚Üí read (default)
- '`w`'  ‚Üí write (overwrites file)
- '`a`'  ‚Üí append (adds to file)
- '`x`'  ‚Üí create error if file exists
- '`b`'  ‚Üí binary mode (images, videos)
- '`t`'  ‚Üí text mode (default)
- Combinations: '`rb`', '`wb`', '`ab`', etc.

[‚¨ÜÔ∏è Go to Context](#context)

### File Handling Using `Open` All Modes

- '`r`'  ‚Üí Read mode (default)
  - Opens file for reading.
  - Raises error if file does not exist.

    ```py
    f = open("data.txt", "r")
    content = f.read()
    f.close()
    ```

- '`w`'  ‚Üí Write mode
  - Creates file if missing.
  - Overwrites file if exists.

    ```py
      f = open("data.txt", "w")
      f.write("Hello World")
      f.close()
      ```

- '`a`'  ‚Üí Append mode
  - Creates file if missing.
  - Adds new data at the end (does not overwrite).

    ```py
    f = open("data.txt", "a")
    f.write("\nNew Line Added")
    f.close()
    ```

- '`x`'  ‚Üí Exclusive creation mode
  - Creates new file.
  - Error if file already exists.

    ```py
    f = open("newfile.txt", "x")
    f.write("Created using x mode")
    f.close()
    ```

- '`b`'  ‚Üí Binary mode
  - Used for images, videos, audio, PDFs.
  - Must combine with r/w/a.

    ```py
    f = open("image.jpg", "rb")
    data = f.read()
    f.close()
    ```

- '`t`'  ‚Üí Text mode (default)
  - Handles normal text files.

    ```py
    f = open("notes.txt", "rt")
    print(f.read())
    f.close()
    ```

- '`rb`'  ‚Üí Read Binary

  ```py
  f = open("file.bin", "rb")
  data = f.read()
  f.close()
  ```

- '`wb`'  ‚Üí Write Binary

  ```py
  f = open("file.bin", "wb")
  f.write(b"Binary Data")
  f.close()
  ```

- '`ab`'  ‚Üí Append Binary

  ```py
  f = open("file.bin", "ab")
  f.write(b"\nMore Binary Data")
  f.close()
  ```

- '`rt`'  ‚Üí Read Text (same as 'r')

  ```py
  f = open("info.txt", "rt")
  ```

- '`wt`'  ‚Üí Write Text (same as 'w')

  ```py
  f = open("info.txt", "wt")
  ```

- '`at`'  ‚Üí Append Text (same as 'a')

  ```py
  f = open("info.txt", "at")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### File Handling Using `with` All Modes

- '`r`' ‚Üí Read mode (default)
  - Opens file for reading.
  - Automatically closes file after block ends.

    ```py
    with open("data.txt", "r") as f:
        content = f.read()
        print(content)
    ```

- '`w`' ‚Üí Write mode
  - Creates file if missing.
  - Overwrites file if it exists.

    ```py
    with open("data.txt", "w") as f:
        f.write("Hello World")
    ```

- '`a`' ‚Üí Append mode
  - Creates file if missing.
  - Adds new data at the end.

    ```py
    with open("data.txt", "a") as f:
        f.write("\nNew Line Added")
    ```

- '`x`' ‚Üí Exclusive creation mode
  - Creates new file.
  - Error if file already exists.

    ```py
    with open("newfile.txt", "x") as f:
        f.write("Created using x mode")
    ```

- '`b`' ‚Üí Binary mode
  - Used for images, PDFs, videos.
  - Must combine with r/w/a.

    ```py
    with open("image.jpg", "rb") as f:
        data = f.read()
    ```

- '`t`' ‚Üí Text mode (default)
  - For normal text files.

    ```py
    with open("notes.txt", "rt") as f:
        print(f.read())
    ```

- '`rb`' ‚Üí Read Binary

    ```py
    with open("file.bin", "rb") as f:
        data = f.read()
    ```

- '`wb`' ‚Üí Write Binary

    ```py
    with open("file.bin", "wb") as f:
        f.write(b"Binary Data")
    ```

- '`ab`' ‚Üí Append Binary

    ```py
    with open("file.bin", "ab") as f:
        f.write(b"\nMore Binary Data")
    ```

- '`rt`' ‚Üí Read Text (same as 'r')

    ```py
    with open("info.txt", "rt") as f:
        print(f.read())
    ```

- '`wt`' ‚Üí Write Text (same as 'w')

    ```py
    with open("info.txt", "wt") as f:
        f.write("Hello!")
    ```

- '`at`' ‚Üí Append Text (same as 'a')

    ```py
    with open("info.txt", "at") as f:
        f.write("\nAppended text")
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### `Open` vs `With` in Python

- **Using `open()`**
  - Must manually close the file using `close()`.
  - If an error occurs, file may remain open (resource leak).
  - More lines of code and less safe.

    ```py
    f = open("data.txt", "r")
    content = f.read()
    f.close()
    ```

- **Using `with`**
  - Automatically closes the file after block ends.
  - Prevents resource leaks even if errors occur.
  - Cleaner, safer, and recommended.

    ```py
    with open("data.txt", "r") as f:
        content = f.read()
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Serialization and Deserialization

- **Serialization**
  - Process of converting Python data types into JSON format.
  - Useful for storing or transmitting data.

    ```py
    import json

    data = {"name": "TT", "age": 25, "city": "Dhaka"}
    json_str = json.dumps(data)  # Python dict ‚Üí JSON string
    print(json_str)  # '{"name": "TT", "age": 25, "city": "Dhaka"}'
    ```

- **Deserialization**
  - Process of converting JSON data back into Python data types.

    ```py
    import json

    json_str = '{"name": "TT", "age": 25, "city": "Dhaka"}'
    data = json.loads(json_str)  # JSON string ‚Üí Python dict
    print(data)  # {'name': 'TT', 'age': 25, 'city': 'Dhaka'}
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### Pickling in Python

- **Pickling**
  - Process of converting Python objects into a byte stream.
  - Can also pickle functions for later use (if defined at top level).

    ```py
    import pickle

    def display_info():
        return "Hi my name is Tansen and I am a Programmer"

    with open("func.pkl", "wb") as f:
        pickle.dump(display_info, f)
    ```

- **Unpickling**
  - Process of converting byte stream back into Python objects.
  - Can call the unpickled function like normal.

    ```py
    import pickle

    with open("func.pkl", "rb") as f:
        func = pickle.load(f)

    print(func())  # Hi my name is Tansen and I am a Programmer
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### JSON Dump vs Pickling

- **JSON Dump**
  - Converts Python objects to JSON string format.
  - Text-based, human-readable.
  - Can be shared across different programming languages.
  - Supports basic Python types (dict, list, str, int, float, bool, None).
  - Cannot serialize custom Python objects or functions directly.

    ```py
    import json

    def display_info():
        return "Hi my name is Tansen and I am a Programmer"

    data = {"name": "Tansen", "age": 25, "info": "Programmer"}
    json_str = json.dumps(data)  # Serialize Python dict
    print(json_str)  # '{"name": "Tansen", "age": 25, "info": "Programmer"}'
    ```

- **Pickling**
  - Converts Python objects to byte stream.
  - Binary format, not human-readable.
  - Python-specific, cannot be directly used in other languages.
  - Can serialize almost any Python object including custom classes and functions.

    ```py
    import pickle

    def display_info():
        return "Hi my name is Tansen and I am a Programmer"

    with open("func.pkl", "wb") as f:
        pickle.dump(display_info, f)  # Serialize function

    with open("func.pkl", "rb") as f:
        func = pickle.load(f)

    print(func())  # Hi my name is Tansen and I am a Programmer
    ```

[‚¨ÜÔ∏è Go to Context](#context)

### File Handling Using `os` Module

- Importing OS Module

  ```py
  import os
  ```

- Check if File or Directory Exists

  ```py
  os.path.exists("data.txt")        # True if file or folder exists
  os.path.isfile("data.txt")        # True if it is a file
  os.path.isdir("my_folder")        # True if it is a directory
  ```

- Create a Directory

  ```py
  os.mkdir("my_folder")             # Single directory
  os.makedirs("parent/child")       # Nested directories
  ```

- Remove/Delete a Directory

  ```py
  os.rmdir("my_folder")             # Only empty directories
  os.removedirs("parent/child")     # Nested empty directories
  ```

- Remove/Delete a File

  ```py
  os.remove("data.txt")
  ```

- Rename a File or Directory

  ```py
  os.rename("old_name.txt", "new_name.txt")
  ```

- List Files and Directories

  ```py
  os.listdir(".")                    # List current directory
  os.listdir("/path/to/folder")      # List specific folder
  ```

- Get Current Working Directory

  ```py
  cwd = os.getcwd()
  print(cwd)
  ```

- Change Directory

  ```py
  os.chdir("my_folder")
  print(os.getcwd())
  ```

- Join Paths

  ```py
  full_path = os.path.join("folder", "file.txt")
  print(full_path)                   # folder/file.txt (or folder\file.txt in Windows)
  ```

- Get Absolute Path

  ```py
  abs_path = os.path.abspath("data.txt")
  print(abs_path)
  ```

- Split Path

  ```py
  folder, file = os.path.split("/path/to/data.txt")
  print(folder, file)
  ```

- Get File Name and Extension

  ```py
  name, ext = os.path.splitext("data.txt")
  print(name, ext)                   # data .txt
  ```

- Check Access Permissions

  ```py
  os.access("data.txt", os.R_OK)    # True if readable
  os.access("data.txt", os.W_OK)    # True if writable
  os.access("data.txt", os.X_OK)    # True if executable
  ```

- File Size

  ```py
  size = os.path.getsize("data.txt")
  print(size)
  ```

- Modification and Creation Time

  ```py
  import time
  mod_time = os.path.getmtime("data.txt")
  print(time.ctime(mod_time))
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Exception Handling in Python**

- Mechanism to handle runtime errors.
- Prevents program from crashing.

[‚¨ÜÔ∏è Go to Context](#context)

### Try and Except

  ```py
  try:
      x = 10 / 0
  except ZeroDivisionError:
      print("Cannot divide by zero")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Try, Except with Multiple Exceptions

  ```py
  try:
      num = int("abc")
      x = 10 / 0
  except ValueError:
      print("Invalid value")
  except ZeroDivisionError:
      print("Cannot divide by zero")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Try, Except with Generic Exception

  ```py
  try:
      x = 10 / 0
  except Exception as e:
      print("Error:", e)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Else Block

- Executes if no exception occurs.

  ```py
  try:
      x = 10 / 2
  except ZeroDivisionError:
      print("Error")
  else:
      print("No error, result is", x)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Finally Block

- Executes regardless of exception.

  ```py
  try:
      x = 10 / 0
  except ZeroDivisionError:
      print("Error")
  finally:
      print("Always runs")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Raising Exceptions

- Manually trigger an exception.

  ```py
  age = -5
  if age < 0:
      raise ValueError("Age cannot be negative")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Custom Exception

  ```py
  class CustomError(Exception):
      pass

  raise CustomError("This is a custom exception")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Try-Except-Else-Finally Complete Structure

  ```py
  try:
      x = int(input("Enter a number: "))
      result = 10 / x
  except ValueError:
      print("Invalid input")
  except ZeroDivisionError:
      print("Cannot divide by zero")
  else:
      print("Result is", result)
  finally:
      print("End of program")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Logging in Python**

- Logging records events, errors, and messages during program execution.
- Useful for debugging and monitoring applications.

[‚¨ÜÔ∏è Go to Context](#context)

### Import Logging Module

  ```py
  import logging
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Basic Configuration (Console Logging)

  ```py
  logging.basicConfig(level=logging.DEBUG)
  logging.debug("This is a debug message")
  logging.info("Informational message")
  logging.warning("Warning message")
  logging.error("Error occurred")
  logging.critical("Critical issue")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Logging to a File

  ```py
  log_path = "app.log"
  logging.basicConfig(
      filename=log_path,
      format="[ %(asctime)s ] %(name)s - %(levelname)s - %(message)s",
      level=logging.INFO
  )

  logging.info("This will be written to a file with timestamp and format")
  logging.warning("This is a warning")
  logging.error("This is an error")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Logging Levels

- `DEBUG` ‚Üí Detailed information, for development.
- `INFO` ‚Üí General events, program flow.
- `WARNING` ‚Üí Indicates a potential problem.
- `ERROR` ‚Üí Serious problem that prevents a function from running.
- `CRITICAL` ‚Üí Very serious error, may stop program.

[‚¨ÜÔ∏è Go to Context](#context)

### Custom Logger

  ```py
  logger = logging.getLogger("myLogger")
  logger.setLevel(logging.DEBUG)
  logger.info("Using custom logger")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Advanced Format

  ```py
  logging.basicConfig(format='%(levelname)s:%(name)s:%(message)s', level=logging.INFO)
  logging.info("Custom formatted log")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Exception Logging

  ```py
  try:
      x = 10 / 0
  except ZeroDivisionError:
      logging.exception("Exception occurred")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 12 - Building an Iron Man JARVIS System**

- JARVIS is a Python-based voice assistant that can interact with the user through speech recognition, perform tasks like opening applications, searching on Google or Wikipedia, playing music randomly, telling jokes, and having small talk.

- This project uses speech recognition and text-to-speech (TTS) to provide a hands-free assistant experience similar to Iron Man's JARVIS.

[‚¨ÜÔ∏è Go to Context](#context)

## **Features in JARVIS System**

- Greet the user according to the time of day (morning, afternoon, evening)
- Recognize voice commands using Google Speech Recognition
- Speak responses using pyttsx3
- Time & Date announcements
- Wikipedia search with spoken summary
- Open websites like Google, Facebook, YouTube
- Play random music from a specified folder
- Open system applications: Calculator, Notepad, CMD
- Open Calendar (Google Calendar via browser)
- Tell jokes and respond to basic small talk
- Exit gracefully with a voice command

[‚¨ÜÔ∏è Go to Context](#context)

## **JARVIS System Setup**

- Python `3.13` or higher
- Packages

  ```sh
  PyAudio==0.2.14
  pyttsx3==2.99
  SpeechRecognition==3.14.4
  wikipedia==1.4.0
  ```

- Create [virtual env](#create-conda-environment) then install package and run [jarvis.py](./Day%2012%20-%20Building%20an%20Iron%20Man%20JARVIS%20System/jarvis.py)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 13 - Multilingual AI Assistant**

## Extending Jarvis Chatbot

- Add new requirement `google-generativeai` to use gemini flash model `gemini-2.5-flash`
- And `python-dotenv` for loading secrete variable from `.env` like API key

  ```sh
  PyAudio==0.2.14
  pyttsx3==2.99
  SpeechRecognition==3.14.4
  wikipedia==1.4.0
  google-generativeai==0.8.5
  python-dotenv==1.2.1
  ```

- Get Free API from [Google AI Studio](https://aistudio.google.com/api-keys)
- Apply it in [jarvis.py](./Day%2013%20-%20Multilingual%20AI%20Assistant/jarvis.py)
- Use it for others query from user
- Run [jarvis.py](./Day%2013%20-%20Multilingual%20AI%20Assistant/jarvis.py)

[‚¨ÜÔ∏è Go to Context](#context)

# **Assignment 04**

- [Jarvis AI Project](https://github.com/aatansen/Jarvis-AI/)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 14 - Additional Topics, Regex**

## **Additional Topics**

### Python Code In Text Files

- We can execute a [text file](./Day%2014%20-%20Additional%20Topics,%20Regex/text_file.txt) that contains python code
  - `python text_file.txt`

[‚¨ÜÔ∏è Go to Context](#context)

### Command Line Utility

- Normal function

  ```py
  def calculator(a, b, operation):
      if operation == 'add':
          return a + b
      elif operation == 'subtract':
          return a - b
      elif operation == 'multiply':
          return a * b
      elif operation == 'divide':
          if b != 0:
              return a / b
          else:
              return "Error: Division by zero."
      else:
          return "Error: Invalid operation."

  result=calculator(3,5,'multiply')
  print(result)
  ```

- Command line utility

  ```py
  import argparse
  import sys

  def calculator(args):
      if args.o == 'add':
          return args.a + args.b
      elif args.o == 'sub':
          return args.a - args.b
      elif args.o == 'mul':
          return args.a * args.b
      elif args.o == 'div':
          if args.b != 0:
              return args.a / args.b
          else:
              return "Error: Division by zero."
      else:
          return "Error: Invalid operation."

  parser = argparse.ArgumentParser()
  parser.add_argument("--a", type=float, default=1.0)
  parser.add_argument("--b", type=float, default=2.0)
  parser.add_argument("--o", type=str, default="add")

  # args = parser.parse_args()
  # sys.stdout.write(str(calculator(args)))

  args = parser.parse_args()
  result = calculator(args)
  print(result)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Regular Expression (Regex)**

- Regular expressions, or "regex" for short, are a powerful tool for working with strings and text data in Python. They allow you to match and manipulate strings based on patterns, making it easy to perform complex string operations with just a few lines of code.
  - [Meta characters in regular expressions](https://www.ibm.com/docs/en/rational-clearquest/9.0.1?topic=tags-meta-characters-in-regular-expressions)

- **Basic Matching** ‚Äì Check if a pattern exists in a string

  ```py
  import re

  text = "I love Python"
  result = re.search("Python", text)

  print(bool(result))  # True
  ```

- **Find All Matches** ‚Äì Get all occurrences of a pattern

  ```py
  import re

  text = "cat bat rat cat"
  matches = re.findall("cat", text)

  print(matches)  # ['cat', 'cat']
  ```

- **Match at Beginning** ‚Äì Check pattern only at start of string

  ```py
  import re

  text = "Python is powerful"
  result = re.match("Python", text)

  print(bool(result))  # True
  ```

- **Character Classes** ‚Äì Match digits, words, or whitespace

  ```py
  import re

  text = "Order ID: 4598"
  digits = re.findall(r"\d+", text)

  print(digits)  # ['4598']
  ```

- **Wildcard (.)** ‚Äì Match any single character

  ```py
  import re

  text = "cat bat rat"
  matches = re.findall(".at", text)

  print(matches)  # ['cat', 'bat', 'rat']
  ```

- **Repetition (*, +, ?)** ‚Äì Control how many times a pattern repeats

  ```py
  import re

  text = "ha hahaha hahahaha"
  laughs = re.findall(r"ha+", text)

  print(laughs)  # ['ha', 'hahaha', 'hahahaha']
  ```

- **Anchors (^, $)** ‚Äì Match start or end of string

  ```py
  import re

  text = "hello"
  print(bool(re.search("^he", text)))  # True
  print(bool(re.search("lo$", text)))  # True
  ```

- **Replace Text (sub)** ‚Äì Replace matching patterns

  ```py
  import re

  text = "My number is 12345"
  masked = re.sub(r"\d", "*", text)

  print(masked)  # My number is *****
  ```

- **Split String** ‚Äì Split text using regex pattern

  ```py
  import re

  text = "apple,banana;orange"
  parts = re.split(r"[,;]", text)

  print(parts)  # ['apple', 'banana', 'orange']
  ```

- **Common Validation Example (Email)** ‚Äì Simple email format check

  ```py
  import re

  email = "test@example.com"
  pattern = r"^[\w\.-]+@[\w\.-]+\.\w+$"

  print(bool(re.match(pattern, email)))  # True
  ```

- **finditer()** ‚Äì Iterate over all matches with position details

  ```py
  text = '''Cyclone Dumazile was a strong tropical cyclone in
  the South-West Indian Ocean that affected Madagascar
  and R√©union in early March 2018. Dumazile originated
  from a Cyclone low-pressure Dyclone Pyclone area that formed
  near Agal√©ga on 27 February. It became a tropical
  disturbance on 2 March, and was named the next day
  after attaining tropical storm status.
  '''

  match_iteam = re.finditer(pattern, text)
  for match in match_iteam:
      index = match.span()
      print(text[index[0]: index[1]])
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Email Extract Using Regex

  ```py
  text = '''Cyclone Dumazile was a strong tropical cyclone in
  the South-West Indian Ocean that affected Madagascar
  and R√©union in early March 2018. Dumazile originated
  from a Cyclone low-pressure bappy@gmail.com area that formed
  near Agal√©ga on 27 February. It became a tropical
  disturbance on 2 March, and was named the next day
  after attaining tropical storm status. contact to
  contact77@gmail.com and alex.gray@amazon.co.uk
  '''
  pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
  emails = re.findall(pattern, text)
  print(emails)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Organize Files Using Python**

  ```py
  import os
  import shutil

  path = input("Enter the path: ")
  files = os.listdir(path)

  for file in files:
      filename, extension = os.path.splitext(file)
      extension = extension[1:]
      if os.path.exists(path+"/"+extension):
          shutil.move(path+"/"+file, path+"/"+extension+"/"+file)
      else:
          os.makedirs(path+"/"+extension)
          shutil.move(path+"/"+file, path+"/"+extension+"/"+file)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 15 - Introduction to OOP**

## **The Robot Problem**

- Using function

  ```py
  # Robot 1
  def movement_1():
    print("Its Robot 1")
  def fire_detection_1():
    print("Its Robot 1")
  def wheel_control_1():
    print("Its Robot 1")

  ## Robot 2
  def movement_2():
    print("Its Robot 2")
  def fire_detection_2():
    print("Its Robot 2")
  def wheel_control_2():
    print("Its Robot 2")

  movement_1()
  movement_2()
  ```

- Solution using OOP

  ```py
  # using OOP

  class Robot:

    def __init__(self, robot_number):
      self.robot_number = robot_number

    def movement(self):
      print(f"Its Robot {self.robot_number}")


    def fire_detection(self):
      print(f"Its Robot {self.robot_number}")

    def wheel_controll(self):
      print(f"Its Robot {self.robot_number}")


    def ai_intelligence(self):
      print(f"Its Robot {self.robot_number}")

  # Robot 1
  robot1 = Robot(robot_number = 1)
  robot1.movement()

  # Robot 2
  robot2 = Robot(robot_number = 2)
  robot2.movement()
  ```

- In OOP `__init__` function is contructor. In construction data properties are defined
- And methods are called functional properties

[‚¨ÜÔ∏è Go to Context](#context)

### Class & Object

- **Class** - Blueprint for creating objects

  ```py
  class Person:
      pass
  ```

- **Object** - Instance of a class

  ```py
  p = Person()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Constructor (`__init__`)

- **Basic Constructor**

  ```py
  class Person:
      def __init__(self):
          print("Object created")

  p = Person()
  ```

- **Constructor with Parameters**

  ```py
  class Person:
      def __init__(self, name, age):
          self.name = name
          self.age = age

  p = Person("Rahim", 20)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### `self` Keyword

- Refers to the **current object**

  ```py
  class Student:
      def __init__(self, name):
          self.name = name

  s = Student("Ayesha")
  print(s.name)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Instance Variables

- Variables unique to each object

  ```py
  class User:
      def __init__(self, username):
          self.username = username

  u1 = User("admin")
  u2 = User("guest")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Class Variables

- Shared among all objects

  ```py
  class Company:
      name = "Google"

  c1 = Company()
  c2 = Company()
  print(c1.name)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Instance Methods

- Methods that work with object data

  ```py
  class Car:
      def start(self):
          print("Car started")

  c = Car()
  c.start()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Class vs Object**

[‚¨ÜÔ∏è Go to Context](#context)

### Class

- A class is a **blueprint / template**
- It defines **properties (variables)** - and **behaviors (methods)**

- **Purpose**
  - Used to create multiple objects
  - Does not occupy memory until object is created

- **Example**

  ```py
  class Car:
      def start(self):
          print("Car started")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Object

- An object is a **real instance*- of a class
- Created from a class

- **Purpose**
  - Used to access class variables and methods
  - Occupies memory

- **Example**

  ```py
  c1 = Car()
  c1.start()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Key Differences in Class and Object

- **Blueprint vs Real Thing**

  - Class ‚Üí Design of a house
  - Object ‚Üí Actual house built from the design

- **Memory**

  - Class ‚Üí No memory allocation
  - Object ‚Üí Memory allocated

- **Creation**

  - Class ‚Üí Created using `class` keyword
  - Object ‚Üí Created using `ClassName()`

- **Quantity**

  - Class ‚Üí One
  - Object ‚Üí Can be many

[‚¨ÜÔ∏è Go to Context](#context)

### Multiple Objects from One Class

- **Same class, different objects**

  ```py
  class Student:
      def __init__(self, name):
          self.name = name

  s1 = Student("Rahim")
  s2 = Student("Karim")
  ```

- Class ‚Üí Logical entity
- Object ‚Üí Physical entity
- Class ‚Üí Defines methods
- Object ‚Üí Uses methods
- Class creates objects
- Objects use class features

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 16 - Writing our first Class in OOP**

## **ATM Machine Using OOP**

  ```py
  class AtmMachine:
    # constructor (special function) --> super power
    def __init__(self):
      self.pin = ""
      self.balance = 0
      self.menu()

    def menu(self):
      user_input = input(
              """
              Hi how can i help you?

              1. Press 1 to create pin
              2. Press 2 to change pin
              3. Press 3 to check balence
              4. Press 4 to withdraw
              5. Anything to exit
              """
          )

      if user_input == "1":
        # create a pin
        self.create_pin()
      elif user_input == "2":
        # change pin
        self.change_pin()
      elif user_input == "3":
        # check balence
        self.check_balance()
      elif user_input == "4":
        # withdraw
        self.withraw_balance()
      else:
        exit()

    def create_pin(self):
      user_pin = input("Enter your pin: ")
      self.pin = user_pin

      user_balance = float(input("Enter your balance: "))
      self.balance = user_balance

      print("Pin Created Successfully!")

      self.menu()

    def change_pin(self):
      old_pin = input("Enter your old pin: ")
      if old_pin == self.pin:
        new_pin = input("Enter your new pin: ")
        self.pin = new_pin
        print("Pin changed successfully!")
        self.menu()
      else:
        print("Incorrect pin!")
        self.menu()

    def check_balance(self):
      user_pin = input("Enter your pin: ")
      if user_pin == self.pin:
        print("Your balance is: ", self.balance)

      else:
        print("Your pin is incorrect, please try again!")

      self.menu()

    def withraw_balance(self):
      user_pin = input("Enter your pin: ")
      if user_pin == self.pin:
        amount = float(input("Enter the amount to withdraw: "))
        if amount <= self.balance:
          self.balance -= amount
          print(f"You have withdrawn {amount}. Your new balance is {self.balance}")
        else:
          print("Insufficient balance!")
      else:
        print("Your pin is incorrect, please try again!")

      self.menu()

  atm = AtmMachine()

  # Similarly more object can be created
  islamibank = AtmMachine()
  primebank = AtmMachine()
  citybank = AtmMachine()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 17 - Self & Encapsulation in OOP**

## **Magic Method/Dunder Method**

- Special methods with double underscore: `__method__`
- Automatically called by Python
- Used to control class behavior
- **Common Magic Methods**

  ```py
  class Test:
      def __init__(self):
          print("Object created")

      def __str__(self):
          return "Test Object"

  t = Test()
  print(t)
  ```

- **Usecase**

  - Object creation ‚Üí `__init__`
  - Object printing ‚Üí `__str__`
  - Object deletion ‚Üí `__del__`

[‚¨ÜÔ∏è Go to Context](#context)

## **Concept of **self** keyword in OOP**

- `self` refers to the **current object**
- Used to access object variables and methods
- **Why `self` is needed**
  - To differentiate object data from local variables

  ```py
  class Person:
      def set_name(self, name):
          self.name = name

  p = Person()
  p.set_name("Rahim")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **How objects access attributes in OOP**

- **Using dot (`.`) operator**

  ```py
  class Student:
      def __init__(self):
          self.name = "Ayesha"

  s = Student()
  print(s.name)
  ```

- **Access order**
  - Object ‚Üí Instance variables
  - Class ‚Üí Class variables

[‚¨ÜÔ∏è Go to Context](#context)

## **Reference Variable in OOP**

- Variable that points to an object in memory
- Object can have multiple reference variables

  ```py
  class Demo:
      pass

  a = Demo()
  b = a   # both refer to same object
  ```

- **Key point**

  - Object is not copied
  - Only reference is shared

[‚¨ÜÔ∏è Go to Context](#context)

## **Pass by reference**

- Python passes **object references**
- Changes inside function affect original object (if mutable)

  ```py
  def update(lst):
      lst.append(4)

  nums = [1, 2, 3]
  update(nums)
  print(nums)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Mutability of object in OOP**

- Can be changed after creation
- List, Dictionary, Set, Class Objects

  ```py
  lst = [1, 2]
  lst.append(3)
  ```

- **Immutable Objects**
  - Cannot be changed
  - int, float, string, tuple

  ```py
  x = 10
  x = 20
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **What is instance variable**

- Variable that belongs to an **object**
- Different for each object
- **Created inside constructor**

  ```py
  class User:
      def __init__(self, name):
          self.name = name

  u1 = User("Admin")
  u2 = User("Guest")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Encapsulation in OOP**

- Wrapping data and methods together
- Protecting data from direct access

[‚¨ÜÔ∏è Go to Context](#context)

### Types of Access Control

- **Public Variable**

  ```py
  self.name = "Rahim"
  ```

- **Protected Variable**- (`_var`)
  - Should not be accessed directly (by convention)

  ```py
  self._email = "test@mail.com"
  ```

- **Private Variable**- (`__var`)
  - Cannot be accessed directly outside class

  ```py
  self.__password = "1234"
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Getter & Setter (Encapsulation Tool)

- **Safe access to private data**

  ```py
  class Account:
      def __init__(self):
          self.__balance = 0

      def get_balance(self):
          return self.__balance

      def set_balance(self, amount):
          self.__balance = amount
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Name Mangling (Private Variable Internals)

- **How Python stores private variables**

  ```py
  print(account._Account__balance)
  ```

- **Why**
  - Prevent accidental access
  - Not true security, but protection
- **Encapsulation Benefits**
  - Data protection
  - Controlled access
  - Easier maintenance
  - Better code structure
- **Summary**
  - `self` ‚Üí current object
  - Dunder methods ‚Üí automatic behavior
  - Reference variable ‚Üí points to object
  - Mutable ‚Üí changeable
  - Instance variable ‚Üí object-specific
  - Encapsulation ‚Üí data protection

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 18 - Inheritance in OOP**

## **Collection Of Class Objects**

A collection of class objects allows you to manage multiple instances of the same class (or related classes) as a single unit. This is fundamental for modeling groups of real-world entities.

- **Homogeneous Collection:** Typically, the collection holds objects of the same class type (e.g., a list of `Employee` objects).
- **Iteration:** You can easily loop through the collection to access and process the data/methods of each individual object.
- **Encapsulation:** While the collection manages the group, each object maintains its own unique state (attributes).

**Python Example (Using a List):**

  ```py
  class Person:

    def __init__(self, name, country):
      self.name = name
      self.country = country

  p1 = Person("Bappy", "UK")
  p2 = Person("Alex", "USA")
  p3 = Person("Ahmed", "india")

  L = [p1, p2, p3]
  print(L)

  for i in L:
    print(i.name, i.country)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Static Variable in OOP**

A static variable (also commonly called a **class variable** in languages like Python) is a variable that is shared across all instances (objects) of a class. Unlike instance variables, which are unique to each object, the static variable maintains a single, persistent copy in memory for the entire class.

- **Single Copy:** Only one memory location is allocated for the static variable, no matter how many objects you create.
- **Shared State:** Any object can access and modify this single value. A change made by one object is immediately visible to all other objects.
- **Access Method:** It is typically accessed and modified using the **Class Name** directly, rather than through an object instance.
- **Common Use Case:** Counting the total number of objects created, storing a global constant specific to the class (e.g., maximum size), or logging class-wide activity.

  ```py
  class Atm:

    #static variable
    __customer_id = 0

    #constructor(special function) - superpower
    def __init__(self):
      self.pin = ""
      self.balance = 0
      Atm.__customer_id += 1
      print(Atm.__customer_id)
    ...

  obj1 = Atm() # 1
  obj2 = Atm() # 2
  ```

- For safety we define the static as private variable `__customer_id`
- To get value of static we use static method decorator

  ```py
  @staticmethod
  def get_customer_id():
    print(Atm.__customer_id)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Instance vs Static Variable in OOP**

The key difference between an Instance Variable and a Static (or Class) Variable lies in **ownership, memory allocation, and sharing** among the objects of a class.

- **Ownership:** Belongs to the **object** (instance) of the class.
- **Definition:** Declared inside the class, typically within the constructor (`__init__` in Python) and associated with the `self` or `this` keyword.
- **Memory:** A **separate copy** of the variable is created in **Heap Memory** for **every object** created from the class.
- **Sharing:** They are **not shared**. Changes made to an instance variable in one object do not affect the value in any other object.
- **Purpose:** To store data that is unique and specific to each instance (e.g., an employee's name, a car's color).
- **Access:** Accessed using the object reference (e.g., `object_name.instance_var`).

| Feature         | Instance Variable                                            | Static Variable (Class Variable)                                |
| :-------------- | :----------------------------------------------------------- | :-------------------------------------------------------------- |
| **Ownership**   | Belongs to the **object (instance)**.                        | Belongs to the **class**.                                       |
| **Memory**      | A **separate copy** for every object (in Heap Memory).       | **One single copy** shared by all objects (at the class level). |
| **Declaration** | Inside the class, typically in the constructor (`__init__`). | Inside the class, but outside all methods.                      |
| **Access**      | Requires an object reference (`obj.instance_var`).           | Accessed via the class name (`Class.static_var`).               |
| **Uniqueness**  | **Unique** value for each object.                            | **Same** shared value for all objects.                          |
| **Lifetime**    | Exists as long as the object exists.                         | Exists as long as the class is loaded (program lifetime).       |

[‚¨ÜÔ∏è Go to Context](#context)

## **Aggregation**

- Non-private attribute
- Non-private methods
- Aggregation method is deprecated currently used `Inheritance`

  ```py
  class Customer:
      def __init__(self,name,gender,address):
          self.name = name
          self.gender = gender
          self.address = address

      def print_info(self):
          print(f"Name: {self.name}, Gender: {self.gender}, Address: {self.address.city}, {self.address.pin}, {self.address.state}")



  class Address:
      def __init__(self, city, pin, state):
          self.city = city
          self.pin = pin
          self.state = state

  adds = Address("Dhaka", 1230, "Bangladesh")
  cus = Customer("Bappy", "Male",adds)
  cus.print_info()
  ```

- Aggregation Diagram

  ![aggregation diagram](https://i.imgur.com/Pz1o1SY.png)

[‚¨ÜÔ∏è Go to Context](#context)

## **DRY Principle**

DRY stands for **"Don't Repeat Yourself."** It is a fundamental software development principle that aims to reduce redundancy and repetition of information, logic, or knowledge within a system.

Every piece of knowledge must have a **single, unambiguous, authoritative representation** within the system.

| Benefit             | Description                                                                                                                                                            |
| :------------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Maintainability** | When a piece of logic needs updating, you only change it in **one central place**, reducing effort and time.                                                           |
| **Fewer Bugs**      | By centralizing logic, you eliminate the risk of introducing inconsistencies or bugs that occur when a fix is applied in one duplicated location but missed in others. |
| **Readability**     | Less repetitive code is shorter, more organized, and easier for other developers (and your future self) to read and understand.                                        |
| **Consistency**     | Ensures that a specific functionality or calculation behaves exactly the same way every time it is used.                                                               |

[‚¨ÜÔ∏è Go to Context](#context)

## **Inheritance**

Inheritance allows us to define a class that inherits all the methods and properties from another class. Parent class is the class being inherited from, also called base class. Child class is the class that inherits from another class, also called derived class.

- Non-private attribute
- Non-private methods

  ```py
  class User: #parent class
    def __init__(self):
      self.name = "Bappy"
      self.gender = "Male"
    def login(self):
      print("Login Done!")
    def register(self):
      print("register Done!")

  class Student(User): #child class
    def __init__(self):
      self.rollno = 12
    def enroll(self):
      print("Enrolled the course!")
    def review(self):
      print("Reviewing the course!")

  class Instructor(User): #child class
    def __init__(self):
      self.idno = 120
    def create(self):
      print("created the course!")
    def reply(self):
      print("Reply to student!")

  s = Student()
  s.enroll()
  s.register()
  s.login()

  I = Instructor()
  I.create()
  I.login()
  I.register()
  ```

- When a child class is instantiated and does not define its own `__init__`, Python automatically and implicitly calls the Parent class's `__init__`.
- When the child class defines its own `__init__`, it **overrides** the parent's `__init__`.
- The `super()` function allows you to explicitly call methods from the parent class, primarily the parent's constructor.

  ```py
  class User: #parent class
    def __init__(self):
      self.name = "Bappy"
      self.gender = "Male"
    def login(self):
      print("Login Done!")
    def register(self):
      print("register Done!")

  class Student(User): #child class
    def __init__(self):
      self.rollno = 12
    def enroll(self):
      print("Enrolled the course!")

  s = Student()
  s.name # error as child has constructor `self.rollno = 12`
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 19 - Polymorphism, Abstraction & Modular Coding**

## **Types of Inheritance**

### Single Inheritance

- One child inherits from **one parent**.

  ```py
  class Parent:
      def show(self):
          print("Parent class")

  class Child(Parent):
      pass

  obj = Child()
  obj.show()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Multilevel Inheritance

- A class inherits from a class that already inherits from another class.

  ```py
  class A:
      def a(self):
          print("A")

  class B(A):
      def b(self):
          print("B")

  class C(B):
      def c(self):
          print("C")

  obj = C()
  obj.a()
  obj.b()
  obj.c()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Multiple Inheritance

- A class inherits from **more than one parent class**.

  ```py
  class Father:
      def skill(self):
          print("Driving")

  class Mother:
      def talent(self):
          print("Cooking")

  class Child(Father, Mother):
      pass

  obj = Child()
  obj.skill()
  obj.talent()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Hierarchical Inheritance

- Multiple child classes inherit from **one parent**.

  ```py
  class Animal:
      def sound(self):
          print("Animal sound")

  class Dog(Animal):
      pass

  class Cat(Animal):
      pass

  Dog().sound()
  Cat().sound()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Hybrid Inheritance

- Combination of **two or more** inheritance types.

  ```py
  class A:
      def a(self):
          print("A")

  class B(A):
      def b(self):
          print("B")

  class C(A):
      def c(self):
          print("C")

  class D(B, C):
      def d(self):
          print("D")

  obj = D()
  obj.a()
  obj.b()
  obj.c()
  obj.d()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Diamond Problem (Special Case)

- Occurs in multiple inheritance when a class inherits from two classes that share a common parent.

  ```py
  class A:
      def show(self):
          print("A")

  class B(A):
      def show(self):
          print("B")

  class C(A):
      def show(self):
          print("C")

  class D(B, C):
      pass

  obj = D()
  obj.show()
  print(D.mro())
  ```

> [!NOTE]
>
> - Single        ‚Üí One parent, one child
> - Multilevel    ‚Üí Parent ‚Üí Child ‚Üí Grandchild
> - Multiple      ‚Üí Multiple parents, one child
> - Hierarchical  ‚Üí One parent, multiple children
> - Hybrid        ‚Üí Combination of inheritance types

[‚¨ÜÔ∏è Go to Context](#context)

## **Method Overriding**

- Method overriding happens when a child class provides its own implementation of a method that already exists in the parent class
  - It allows a child class to change or extend the behavior of a parent class method while keeping the same method name.
  - A feature of inheritance
  - Same method name
  - Same parameters
  - Defined in parent and child class
  - Child method replaces parent method behavior
- When we inherite the parant class the child class also need those argument when child class object is created

  ```py
  class Phone:
    def __init__(self, price, brand, camera):
      print("Inside Phone constructor")
      self.__price = price
      self.brand = brand
      self.camera = camera

    def get_price(self):
      return self.__price

    def buy(self):
      print("Buying a Phone inside Phone constructor")

  class SmartPhone(Phone):
    def buy(self):
      print("Buying a Phone inside SmartPhone constructor")

  S  = SmartPhone(200000, "apple", 3) # output: Inside Phone constructor
  S.buy() # overriding parent buy() output: Buying a Phone inside SmartPhone constructor
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Super Keyword in OOP**

- `super()` allows a child class to safely access parent class methods and constructors, especially powerful in multiple inheritance.
  - Built-in function in Python
  - Refers to the parent (super) class
  - Used inside child class
  - Commonly used in method overriding

  ```py
  class Parent:
      def show(self):
          print("This is Parent class")

  class Child(Parent):
      def show(self):
          super().show()   # call parent method
          print("This is Child class")

  obj = Child()
  obj.show()
  ```

- Accessing parent constructor properties

  ```py
  class Person:
      def __init__(self, name):
          self.name = name

  class Student(Person):
      def __init__(self, name, roll):
          super().__init__(name)   # call parent constructor
          self.roll = roll

  s = Student("Rahim", 101)
  print(s.name, s.roll)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Multilevel Inheritance**

- Inheritance allows one class to acquire properties and methods from another class. In multilevel inheritance, a class is derived from a class that is already derived from another class.
  - Involves more than two classes
  - Each class inherits from the previous class
  - Forms a hierarchy
  - Common in real-world modeling

  ```py
  class GrandParent:
      def house(self):
          print("Owns a house")

  class Parent(GrandParent):
      def car(self):
          print("Owns a car")

  class Child(Parent):
      def bike(self):
          print("Owns a bike")

  c = Child()
  c.house()
  c.car()
  c.bike()
  ```

  ```py
  class Device:
      def power_on(self):
          print("Device powered on")

  class Mobile(Device):
      def call(self):
          print("Calling...")

  class SmartPhone(Mobile):
      def internet(self):
          print("Browsing internet")

  phone = SmartPhone()
  phone.power_on()
  phone.call()
  phone.internet()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Polymorphism**

- In Object-Oriented Programming, different objects may need to respond to the same method name in different ways.
  - One interface, many forms
  - Same method name, different behavior
  - Achieved at runtime in Python
  - Strongly linked with inheritance

  ```py
  class Animal:
      def speak(self):
          print("Animal makes a sound")

  class Dog(Animal):
      def speak(self):
          print("Dog barks")

  class Cat(Animal):
      def speak(self):
          print("Cat meows")

  animals = [Dog(), Cat()]

  for a in animals:
      a.speak()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Abstraction**

- In large systems, exposing all internal details makes code complex and hard to maintain.
  - Hides internal implementation
  - Shows essential features only
  - Focuses on what an object does, not how
  - Achieved using abstract classes & interfaces (conceptually)

  ```py
  from abc import ABC, abstractmethod

  class Payment(ABC):
      @abstractmethod
      def pay(self):
          pass

  class Bkash(Payment):
      def pay(self):
          print("Payment using bKash")

  class Card(Payment):
      def pay(self):
          print("Payment using Card")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Modular Coding**

- Breaking a large program into smaller modules
- Each module is a separate file
- Modules can contain functions, classes, or variables
- Modules are imported where needed
- Improves readability
- Easier maintenance
- Encourages reuse
- Simplifies testing
- Supports team collaboration
- Example
  - `calculator.py` file content

    ```py
    # calculator.py
    def add(a, b):
        return a + b

    def sub(a, b):
        return a - b
    ```

  - Using `calculator.py` function in `main.py`

    ```py
    # main.py
    import calculator

    print(calculator.add(10, 5))
    print(calculator.sub(10, 5))
    ```

- Project structure of [ATM Machine](./Day%2019%20-%20Polymorphism,%20Abstraction%20&%20Modular%20Coding/atm_project/)

  ```txt
  atm_project
  ‚îú‚îÄ‚îÄ üìÅ core
  ‚îÇ   ‚îú‚îÄ‚îÄ üêç __init__.py
  ‚îÇ   ‚îú‚îÄ‚îÄ üêç auth.py
  ‚îÇ   ‚îú‚îÄ‚îÄ üêç database.py
  ‚îÇ   ‚îî‚îÄ‚îÄ üêç transactions.py
  ‚îú‚îÄ‚îÄ üìù README.md
  ‚îî‚îÄ‚îÄ üêç main.py
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 20 - Mega OOP Project**

## Gemini CLI Text Analyzer (NLP)

A simple **Python command-line application*- that uses **Google Gemini (Generative AI)*- to perform basic NLP tasks like sentiment analysis, language translation, and language detection.

The app also includes a **basic in-memory user registration and login system**.

- Features
  - User Registration & Login (in-memory)
  - Sentiment Analysis
  - Language Translation (English ‚Üí Bangla)
  - Language Detection
  - Uses Google Gemini API (`gemini-2.5-flash`)
  - Environment variable support using `python-dotenv`

- Tech Stack
  - Python
  - google-generativeai (Gemini)
  - python-dotenv

- Project Structure
  - `BaseModel`
    - Handles Gemini API configuration
    - Returns the AI model instance
  - `AppFeatures`
    - User authentication (register/login)
    - Menu-based CLI navigation
    - NLP features using Gemini

- Requirements
  - Python 3.9+
  - Google Gemini API Key

- Installation

  ```sh
  pip install google-generativeai python-dotenv
  ```

- Environment Setup

  - Create a `.env` file in the root directory and add:

  ```env
  GEMINI_API_KEY=your_api_key_here
  ```

- Run The App

  ```sh
  python app.py
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 21 - Decorator, Iterators & Generator**

## **Namespaces**

- A **mapping of names to objects**
- Prevents naming conflicts
- Determines **where** a name is accessible

  ```py
  x = 10
  ```

Here, `x` exists in a namespace.

[‚¨ÜÔ∏è Go to Context](#context)

### Types of Namespaces in Python

#### 1. Built-in Namespace

- Contains built-in functions and keywords
- Available everywhere

Examples:

```py
print()
len()
int()
```

[‚¨ÜÔ∏è Go to Context](#context)

#### 2. Global Namespace

- Created when a module is loaded
- Names defined at the top level of a file

  ```py
  x = 100   # global namespace

  def show():
      pass
  ```

[‚¨ÜÔ∏è Go to Context](#context)

#### 3. Local Namespace

- Created when a function is called
- Exists only inside that function

  ```py
  def demo():
      y = 50   # local namespace
      print(y)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Namespace Lifetime

- Built-in ‚Üí Exists until interpreter exits
- Global   ‚Üí Exists until module execution ends
- Local    ‚Üí Exists during function call

[‚¨ÜÔ∏è Go to Context](#context)

### LEGB Rule (Name Resolution Order)

- L ‚Üí Local
- E ‚Üí Enclosing (nested functions)
- G ‚Üí Global
- B ‚Üí Built-in

  ```py
  x = "global"

  def outer():
      x = "enclosing"
      def inner():
          x = "local"
          print(x)
      inner()

  outer()
  ```

- **Output**

  ```txt
  local
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Global Keyword

  ```py
  x = 10

  def change():
      global x
      x = 20

  change()
  print(x)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Nonlocal Keyword

  ```py
  def outer():
      x = 5
      def inner():
          nonlocal x
          x = 10
      inner()
      print(x)

  outer()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Checking Namespaces

  ```py
  print(globals())
  print(locals())
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Namespace vs Scope

- Namespace ‚Üí Where names are stored
- Scope     ‚Üí Where names are accessible

[‚¨ÜÔ∏è Go to Context](#context)

## **Decorator**

- A **function that modifies another function**
- Uses the `@decorator_name` syntax
- Works because **functions are first-class objects**
- Commonly used for logging, authentication, timing, caching
- Code reusability
- Cleaner function logic
- Separation of concerns
- Easy to apply/remove behavior

- Basic Decorator Example

  ```py
  def my_decorator(func):
      def wrapper():
          print("Before function call")
          func()
          print("After function call")
      return wrapper

  @my_decorator
  def say_hello():
      print("Hello!")

  say_hello()
  ```

- **Output**

  ```txt
  Before function call
  Hello!
  After function call
  ```

- Decorator Without `@` Syntax

  ```py
  def say_hi():
      print("Hi")

  say_hi = my_decorator(say_hi)
  say_hi()
  ```

- Decorator with Arguments

  ```py
  def my_decorator(func):
      def wrapper(*args, **kwargs):
          print("Before function")
          return func(*args, **kwargs)
      return wrapper

  @my_decorator
  def add(a, b):
      return a + b

  print(add(2, 3))
  ```

- Using `functools.wraps` (Best Practice)

  ```py
  from functools import wraps

  def my_decorator(func):
      @wraps(func)
      def wrapper(*args, **kwargs):
          return func(*args, **kwargs)
      return wrapper
  ```

- Preserves function name and docstring
- Important for debugging and documentation

- Authentication using Decorator

  ```py
  def login_required(func):
      def wrapper(user):
          if not user:
              print("Login required")
              return
          return func(user)
      return wrapper

  @login_required
  def dashboard(user):
      print("Welcome to dashboard")

  dashboard(None)
  dashboard("Admin")
  ```

- Decorators with Parameters

  ```py
  def repeat(n):
      def decorator(func):
          def wrapper(*args, **kwargs):
              for _ in range(n):
                  func(*args, **kwargs)
          return wrapper
      return decorator

  @repeat(3)
  def greet():
      print("Hello")

  greet()
  ```

- Class-Based Decorator

  ```py
  class MyDecorator:
      def __init__(self, func):
          self.func = func

      def __call__(self):
          print("Before call")
          self.func()
          print("After call")

  @MyDecorator
  def hello():
      print("Hello")

  hello()
  ```

- Common Built-in Decorators

  ```py
  @staticmethod
  @classmethod
  @property
  ```

- Example

  ```py
  class Demo:
      @staticmethod
      def show():
          print("Static method")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Iterators**

- **Iteration**: Iteration is a general term for taking each item of something, one after another. Any time you use a loop, explicit or implicit, to go over a group of items, that is iteration.

  ```py
  num = [1,2,3]

  for i in num:
    print(i)
  ```

- **Iterator**: An Iterator is an object that allows the programmer to traverse through a sequence of data without having to store the entire data in the memory. It produce values one at a time during iteration and remember their current state.

  ```py
  nums = [1, 2, 3]
  it = iter(nums)

  print(next(it))
  print(next(it))
  print(next(it))
  ```

- **Iterables**: Iterables are objects that can be looped over and provide an iterator when passed to the iter() function.
  - `list`
  - `tuple`
  - `set`
  - `string`
  - `dictionary`
  - `range`

- Iterable vs Iterator
  - Iterable
    - Can be iterated over
    - Returns a new iterator
    - Has `__iter__()`
    - Example: `list`, `tuple`, `string`
  - Iterator
    - Produces values
    - Remembers state
    - Has `__iter__()` and `__next__()`
    - Example: `iter(list)`

> [!NOTE]
>
> - Iterable ‚Üí Object you can loop over (list, tuple, set, string)
> - Iterator ‚Üí Object that produces values using `__next__()`

[‚¨ÜÔ∏è Go to Context](#context)

## **Generators**

- A **generator** is a function that:
  - Returns an iterator
  - Uses `yield` instead of `return`
  - It **pauses execution**, remembers state, and resumes later
- Generators are a way to create **iterators** easily
- It allow us to **produce values one at a time**, instead of storing everything in memory
- Especially useful for:
  - Large data processing
  - Streams
  - Infinite sequences
  - Performance-critical code

  ```py
  def count_up():
      yield 1
      yield 2
      yield 3
  ```

- Calling the function does **not** run it immediately

  ```py
  g = count_up()
  ```

- Values are produced only when requested

  ```py
  print(next(g))  # 1
  print(next(g))  # 2
  print(next(g))  # 3
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Generator vs Normal Function

- Normal Function

  ```py
  def get_numbers():
      return [1, 2, 3]
  ```

- Executes fully
- Returns all values at once
- Uses memory to store everything

- Generator Function

  ```py
  def get_numbers():
      yield 1
      yield 2
      yield 3
  ```

- Executes lazily
- Produces values one by one
- Very memory efficient

[‚¨ÜÔ∏è Go to Context](#context)

### `yield` Keyword Explained

- `yield`:

  - Sends a value to the caller
  - Pauses the function
  - Saves local variables & execution state

- Execution Flow

  ```py
  def demo():
      print("Start")
      yield 1
      print("Middle")
      yield 2
      print("End")
  ```

- Calling step-by-step

  ```py
  g = demo()
  next(g)  # prints "Start", returns 1
  next(g)  # prints "Middle", returns 2
  next(g)  # prints "End", StopIteration raised
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Generator is an Iterator

- Generators:

  - Implement `__iter__()`
  - Implement `__next__()`
- Can be used in loops directly

  ```py
  for value in count_up():
      print(value)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Generator Expression

- Produces values lazily
- Uses far less memory
- Similar to list comprehensions
- Use `()` instead of `[]`

  ```py
  nums = (x * 2 for x in range(5))
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### `yield` vs `return`

- `return`
  - Ends function execution
- `yield`
  - Pauses function
  - Can be used multiple times

  ```py
  def test():
      yield 1
      return
      yield 2  # never runs
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Where To Use Generators

- Data is large
- Don‚Äôt need random access
- Avoid generators when need to reuse values multiple times
- Prefer generator expressions for simple transformations
- Always close resources properly

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 22 - User Interface (UI) Creation**

## **Design simple UI**

- Official docs: [Streamlit Fundamentals](https://docs.streamlit.io/get-started/fundamentals/main-concepts)
- Transform CLI interface of [Day 20 - Mega OOP Project](./Day%2020%20-%20Mega%20OOP%20Project/) to [Day 22 - User Interface (UI) Creation](./Day%2022%20-%20User%20Interface%20(UI)%20Creation/) GUI interface
- To save data locally `st.session_state` is used
- Full code can be found in [Day 22 - User Interface (UI) Creation/app.py](./Day%2022%20-%20User%20Interface%20(UI)%20Creation/app.py)

[‚¨ÜÔ∏è Go to Context](#context)

# **Assignment 05**

- [Personal AI Project](https://github.com/aatansen/Personal-AI-Assistant/)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 23 - PyPI Package Discussion**

## **PyPI Package**

- **PyPI (Python Package Index)** is the official repository where Python developers publish and share reusable Python packages.
- Website: pypi.org
- Similar idea to
  - npm for JavaScript
  - Maven Central for Java

[‚¨ÜÔ∏è Go to Context](#context)

### What is a Python Package?

- A **package** is a collection of Python modules bundled together.
- Used to:
  - Reuse code
  - Avoid writing everything from scratch
  - Share solutions with others
- Examples:
  - requests ‚Üí HTTP requests
  - numpy ‚Üí numerical computing
  - django ‚Üí web framework

[‚¨ÜÔ∏è Go to Context](#context)

### Package Manager: `pip`

- `pip` is the tool used to install packages from PyPI.

- Common commands:
  - `pip install package_name`
  - `pip uninstall package_name`
  - `pip list`
  - `pip show package_name`
  - `pip install --upgrade package_name`

[‚¨ÜÔ∏è Go to Context](#context)

### Requirements File

- Used to manage dependencies `requirements.txt`

  ```txt
  django==4.2.3
  requests>=2.28
  numpy
  ```

- Installation
  - `pip install -r requirements.txt`

[‚¨ÜÔ∏è Go to Context](#context)

### Virtual Environments

- Isolate project dependencies.
- Prevent version conflicts.
  - `python -m venv venv`
  - `venv\Scripts\activate`

[‚¨ÜÔ∏è Go to Context](#context)

### How a Package is Structured

- Basic structure:

  ```txt
  mypackage/
    ‚îú‚îÄ‚îÄ mypackage/
    ‚îÇ    ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ    ‚îî‚îÄ‚îÄ core.py
    ‚îú‚îÄ‚îÄ setup.py / pyproject.toml
    ‚îú‚îÄ‚îÄ README.md
    ‚îî‚îÄ‚îÄ LICENSE
  ```

[‚¨ÜÔ∏è Go to Context](#context)

### Publishing a Package to PyPI

- Create account on PyPI
- Prepare package metadata
- Build distribution
- Upload using `twine`
- Modern tools
  - `setuptools`
  - `poetry`
  - `flit`

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 24,25 - Publish Package to PyPI**

## **Youtube Notebook Embed Package**

### Day 24 - Project Setup

- Create `.venv`
- Generate project structure by running `template.py`
- Add required packages in `requirements.txt` and `requirements-dev.txt`
- Write `setup.py` and `setup.cfg`
- Now define `pyproject.toml`
- Install `requirements-dev.txt`
- Define `logger.py` and `custom_exception.py` inside `src/ytnb-embed` path
- Write test run in `tox.ini` and create `tests/integration/test_int.py` & `tests/unit/test_unit.py` files
- Now to integrate CI/CD create `.github/workflows/ci.yml` for CI integration
- Push to github to see the github action running

[‚¨ÜÔ∏è Go to Context](#context)

### Day 25 - Publish to PyPI

- Add youtube embed functionality in `src/ytnb_embed/youtube.py`
- Now create [PyPI account](https://pypi.org/account/register/)
- Get API
- Setup secrete in Github Action secrete
  - [https://github.com/USER_NAME/REPO_NAME/settings/secrets/actions](https://github.com/USER_NAME/REPO_NAME/settings/secrets/actions)
  - Add `PYPI_API_TOKEN` in New repository secret
- Now in every push it will test using `tox` and in every release it will release it to the `PyPI`

> [!NOTE]
>
> - Final Project Repository --> [ytnb-embed](https://github.com/aatansen/ytnb-embed)

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 26 - MongoDB with Python**

## **SQL vs NoSQL**

| Feature      | SQL           | NoSQL               |
| ------------ | ------------- | ------------------- |
| Definition   | Relational DB | Non-relational DB   |
| Schema       | Fixed         | Flexible            |
| Scaling      | Vertical      | Horizontal          |
| Consistency  | Strong        | Eventual            |
| Transactions | ACID          | BASE                |
| Data Type    | Structured    | Semi / Unstructured |

- **SQL (Structured Query Language Databases)**

  - Databases based on the **relational model**
  - Data is stored in **tables with predefined schema**
  - Uses SQL to create, read, update, and delete data
  - Schema is fixed and predefined
  - Relationships supported using joins & foreign keys
  - **Best Use Cases**
    - Financial systems
    - Inventory management
    - Enterprise applications
  - **Examples**
    - MySQL
    - PostgreSQL
    - SQLite
    - Oracle

- **NoSQL (Not Only SQL Databases)**

  - Databases designed for **non-relational or flexible data models**
  - Data is stored in formats like **documents, key-value pairs, columns, or graphs**
  - Optimized for **scalability, performance, and flexible schemas**
  - Key-Value, Document, Column, Graph
  - Semi-structured or unstructured
  - Schema is dynamic / schema-less
  - Relationships managed at application level
  - **Best Use Cases**
    - Big data systems
    - Content management
    - Real-time applications
  - **Examples**
    - MongoDB
    - Redis
    - Cassandra
    - DynamoDB
    - Neo4j

[‚¨ÜÔ∏è Go to Context](#context)

## **MongoDB Diagram**

```mermaid
flowchart TD
    %% User Setup Phase
    subgraph Setup ["1. Provisioning & Security"]
        A[User / Developer] --> B(MongoDB Atlas Portal)
        B --> C{Account Access}
        C --> D[Create Project]
        D --> E[Configure Cluster]

        subgraph Config ["Cluster Specs"]
            E --> E1[Cloud: AWS/GCP/Azure]
            E --> E2[Region Selection]
            E --> E3[Tier: Free vs Dedicated]
        end

        E3 --> F[Security Layer]
        subgraph Security ["Access Control"]
            F --> F1[IP Access List]
            F --> F2[Database Users/Roles]
        end
    end

    %% Connection Phase
    F2 --> G[Cluster Provisioned]
    G --> H{Connection Methods}

    subgraph Connectivity ["2. Connection & Schema"]
        H --> H1[App Drivers: Node/Python/Go]
        H --> H2[Compass / Shell]
        H1 & H2 --> I[(Database & Collections)]
    end

    %% Engine & Data Processing
    I --> J[Data Operations: CRUD]

    subgraph Engine ["3. Core Engine & Storage"]
        J --> K[WiredTiger Storage Engine]
        subgraph Performance ["Efficiency"]
            K --> K1[Indexing]
            K --> K2[Compression]
        end

        K --> L{Availability & Scaling}

        subgraph HighAvailability ["Replica Set"]
            L --> L1[Primary: Writes/Reads]
            L1 -.->|Replication| L2[Secondaries: Reads]
            L2 -.->|Election| L1
        end

        subgraph Scaling ["Sharding"]
            L --> M[Shard Key Partitioning]
            M --> M1[Horizontal Scale-out]
        end
    end

    %% Analysis & Maintenance
    L1 & L2 --> N[Aggregation Pipeline]
    N --> O[App Receives Results]
    O --> P[Monitoring & Backups]

    %% Styling
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style I fill:#00ed64,stroke:#001e2b,color:#001e2b
    style G fill:#00684a,color:#fff
```

- MongoDB Database
  ![segeg](https://i.imgur.com/Y6cXhoT.png)

[‚¨ÜÔ∏è Go to Context](#context)

## **MongoDB Setup And Operations**

- Connection & Setup
  - Create Project
  - Create Cluster
    - Setup Network access (access from anywhere)
  - Connect cluster
    - Select driver (stable python api)
    - Get connection string code `mongodb+srv://...`
  - Create [venv](#create-conda-environment)
  - Install [ipykernel](https://pypi.org/project/ipykernel/), [pandas](https://pypi.org/project/pandas/) and [pymongo](https://pypi.org/project/pymongo/)

  ```py
  from pymongo

  client = pymongo.MongoClient(CONNECTION_URL)      # connect
  db = client["db_name"]                    # select database
  collection = db["collection_name"]        # select collection

  client.list_database_names()              # list DBs
  db.list_collection_names()                # list collections
  client.close()                            # close connection
  ```

- Insert Operations

  ```py
  collection.insert_one(document)           # insert single document
  collection.insert_many(documents)          # insert multiple documents
  collection.count_documents({})             # count all documents
  ```

- Read / Fetch Operations

  ```py
  collection.find()                          # fetch all (cursor)
  collection.find_one()                      # fetch single document
  ```

- Limit & pagination

  ```py
  collection.find().limit(10)
  collection.find().skip(10).limit(10)
  ```

- Sample data instead of full collection

  ```py
  df = pd.DataFrame(
      list(collection.find({}, {"_id": 0}).limit(1000))
  )
  ```

> [!NOTE]
>
> - Without projection `df = pd.DataFrame(list(collection.find().limit(1000)))` will returns `_id` also
> - `{}`              ‚Üí no filter (fetch all documents)
> - `{"_id": 0}`      ‚Üí projection: exclude MongoDB's _id field
> - `limit(1000)`     ‚Üí fetch only 1000 documents
> - `list(...)`       ‚Üí load 1000 docs into memory
> - `DataFrame(...)`  ‚Üí convert to pandas

- Filtering

  ```py
  collection.find({"field": "value"})
  collection.find({"field": {"$gt": 10}})
  collection.find({"field": {"$gte": 10}})
  collection.find({"field": {"$lt": 10}})
  collection.find({"field": {"$lte": 10}})
  collection.find({"field": {"$ne": "value"}})
  collection.find({"field": {"$in": [1, 2, 3]}})
  collection.find({"field": {"$nin": [1, 2, 3]}})
  ```

- Logical operators

  ```py
  collection.find({"$and": [{"a": 1}, {"b": 2}]})
  collection.find({"$or": [{"a": 1}, {"b": 2}]})
  ```

- Projection (Control Output)

  ```py
  collection.find({}, {"_id": 0})
  collection.find({}, {"field1": 1, "field2": 1})
  collection.find({}, {"field": 0})
  ```

- Sorting

  ```py
  collection.find().sort("field", 1)         # ascending
  collection.find().sort("field", -1)        # descending
  ```

- Update Operations

  ```py
  collection.update_one(
      {"field": "value"},
      {"$set": {"field": "new_value"}}
  )

  collection.update_many(
      {"status": "pending"},
      {"$set": {"status": "processed"}}
  )

  collection.update_one(
      {"field": "value"},
      {"$inc": {"count": 1}}
  )

  collection.update_one(
      {"field": "value"},
      {"$unset": {"temp_field": ""}}
  )

  collection.update_one(
      {"field": "value"},
      {"$rename": {"old_name": "new_name"}}
  )
  ```

- Delete Operations

  ```py
  collection.delete_one({"field": "value"})
  collection.delete_many({"status": "obsolete"})
  collection.drop()                          # drop entire collection
  ```

- Indexing (Performance)

  ```py
  collection.create_index("field")
  collection.create_index([("field1", 1), ("field2", -1)])
  collection.index_information()
  collection.drop_index("index_name")
  ```

- Aggregation Pipeline (Core)

  ```py
  pipeline = [
      {"$match": {"field": "value"}},
      {"$group": {"_id": "$category", "count": {"$sum": 1}}},
      {"$sort": {"count": -1}},
      {"$limit": 5}
  ]

  collection.aggregate(pipeline)
  ```

- Cursor Utilities & Safety

  ```py
  cursor = collection.find().limit(10)
  for doc in cursor:
      print(doc)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 27 - MySQL Using Python**

## **Setup MySQL**

- Download [MySQL Installer (v8.0.44)](https://dev.mysql.com/downloads/installer/)
- Open and install it with all default selected option
- Create [venv](#create-conda-environment)
- Install [ipykernel](https://pypi.org/project/ipykernel/), [mysql-connector-python](https://pypi.org/project/mysql-connector-python/) and [pandas](https://pypi.org/project/pandas/)

## **MySQL Diagram**

![mysql_diagram](https://i.imgur.com/A8xC0JY.png)

## **MySQL Operations**

- Connection & Setup

  ```py
  import mysql.connector   # or: import pymysql

  conn = mysql.connector.connect(
      host="HOST",
      user="USER",
      password="PASSWORD",
      database="DB_NAME"
  )

  cursor = conn.cursor(dictionary=True)   # dictionary=True ‚Üí rows as dicts
  conn.is_connected()                      # check connection
  ```

- Create Database

  ```py
  cursor.execute("CREATE DATABASE IF NOT EXISTS db_name")
  cursor.execute("SHOW DATABASES")
  cursor.fetchall()
  ```

- Database & Table Utilities

  ```py
  cursor.execute("SHOW DATABASES")
  cursor.fetchall()

  cursor.execute("SHOW TABLES")
  cursor.fetchall()

  cursor.execute("DESCRIBE table_name")
  cursor.fetchall()
  ```

- Insert Operations

  ```py
  cursor.execute(
      "INSERT INTO table_name (col1, col2) VALUES (%s, %s)",
      (val1, val2)
  )

  cursor.executemany(
      "INSERT INTO table_name (col1, col2) VALUES (%s, %s)",
      data_list
  )

  # Single insert with direct values
  cursor.execute(
      "INSERT INTO StudentDetails VALUES ('1132','Sachin','Kumar','1997-11-11','Eleventh','A')"
  )

  conn.commit()                            # REQUIRED after insert/update/delete
  cursor.rowcount                          # affected rows
  ```

- Insert CSV data to MySQL shown in notebook -> [Day 27 - MySQL Using Python/MySQL.ipynb](./Day%2027%20-%20MySQL%20Using%20Python/MySQL.ipynb)

- Read / Fetch Operations

  ```py
  cursor.execute("SELECT * FROM table_name")
  rows = cursor.fetchall()

  cursor.execute("SELECT * FROM table_name LIMIT 10")
  cursor.fetchall()

  cursor.execute("SELECT * FROM table_name LIMIT 10 OFFSET 10")
  cursor.fetchall()
  ```

- Filtering (WHERE clause)

  ```py
  cursor.execute(
      "SELECT * FROM table_name WHERE status = %s",
      ("Approved",)
  )

  cursor.execute(
      "SELECT * FROM table_name WHERE salary > %s",
      (80000,)
  )

  cursor.execute(
      "SELECT * FROM table_name WHERE year BETWEEN %s AND %s",
      (2020, 2024)
  )
  ```

- Projection (Select columns)

  ```py
  cursor.execute(
      "SELECT col1, col2 FROM table_name"
  )
  cursor.fetchall()
  ```

- Sorting

  ```py
  cursor.execute(
      "SELECT * FROM table_name ORDER BY year ASC"
  )

  cursor.execute(
      "SELECT * FROM table_name ORDER BY salary DESC"
  )
  ```

- Update Operations

  ```py
  cursor.execute(
      "UPDATE table_name SET status = %s WHERE status = %s",
      ("Processed", "Pending")
  )

  cursor.execute(
      "UPDATE table_name SET count = count + 1 WHERE id = %s",
      (1,)
  )

  conn.commit()
  ```

- Delete Operations

  ```py
  # Delete rows from a table
  cursor.execute(
      "DELETE FROM table_name WHERE status = %s",
      ("Obsolete",)
  )

  conn.commit()

  # Delete an entire database by name
  cursor.execute("DROP DATABASE IF EXISTS db_name")
  ```

- Indexing (Performance)

  ```py
  cursor.execute(
      "CREATE INDEX idx_status ON table_name(status)"
  )

  cursor.execute(
      "SHOW INDEX FROM table_name"
  )

  cursor.execute(
      "DROP INDEX idx_status ON table_name"
  )
  ```

- Aggregation / Analytics

  ```py
  cursor.execute(
      """
      SELECT category, COUNT(*) AS count
      FROM table_name
      WHERE status = %s
      GROUP BY category
      ORDER BY count DESC
      LIMIT 5
      """,
      ("Approved",)
  )

  cursor.fetchall()
  ```

- MySQL ‚Üî pandas Bridge

  ```py
  import pandas as pd

  cursor.execute("SELECT * FROM table_name LIMIT 1000")
  df = pd.DataFrame(cursor.fetchall())
  df.head()
  ```

- Cursor & Connection Safety

  ```py
  cursor.fetchone()        # fetch one row
  cursor.fetchall()        # fetch all rows
  cursor.close()           # close cursor
  conn.close()             # close connection
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 28 - Jarvis Using Arduino**

## **JARVIS Smart Home Controller**

- A simple **voice-controlled smart home system** using **Python + Arduino (Serial Communication)**.
The system allows you to control lights, fan, and TV using voice commands processed in Python and sent to Arduino via serial.

[‚¨ÜÔ∏è Go to Conext](#context)

## **Smart Home Features**

- Bedroom light ON / OFF
- Table lamp ON / OFF
- Fan ON / OFF
- TV ON / OFF
- Turn **everything ON**
- Turn **everything OFF**
- Real-time serial communication
- Easy to extend (add more devices or commands)

[‚¨ÜÔ∏è Go to Context](#context)

## **Arduino Jarvis System Diagram**

  ```mermaid
  flowchart LR
      A[User Voice Command] --> B[Microphone]

      B --> C[Python Voice Recognition]
      C --> D[Command Processing Logic]

      D -->|Single Character Command| E[Serial Communication]

      E --> F[Arduino Controller]

      F --> G[Bedroom Light]
      F --> H[Table Lamp]
      F --> I[Fan]
      F --> J[TV]

      subgraph Python Side
          C
          D
          E
      end

      subgraph Arduino Side
          F
      end

      subgraph Devices
          G
          H
          I
          J
      end
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **JARVIS Smart Home Setup and Usage**

- Hardware Requirements
  - Arduino Uno / Nano / Mega
  - Relay Module (4-channel recommended)
  - Lights, Fan, TV (or LEDs for testing)
  - Jumper wires
  - USB cable
- Software Requirements
  - Arduino IDE
  - Python 3.x
  - Python Libraries:
    - `pyserial`
    - `speechrecognition`
    - `pyttsx3`
    - `logging`

- Pin Configuration (Arduino)

  | Device        | Arduino Pin |
  | ------------- | ----------- |
  | Bedroom Light | D2          |
  | Table Lamp    | D3          |
  | Fan           | D4          |
  | TV            | D5          |

- Serial Command Mapping

  | Command | Action              |
  | ------- | ------------------- |
  | `1`     | Bedroom Light ON    |
  | `2`     | Bedroom Light OFF   |
  | `3`     | Table Lamp ON       |
  | `4`     | Table Lamp OFF      |
  | `5`     | Fan ON              |
  | `6`     | Fan OFF             |
  | `7`     | TV ON               |
  | `8`     | TV OFF              |
  | `9`     | Turn ON Everything  |
  | `0`     | Turn OFF Everything |

- Arduino Code
  - Initializes serial communication at **9600 baud**
  - Sets all device pins as `OUTPUT`
  - Listens for serial input
  - Uses `switch-case` to control devices
  - Safe startup (everything OFF)

- Python Voice Command Logic
  - Listens for voice input
  - Matches phrases like:
    - `"turn on fan"`
    - `"turn off tv"`
  - Sends **single-byte commands** to Arduino using `ser.write(b'X')`
  - Uses text-to-speech feedback
  - Logs all user actions

[‚¨ÜÔ∏è Go to Context](#context)

## **How to Run JARVIS Smart Home**

- Arduino
  - Open Arduino IDE
  - Upload the Arduino sketch
  - Note the COM port

- Python

  ```sh
  pip install pyserial speechrecognition pyttsx3
  python main.py
  ```

- Example Voice Commands
  - "Turn on bedroom light"
  - "Turn off table lamp"
  - "Turn on everything"
  - "Turn off fan"
  - "Turn on TV"

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 29 - Flask API**

## **Flask and Postman Setup**

- Create [venv](#create-conda-environment)
- Install [Flask](https://pypi.org/project/Flask/)
- Download and install [Postman](https://www.postman.com/downloads/)

[‚¨ÜÔ∏è Go to Context](#context)

## **Flask Usages**

- Core Usages

  - Building RESTful APIs
  - Creating backend services for web & mobile apps
  - Developing lightweight microservices
  - Backend for small to medium web apps
  - Rapid prototyping & MVPs
  - Internal tools & admin dashboards

- API Development

  - CRUD APIs (Create, Read, Update, Delete)
  - Request handling using decorators & routes
  - Manual or schema-based validation (Marshmallow, Pydantic)
  - JSON request & response handling
  - Blueprint-based API versioning

- Performance & Architecture

  - Synchronous by default (WSGI-based)
  - Async possible via extensions or ASGI wrappers
  - Suitable for low to medium traffic APIs
  - Extremely flexible and minimal
  - Requires more decisions from the developer

- Authentication & Security

  - Session-based authentication
  - JWT authentication (Flask-JWT-Extended)
  - OAuth support (Flask-Login, Flask-OAuthlib)
  - Role-based access control via custom decorators
  - CSRF protection for form-based apps

- Database Integration

  - SQL databases (PostgreSQL, MySQL, SQLite)
  - ORM support (SQLAlchemy, Flask-SQLAlchemy)
  - Migration support (Flask-Migrate)
  - NoSQL databases (MongoDB via PyMongo)
  - Mostly synchronous DB operations

- Documentation & Testing

  - No built-in API docs
  - Swagger/OpenAPI via extensions (Flask-RESTX, Flasgger)
  - Manual schema definition
  - Strong pytest integration
  - Flask test client for unit & integration tests

- Microservices & DevOps

  - Container-friendly (Docker)
  - Easy deployment on AWS, GCP, Azure
  - Commonly used behind Nginx/Gunicorn
  - Works with Kubernetes
  - Requires extra setup for health checks

- Background & Advanced Tasks

  - Background jobs via Celery or RQ
  - Middleware via WSGI
  - Custom error handling
  - App lifecycle hooks
  - Limited native real-time support (WebSockets via extensions)

- Machine Learning & Data APIs

  - Popular for serving ML models
  - Simple inference endpoints
  - Data processing APIs
  - Widely used in research & data science teams
  - Very low learning curve for ML engineers

- When to Use Flask

  - Need full control over architecture
  - Building small to medium APIs
  - Rapid prototyping & experiments
  - ML model serving with minimal overhead
  - Prefer simplicity over automation

- When NOT to Use Flask

  - High-concurrency async workloads
  - Large teams needing strict structure
  - APIs requiring automatic validation & docs
  - Complex microservice ecosystems (FastAPI fits better)

[‚¨ÜÔ∏è Go to Context](#context)

## **Flask Implementation**

- App Setup & Initialization

  ```py
  from flask import Flask

  app = Flask(__name__)

  if __name__ == "__main__":
      app.run(debug=True)
  ```

- Basic Routing

  ```py
  @app.route("/")
  def home():
      return "Hello, Flask!"
  ```

  ```py
  @app.route("/about")
  def about():
      return "About Page"
  ```

- Routing with HTTP Methods

  ```py
  from flask import request

  @app.route("/login", methods=["GET", "POST"])
  def login():
      if request.method == "POST":
          return "POST request"
      return "GET request"
  ```

- URL Parameters (Dynamic Routes)

  ```py
  @app.route("/user/<username>")
  def user_profile(username):
      return f"User: {username}"
  ```

  ```py
  @app.route("/post/<int:post_id>")
  def show_post(post_id):
      return f"Post ID: {post_id}"
  ```

- Query Parameters

  ```py
  @app.route("/search")
  def search():
      keyword = request.args.get("q")
      return f"Search for: {keyword}"
  ```

- JSON Response (API)

  ```py
  from flask import jsonify

  @app.route("/api/status")
  def status():
      return jsonify({
          "status": "ok",
          "service": "flask"
      })
  ```

- Request Data (Form & JSON)

  ```py
  @app.route("/submit", methods=["POST"])
  def submit():
      name = request.form.get("name")
      return f"Name: {name}"
  ```

  ```py
  @app.route("/submit-json", methods=["POST"])
  def submit_json():
      data = request.get_json()
      return jsonify(data)
  ```

- Templates (Jinja2)

  ```py
  from flask import render_template

  @app.route("/profile")
  def profile():
      return render_template(
          "profile.html",
          username="TT",
          age=20
      )
  ```

- Static Files (CSS / JS)

  ```py
  # Folder structure:
  # /static/style.css
  # /templates/index.html
  ```

  ```html
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  ```

- Redirects & URL Building

  ```py
  from flask import redirect, url_for

  @app.route("/old")
  def old():
      return redirect(url_for("home"))
  ```

- Error Handling

  ```py
  @app.errorhandler(404)
  def not_found(e):
      return "Page not found", 404
  ```

  ```py
  @app.errorhandler(500)
  def server_error(e):
      return "Server error", 500
  ```

- Blueprints (Project Structure)

  ```py
  from flask import Blueprint

  auth = Blueprint("auth", __name__)

  @auth.route("/login")
  def login():
      return "Login Page"
  ```

  ```py
  app.register_blueprint(auth, url_prefix="/auth")
  ```

- Configuration & Environment Variables

  ```py
  import os

  app.config["SECRET_KEY"] = os.getenv("SECRET_KEY")
  app.config["DEBUG"] = True
  ```

- Middleware (Before & After Request)

  ```py
  @app.before_request
  def before_request():
      print("Before request")

  @app.after_request
  def after_request(response):
      return response
  ```

- Database Integration (Flask + MySQ)

  ```py
  import mysql.connector

  def get_db():
      return mysql.connector.connect(
          host="HOST",
          user="USER",
          password="PASSWORD",
          database="DB_NAME"
      )
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Project Structure of Flask**

- Minimal Flask App Structure

  ```txt
  flask_app/
  ‚îú‚îÄ app.py
  ‚îú‚îÄ requirements.txt
  ‚îî‚îÄ README.md
  ```

- Standard Structure

  ```txt
  flask_app/
  ‚îú‚îÄ app/
  ‚îÇ  ‚îú‚îÄ __init__.py          # create_app(), app config
  ‚îÇ  ‚îú‚îÄ routes.py            # main routes
  ‚îÇ  ‚îú‚îÄ models.py            # database models
  ‚îÇ  ‚îú‚îÄ extensions.py        # db, login_manager, etc.
  ‚îÇ  ‚îú‚îÄ config.py            # configuration classes
  ‚îÇ  ‚îÇ
  ‚îÇ  ‚îú‚îÄ templates/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ base.html
  ‚îÇ  ‚îÇ  ‚îú‚îÄ index.html
  ‚îÇ  ‚îÇ  ‚îî‚îÄ auth/
  ‚îÇ  ‚îÇ     ‚îî‚îÄ login.html
  ‚îÇ  ‚îÇ
  ‚îÇ  ‚îî‚îÄ static/
  ‚îÇ     ‚îú‚îÄ css/
  ‚îÇ     ‚îÇ  ‚îî‚îÄ style.css
  ‚îÇ     ‚îú‚îÄ js/
  ‚îÇ     ‚îÇ  ‚îî‚îÄ main.js
  ‚îÇ     ‚îî‚îÄ images/
  ‚îÇ
  ‚îú‚îÄ migrations/             # Flask-Migrate (Alembic)
  ‚îÇ
  ‚îú‚îÄ tests/
  ‚îÇ  ‚îú‚îÄ __init__.py
  ‚îÇ  ‚îî‚îÄ test_routes.py
  ‚îÇ
  ‚îú‚îÄ .env
  ‚îú‚îÄ .gitignore
  ‚îú‚îÄ requirements.txt
  ‚îî‚îÄ run.py                  # entry point
  ```

- Large / Scalable Structure (Production-style)

  ```txt
  flask_app/
  ‚îú‚îÄ app/
  ‚îÇ  ‚îú‚îÄ __init__.py
  ‚îÇ  ‚îú‚îÄ auth/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ __init__.py
  ‚îÇ  ‚îÇ  ‚îú‚îÄ routes.py
  ‚îÇ  ‚îÇ  ‚îú‚îÄ forms.py
  ‚îÇ  ‚îÇ  ‚îî‚îÄ models.py
  ‚îÇ  ‚îÇ
  ‚îÇ  ‚îú‚îÄ blog/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ __init__.py
  ‚îÇ  ‚îÇ  ‚îú‚îÄ routes.py
  ‚îÇ  ‚îÇ  ‚îî‚îÄ models.py
  ‚îÇ  ‚îÇ
  ‚îÇ  ‚îú‚îÄ templates/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ base.html
  ‚îÇ  ‚îÇ  ‚îú‚îÄ auth/
  ‚îÇ  ‚îÇ  ‚îî‚îÄ blog/
  ‚îÇ  ‚îÇ
  ‚îÇ  ‚îú‚îÄ static/
  ‚îÇ  ‚îÇ
  ‚îÇ  ‚îî‚îÄ extensions.py
  ‚îÇ
  ‚îú‚îÄ migrations/
  ‚îú‚îÄ tests/
  ‚îú‚îÄ .env
  ‚îú‚îÄ requirements.txt
  ‚îî‚îÄ run.py
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 30 - FastAPI**

- FastAPI is a modern, high-performance Python web framework used to build APIs quickly with automatic documentation and strong type safety.

[‚¨ÜÔ∏è Go to Context](#context)

## **FastAPI Setup**

- Create [venv](#create-conda-environment)
- Install [fastapi](https://pypi.org/project/fastapi/), [uvicorn](https://pypi.org/project/uvicorn/), [pydantic](https://pypi.org/project/pydantic/)

[‚¨ÜÔ∏è Go to Context](#context)

## **FastAPI Usages**

- Core Usages
  - Building RESTful APIs
  - Creating backend services for web & mobile apps
  - Developing microservices
  - Serving machine learning models
  - Backend for SPAs (React / Next.js / Vue)
  - Internal tools & automation services

- API Development
  - CRUD APIs (Create, Read, Update, Delete)
  - Request validation using Pydantic models
  - Automatic request parsing (JSON, query params, path params)
  - Automatic response serialization
  - API versioning

- Performance & Architecture
  - Asynchronous APIs using async/await
  - High performance with Starlette & Uvicorn
  - Suitable for I/O-bound and concurrent workloads
  - Lightweight alternative to Django REST Framework

- Authentication & Security
  - JWT-based authentication
  - OAuth2 (Password, Authorization Code)
  - API key authentication
  - Role-based access control (RBAC)
  - Dependency-based security checks

- Database Integration
  - SQL databases (PostgreSQL, MySQL, SQLite)
  - ORM support (SQLAlchemy, SQLModel)
  - Async DB access (asyncpg, databases)
  - NoSQL databases (MongoDB with Motor)

- Documentation & Testing
  - Auto-generated Swagger UI (/docs)
  - ReDoc documentation (/redoc)
  - Type hints act as documentation
  - Easy integration with pytest
  - TestClient for API testing

- Microservices & DevOps
  - Container-friendly (Docker)
  - Easy deployment with AWS, GCP, Azure
  - Works well with Kubernetes
  - Used behind API gateways
  - Health-check endpoints

- Background & Advanced Tasks
  - Background tasks (email, logging, cleanup jobs)
  - Middleware support
  - Custom exception handling
  - Event hooks (startup & shutdown)
  - WebSocket support (real-time apps)

- Machine Learning & Data APIs
  - Serving trained ML/DL models
  - Model inference APIs
  - Data preprocessing endpoints
  - Lightweight alternative to Flask for ML serving

- When to Use FastAPI
  - Need high-speed APIs
  - Prefer strong typing & validation
  - Building scalable microservices
  - Want automatic API docs

- When NOT to Use FastAPI
  - Full monolithic apps with heavy admin panels
  - CMS-like applications (Django is better)

[‚¨ÜÔ∏è Go to Context](#context)

## **FastAPI Implementation**

- **App Setup & Initialization**

  ```py
  # main.py
  from fastapi import FastAPI

  app = FastAPI(title="My API", version="0.1.0")

  @app.get("/")
  def read_root():
      return {"hello": "world"}
  ```

- Development run:

  ```sh
  python -m uvicorn main:app --host 127.0.0.1 --port 8000 --reload
  ```

- **Routing basics (path & query params)**

  ```py
  from fastapi import FastAPI, Path, Query

  app = FastAPI()

  @app.get("/items/{item_id}")
  def get_item(item_id: int = Path(..., title="ID of item"), q: str | None = Query(None, max_length=50)):
      return {"item_id": item_id, "q": q}
  ```

  - `Path` and `Query` allow metadata & validation (min/max, regex, description).
  - Path params are required. Query params optional by default.

- **Request body & Pydantic models**

  ```py
  from pydantic import BaseModel, Field
  from typing import List, Optional

  class Item(BaseModel):
      name: str = Field(..., min_length=1, max_length=100)
      description: Optional[str] = None
      price: float = Field(..., gt=0)
      tags: List[str] = []

  @app.post("/items", response_model=Item, status_code=201)
  def create_item(item: Item):
      # item is validated and typed
      return item
  ```

  - Use `response_model` to validate & shape output.
  - Pydantic `Field(...)` for constraints and examples.

- **Response types & classes**

  ```py
  from fastapi.responses import JSONResponse, HTMLResponse, PlainTextResponse, FileResponse, StreamingResponse

  @app.get("/html", response_class=HTMLResponse)
  def get_html():
      return "<html><body><h1>Hello</h1></body></html>"

  @app.get("/file")
  def get_file():
      return FileResponse("path/to/file.pdf", media_type="application/pdf", filename="report.pdf")
  ```

  - `StreamingResponse` for large streams (video, large JSON, generator).
  - Set appropriate `status_code` and headers as needed.

- **Advanced response control**

  ```py
  from fastapi import Response

  @app.get("/custom")
  def custom():
      content = {"hello": "world"}
      return JSONResponse(content=content, status_code=202, headers={"X-App": "MyApp"})
  ```

  - Use `response_model_include` / `exclude` and `response_model_exclude_unset` to control fields.

- **Dependencies (DI) ‚Äî basic & yield cleanup**

  ```py
  from fastapi import Depends

  def common_parameters(q: str | None = None, limit: int = 10):
      return {"q": q, "limit": limit}

  @app.get("/search")
  def search(params: dict = Depends(common_parameters)):
      return params
  ```

  - `Depends` supports callables, classes (`__call__`), async dependencies.
  - Use `yield` in dependencies for setup/teardown (e.g., DB session):

  ```py
  from contextlib import contextmanager

  async def get_db():
      db = create_session()
      try:
          yield db
      finally:
          db.close()
  ```

- **APIRouter & modularization**

  ```py
  from fastapi import APIRouter

  router = APIRouter(prefix="/users", tags=["users"])

  @router.get("/")
  def list_users():
      return [{"id": 1, "name": "Alice"}]

  # main.py
  app.include_router(router)
  ```

  - Create routers per domain (users, auth, items) and include in main app.
  - Supports prefix, tags, dependencies for groups.

- **Middleware & CORS**

  ```py
  from fastapi.middleware.cors import CORSMiddleware

  app.add_middleware(
      CORSMiddleware,
      allow_origins=["https://myfrontend.com"],
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
  )
  ```

- Custom middleware example:

  ```py
  from starlette.middleware.base import BaseHTTPMiddleware
  from starlette.requests import Request
  from starlette.responses import Response

  class LoggingMiddleware(BaseHTTPMiddleware):
      async def dispatch(self, request: Request, call_next):
          print("request:", request.method, request.url)
          response: Response = await call_next(request)
          print("response status:", response.status_code)
          return response

  app.add_middleware(LoggingMiddleware)
  ```

- **Startup & Shutdown events**

  ```py
  @app.on_event("startup")
  async def startup_event():
      # create connection pool, initialize cache, etc.
      pass

  @app.on_event("shutdown")
  async def shutdown_event():
      # cleanup
      pass
  ```

  - Use for global resources (DB pool, message brokers).

- **Background tasks**

  ```py
  from fastapi import BackgroundTasks

  def write_log(message: str):
      with open("log.txt", "a") as f:
          f.write(message + "\n")

  @app.post("/notify")
  def notify(background_tasks: BackgroundTasks, msg: str):
      background_tasks.add_task(write_log, msg)
      return {"status": "accepted"}
  ```

  - Good for non-critical tasks (emails, logs) ‚Äî not for long-running workers (use Celery/RQ).

- **File uploads & forms**

  ```py
  from fastapi import File, UploadFile, Form

  @app.post("/upload")
  async def upload(file: UploadFile = File(...), desc: str = Form(...)):
      contents = await file.read()
      # save or process
      return {"filename": file.filename, "content_length": len(contents)}
  ```

  - `UploadFile` is async-friendly and efficient.

- **WebSockets**

  ```py
  from fastapi import WebSocket

  @app.websocket("/ws")
  async def websocket_endpoint(ws: WebSocket):
      await ws.accept()
      while True:
          data = await ws.receive_text()
          await ws.send_text(f"echo: {data}")
  ```

  - Use for realtime features. When running behind proxy, ensure proper websocket support.

- **Server-Sent Events (SSE) / streaming**

  ```py
  from fastapi.responses import StreamingResponse
  import asyncio

  async def event_generator():
      for i in range(5):
          yield f"data: ping {i}\n\n"
          await asyncio.sleep(1)

  @app.get("/sse")
  async def sse():
      return StreamingResponse(event_generator(), media_type="text/event-stream")
  ```

- **Security: OAuth2 password flow & JWT (example)**

  ```py
  from fastapi import Depends, HTTPException, status
  from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
  from datetime import datetime, timedelta
  import jwt  # use PyJWT or jose

  oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

  SECRET = "super-secret"
  ALGORITHM = "HS256"

  def create_access_token(data: dict, expires_delta: timedelta | None = None):
      to_encode = data.copy()
      expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
      to_encode.update({"exp": expire})
      return jwt.encode(to_encode, SECRET, algorithm=ALGORITHM)

  @app.post("/token")
  def login(form_data: OAuth2PasswordRequestForm = Depends()):
      # validate user credentials (check DB)
      if form_data.username != "bob" or form_data.password != "pass":
          raise HTTPException(status_code=401, detail="Invalid credentials")
      token = create_access_token({"sub": form_data.username})
      return {"access_token": token, "token_type": "bearer"}

  def get_current_user(token: str = Depends(oauth2_scheme)):
      try:
          payload = jwt.decode(token, SECRET, algorithms=[ALGORITHM])
          username = payload.get("sub")
          if username is None:
              raise HTTPException(status_code=401)
          return {"username": username}
      except jwt.PyJWTError:
          raise HTTPException(status_code=401)
  ```

  - Use well-tested libs (`python-jose`, `PyJWT`) and rotate secrets.
  - Implement refresh tokens and scopes for production.

- **Async vs Sync functions**

  - Use `async def` when you perform IO-bound async ops (db async drivers, httpx async). Use sync for CPU-bound or sync libs.
  - If a sync blocking function must run in an async endpoint, use `run_in_threadpool`:

    ```py
    from starlette.concurrency import run_in_threadpool
    result = await run_in_threadpool(sync_blocking_func, arg)
    ```

- **Databases: sync (SQLAlchemy) & async (SQLModel / async SQLAlchemy)**

- Sync SQLAlchemy + session dependency:

  ```py
  # db.py (sync)
  from sqlalchemy import create_engine
  from sqlalchemy.orm import sessionmaker

  engine = create_engine("postgresql://user:passwd@localhost/dbname")
  SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

  def get_db():
      db = SessionLocal()
      try:
          yield db
      finally:
          db.close()
  ```

  ```py
  @app.get("/users/{user_id}")
  def get_user(user_id: int, db = Depends(get_db)):
      return db.query(User).filter(User.id == user_id).first()
  ```

- Async example with SQLModel / AsyncEngine:

  ```py
  # async_db.py
  from sqlmodel import SQLModel, create_engine, AsyncSession
  from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker

  engine = create_async_engine("postgresql+asyncpg://user:pass@localhost/db")
  async_session = async_sessionmaker(engine, expire_on_commit=False)

  async def get_session():
      async with async_session() as session:
          yield session
  ```

- Migrations with Alembic (sync SQLAlchemy): commands (WSL/Linux / Windows):

  - WSL/Linux:

    ```bash
    pip install alembic
    alembic init alembic
    # edit alembic.ini and env.py to point to SQLALCHEMY DB URL
    alembic revision --autogenerate -m "create users"
    alembic upgrade head
    ```

  - Windows PowerShell (similar):

    ```sh
    .\.venv\Scripts\Activate.ps1
    pip install alembic
    alembic init alembic
    # run revisions and upgrades similarly
    ```

- For async migrations, use tools that support async dialects (recent Alembic versions can be configured).

- **Testing (TestClient & pytest)**

  ```py
  from fastapi.testclient import TestClient
  import pytest

  client = TestClient(app)

  def test_read_root():
      resp = client.get("/")
      assert resp.status_code == 200
      assert resp.json() == {"hello": "world"}

  # override dependencies
  def test_with_fake_db():
      def fake_get_db():
          yield FakeDB()
      app.dependency_overrides[get_db] = fake_get_db
      resp = client.get("/users/1")
      assert resp.status_code == 200
  ```

   Use `app.dependency_overrides` to inject test doubles.

- **OpenAPI / docs customization**

  ```py
  app = FastAPI(
      title="My API",
      description="Detailed description",
      version="0.2.0",
      docs_url="/docs",         # Swagger UI
      redoc_url="/redoc",      # ReDoc
      openapi_url="/openapi.json"
  )

  @app.get("/items", tags=["items"], summary="List items", description="Returns a list of items.")
  def list_items():
      ...
  ```

  - Add examples via `Field(example=...)` or `response_model` examples.

- **Versioning & routing patterns**

  - Common approaches:

    - URL versioning: `/v1/items`, `/v2/items`
    - Header-based versioning (custom dependency to read header)
  - Keep routers grouped per version: `v1_router`, `v2_router`.

- **Pagination & filtering patterns**

  ```py
  @app.get("/items")
  def list_items(limit: int = 10, offset: int = 0, q: str | None = None):
      query = db.query(Item)
      if q:
          query = query.filter(Item.name.ilike(f"%{q}%"))
      items = query.offset(offset).limit(limit).all()
      return {"count": len(items), "items": items}
  ```

  - Return metadata (total_count, next_page) for clients.

- **Caching & rate limiting (third-party)**

  - Use `fastapi-cache2`, `aiocache` for caching responses.
  - Rate limiting: use `slowapi` or an API gateway (NGINX / Kong) for production rate limiting.

  ```py
  # example using fastapi-cache2
  from fastapi_cache import FastAPICache
  from fastapi_cache.backends.inmemory import InMemoryBackend

  @app.on_event("startup")
  async def startup():
      FastAPICache.init(InMemoryBackend(), prefix="fastapi-cache")
  ```

- **Observability: logging & tracing**

  - Use structured logging (structlog or Python logging with JSON formatter).
  - Integrate tracing (OpenTelemetry) and error tracking (Sentry).
  - Example Sentry setup:

    ```py
    import sentry_sdk
    sentry_sdk.init(dsn="your_dsn")
    ```

- **Mounting static files & templates**

  ```py
  from fastapi.staticfiles import StaticFiles
  from fastapi.templating import Jinja2Templates
  from fastapi import Request

  app.mount("/static", StaticFiles(directory="static"), name="static")
  templates = Jinja2Templates(directory="templates")

  @app.get("/page")
  def get_page(request: Request):
      return templates.TemplateResponse("index.html", {"request": request, "title": "Home"})
  ```

- **Mounting sub-applications**

  ```py
  from fastapi import FastAPI

  admin_app = FastAPI(openapi_prefix="/admin")

  @admin_app.get("/stats")
  def stats():
      return {"uptime": 100}

  app.mount("/admin", admin_app)
  ```

  - Useful when combining microservices or separate apps.

- **Webhooks & security tips**

  - Validate webhook payloads with signatures (HMAC).
  - Use HTTPS for production and verify certificates.

- **Common pitfalls & best practices**

  - Don‚Äôt run Uvicorn with `--reload` in production.
  - Avoid blocking IO in `async` endpoints (use threadpool).
  - Always validate user input and escape outputs (when rendering HTML).
  - Limit body size or implement streaming for large uploads.
  - Use connection pools for DBs; don‚Äôt create new engine/session per request.
  - Keep secrets out of code (use env vars / secret manager).
  - Use HTTPS + HSTS in production.

- **Deployment checklist (brief)**

  - Set environment variables (DB, secrets).

  - Use a process manager (systemd) or container orchestrator (Docker + Kubernetes).

  - Example Dockerfile:

    ```dockerfile
    FROM python:3.11-slim
    WORKDIR /app
    COPY pyproject.toml .
    RUN pip install --no-cache-dir fastapi uvicorn
    COPY . .
    CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]
    ```

  - Use reverse proxy (NGINX) in front of app for static serving, HTTPS termination, rate limiting.

- **Extending FastAPI ecosystem (tools & libs to know)**

  - Databases: SQLAlchemy, SQLModel, Tortoise ORM, asyncpg
  - Migrations: Alembic
  - Authentication: python-jose, oauthlib, Authlib
  - Background workers: Celery, RQ, Dramatiq
  - Caching: fastapi-cache2, redis
  - Testing: pytest, httpx (async testing), TestClient
  - Docs: Swagger UI, ReDoc (customize/extend)
  - Observability: OpenTelemetry, Sentry

- **Minimal practical template (file layout)**

  ```txt
  project/
  ‚îú‚îÄ app/
  ‚îÇ  ‚îú‚îÄ main.py
  ‚îÇ  ‚îú‚îÄ api/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ v1/
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ users.py
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ items.py
  ‚îÇ  ‚îú‚îÄ core/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ config.py
  ‚îÇ  ‚îÇ  ‚îî‚îÄ security.py
  ‚îÇ  ‚îú‚îÄ db/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ base.py
  ‚îÇ  ‚îÇ  ‚îî‚îÄ session.py
  ‚îÇ  ‚îî‚îÄ models/
  ‚îú‚îÄ alembic/
  ‚îú‚îÄ tests/
  ‚îú‚îÄ Dockerfile
  ‚îî‚îÄ pyproject.toml
  ```

- **Quick reference snippets**

  - Run async DB query example (SQLModel):

    ```py
    async with async_session() as session:
        result = await session.execute(select(User).where(User.id == user_id))
        user = result.scalar_one_or_none()
    ```

  - Override dependency for tests:

    ```py
    app.dependency_overrides[get_db] = override_get_db
    ```

  - Return paginated data with meta:

    ```py
    return {"total": total, "limit": limit, "offset": offset, "items": items}
    ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Project Structure of FastAPI**

- **Minimal FastAPI App**

  ```txt
  fastapi_app/
  ‚îú‚îÄ main.py                # app = FastAPI(), include routers, run with uvicorn
  ‚îú‚îÄ requirements.txt       # fastapi, uvicorn[standard], pydantic...
  ‚îî‚îÄ README.md
  ```

  - `main.py` ‚Äî tiny app (startup events, one route). Run: `uvicorn main:app --reload`

- **Standard Structure**

  ```txt
  fastapi_app/
  ‚îú‚îÄ app/
  ‚îÇ  ‚îú‚îÄ __init__.py         # optional; package marker
  ‚îÇ  ‚îú‚îÄ main.py             # app factory or app instance, include routers, startup/shutdown
  ‚îÇ  ‚îú‚îÄ core/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ config.py        # settings (pydantic BaseSettings)
  ‚îÇ  ‚îÇ  ‚îî‚îÄ security.py      # JWT helpers, password hashing
  ‚îÇ  ‚îú‚îÄ api/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ __init__.py
  ‚îÇ  ‚îÇ  ‚îú‚îÄ v1/
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ __init__.py
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ routers/
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ users.py
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ items.py
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ schemas.py    # Pydantic models (request/response)
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ crud.py       # DB access helpers
  ‚îÇ  ‚îú‚îÄ db/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ base.py          # Base metadata, model imports
  ‚îÇ  ‚îÇ  ‚îú‚îÄ session.py       # engine/session (sync/async)
  ‚îÇ  ‚îÇ  ‚îî‚îÄ models.py        # SQLAlchemy/SQLModel models
  ‚îÇ  ‚îú‚îÄ services/
  ‚îÇ  ‚îÇ  ‚îî‚îÄ ml_inference.py  # model loading + inference endpoints caller
  ‚îÇ  ‚îú‚îÄ dependencies.py     # common dependency functions (auth, pagination)
  ‚îÇ  ‚îú‚îÄ background_tasks.py # Celery/RQ integration or FastAPI BackgroundTasks usage
  ‚îÇ  ‚îú‚îÄ templates/          # Jinja2 if using server-side templates
  ‚îÇ  ‚îî‚îÄ static/             # static files (served by ASGI in dev or by CDN/nginx in prod)
  ‚îÇ
  ‚îú‚îÄ alembic/               # DB migrations (if using SQLAlchemy/SQLModel + Alembic)
  ‚îú‚îÄ tests/
  ‚îÇ  ‚îú‚îÄ __init__.py
  ‚îÇ  ‚îî‚îÄ test_users.py       # pytest + AsyncClient/httpx or TestClient
  ‚îú‚îÄ .env
  ‚îú‚îÄ .gitignore
  ‚îú‚îÄ requirements.txt
  ‚îî‚îÄ docker-compose.yml     # optional
  ```

  - Use routers to split endpoints; mount versions (e.g., `/api/v1`).
  - `schemas.py` = Pydantic models (validate and document automatically).
  - `dependencies.py` centralizes auth and reusable DI.

- **Large / Scalable (production-style)**

  ```txt
  fastapi_app/
  ‚îú‚îÄ app/
  ‚îÇ  ‚îú‚îÄ main.py
  ‚îÇ  ‚îú‚îÄ core/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ config.py
  ‚îÇ  ‚îÇ  ‚îú‚îÄ logger.py
  ‚îÇ  ‚îÇ  ‚îî‚îÄ events.py       # startup/shutdown hooks
  ‚îÇ  ‚îú‚îÄ api/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ v1/
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ routers/
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ schemas/
  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ crud/
  ‚îÇ  ‚îÇ  ‚îî‚îÄ v2/             # future versions
  ‚îÇ  ‚îú‚îÄ models/             # per-model files or folder per domain
  ‚îÇ  ‚îú‚îÄ db/
  ‚îÇ  ‚îÇ  ‚îú‚îÄ session.py
  ‚îÇ  ‚îÇ  ‚îú‚îÄ base.py
  ‚îÇ  ‚îÇ  ‚îî‚îÄ repositories/
  ‚îÇ  ‚îú‚îÄ services/
  ‚îÇ  ‚îú‚îÄ workers/            # celery tasks + workers
  ‚îÇ  ‚îú‚îÄ utils/
  ‚îÇ  ‚îú‚îÄ tests/
  ‚îÇ  ‚îî‚îÄ docs/               # extra documentation (MD files)
  ‚îÇ
  ‚îú‚îÄ migrations/            # alembic or other migration tool
  ‚îú‚îÄ infra/
  ‚îÇ  ‚îú‚îÄ Dockerfile
  ‚îÇ  ‚îú‚îÄ k8s/                # k8s manifests
  ‚îÇ  ‚îî‚îÄ helm/               # optional
  ‚îú‚îÄ ci/
  ‚îÇ  ‚îî‚îÄ pipelines.yml
  ‚îú‚îÄ requirements.txt
  ‚îú‚îÄ poetry.lock / pyproject.toml
  ‚îî‚îÄ README.md
  ```

  - Separate `services/` for business logic and `repositories/` for DB access.
  - `infra/` for deployment artifacts; `ci/` for pipeline configs.

- **Common/Useful files & notes**

  - `main.py` (example minimal):

    ```py
    from fastapi import FastAPI
    from .api.v1.routers import users

    app = FastAPI(title="My App")

    app.include_router(users.router, prefix="/api/v1/users")
    ```

  - `core/config.py` ‚Äî use `pydantic.BaseSettings` for env-driven config.
  - `db/session.py` ‚Äî choose sync (SQLAlchemy + sessionmaker) or async (async_engine + AsyncSession / SQLModel).
  - `schemas.py` ‚Äî place Pydantic models near routers or in per-domain `schemas/`.
  - `dependencies.py` ‚Äî put reusable DI like `get_db`, `get_current_user`.
  - `Dockerfile` ‚Äî use `uvicorn` (ASGI): `CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "80"]`.
  - `requirements.txt` typical libs:

    - `fastapi`
    - `uvicorn[standard]`
    - `sqlalchemy` or `sqlmodel`
    - `databases` or `asyncpg` (if async)
    - `alembic`
    - `pydantic`
    - `pytest`, `httpx`
    - `python-jose` / `passlib` for auth

- **Testing**

  - Use `pytest` + `httpx.AsyncClient` for async endpoints or `TestClient` for sync.
  - Put fixtures for test DB in `tests/conftest.py` (use sqlite in-memory or test docker DB).

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 31 - Pandas for Data Science**

## **Pandas Setup**

- Create [venv](#create-conda-environment)
- Install [ipykernel](https://pypi.org/project/ipykernel/), [pandas](https://pypi.org/project/pandas/)
- pandas [docs](https://pandas.pydata.org/docs/)

[‚¨ÜÔ∏è Go to Context](#context)

## **Pandas Intro**

- Import pandas library.

  ```py
  import pandas as pd
  ```

- Create a DataFrame from a 2D list with custom columns and index.

  ```py
  df = pd.DataFrame(
      [[1,2,3],[4,5,6],[7,8,9],[10,11,12]],
      columns=['A', 'B', 'C'],
      index=["x1", "x2", "x3", "x4"]
  )
  df
  ```

- View first N rows of DataFrame.

  ```py
  df.head(2)
  ```

- View last N rows of DataFrame.

  ```py
  df.tail(2)
  ```

- Access column index object.

  ```py
  df.columns
  ```

- Convert column index to Python list.

  ```py
  df.columns.to_list()
  ```

- Access row index object.

  ```py
  df.index
  ```

- Convert row index to Python list.

  ```py
  df.index.to_list()
  ```

- Show structure, datatypes, and memory usage.

  ```py
  df.info()
  ```

- Generate statistical summary of numeric columns.

  ```py
  df.describe()
  ```

- Count unique values per column.

  ```py
  df.nunique()
  ```

- Count unique values in a specific column.

  ```py
  df["A"].nunique()
  ```

- Get unique values of a column.

  ```py
  df["A"].unique()
  ```

- Get shape as (rows, columns).

  ```py
  df.shape
  ```

- Get total number of elements (rows √ó columns).

  ```py
  df.size
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Loading DataFrames from Files**

- Load CSV file into DataFrame.

  ```py
  coffee = pd.read_csv("warmup-data/coffee.csv")
  coffee.head()
  ```

- Load Parquet file into DataFrame.

  ```py
  results = pd.read_parquet("data/results.parquet")
  results.head()
  ```

- Load another CSV file.

  ```py
  bios = pd.read_csv("data/bios.csv")
  bios.head()
  ```

- Load Excel file with specific sheet.

  ```py
  olympics_data = pd.read_excel(
      "data/olympics-data.xlsx",
      sheet_name='results'
  )
  olympics_data.head()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Viewing & Sampling Data**

- Print entire DataFrame (console).

  ```py
  print(coffee)
  ```

- Display DataFrame nicely in notebooks.

  ```py
  display(coffee)
  ```

- Randomly sample rows.

  ```py
  coffee.sample(5)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Accessing Data with loc and iloc**

- Access a full row by label-based index.

  ```py
  coffee.loc[0]
  ```

- Access a specific cell using labels.

  ```py
  coffee.loc[0, "Coffee Type"]
  ```

- Access multiple rows by labels.

  ```py
  coffee.loc[[0,1,2]]
  ```

- Access a cell using integer positions.

  ```py
  coffee.iloc[0, 1]
  ```

- Select all rows but specific columns by position.

  ```py
  coffee.iloc[:, [0,2]]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Index Manipulation**

- Change DataFrame index to a column.

  ```py
  coffee.index = coffee["Day"]
  coffee.head()
  ```

- Access row using new index label.

  ```py
  coffee.loc["Monday", "Coffee Type"]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Setting & Updating Values**

- Reload DataFrame to reset changes.

  ```py
  coffee = pd.read_csv('./warmup-data/coffee.csv')
  ```

- Update a column value for a slice of rows.

  ```py
  coffee.loc[1:3, "Units Sold"] = 10
  coffee.head()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Column Access Techniques**

- Access column using bracket notation.

  ```py
  coffee["Day"]
  ```

- Access column using dot notation.

  ```py
  coffee.Day
  ```

- Store a column as Series (1D).

  ```py
  s = coffee['Coffee Type']
  s
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Sorting Data**

- Sort DataFrame by one column descending.

  ```py
  coffee.sort_values(["Units Sold"], ascending=False)
  ```

- Sort by multiple columns with mixed order.

  ```py
  coffee.sort_values(
      ["Units Sold", "Coffee Type"],
      ascending=[1, 0]
  )
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Iterating Over DataFrame (Not Recommended for Big Data)**

- Iterate row-by-row using iterrows().

  ```py
  for index, row in coffee.iterrows():
      print(f"Index: {index}")
      print(f"Row Data:\n{row}")
      print(f"Coffee Type: {row['Coffee Type']}")
      print("--")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Filtering Data**

- Create boolean mask from condition.

  ```py
  bios["height_cm"] > 215
  ```

- Filter rows using boolean mask.

  ```py
  temp = bios.loc[bios["height_cm"] > 215]
  temp.head()
  ```

- Filter rows and select columns.

  ```py
  bios.loc[bios["height_cm"] > 215, ["name", "height_cm"]]
  ```

- Shorthand filtering without `.loc`.

  ```py
  bios[bios['height_cm'] > 215][["name", "height_cm"]]
  ```

- Apply multiple filter conditions.

  ```py
  bios[
      (bios['height_cm'] > 215) &
      (bios['born_country'] == 'USA')
  ]
  ```

- Filter rows using string matching.

  ```py
  bios[bios['name'].str.contains("keith", case=False)]
  ```

- Use query syntax for readable filtering.

  ```py
  bios.query('born_country == "USA" and born_city == "Seattle"')
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Adding, Removing & Renaming Columns**

- Add constant-value column.

  ```py
  coffee["price"] = 4.99
  ```

- Conditionally assign values using NumPy.

  ```py
  import numpy as np

  coffee["new_price"] = np.where(
      coffee["Coffee Type"] == "Espresso",
      3.99,
      5.99
  )
  ```

- Remove a column from DataFrame.

  ```py
  coffee.drop(columns=["price"], inplace=True)
  ```

- Create computed column from arithmetic.

  ```py
  coffee["revenue"] = coffee["Units Sold"] * coffee["new_price"]
  ```

- Rename column names.

  ```py
  coffee.rename(columns={"new_price": "price"}, inplace=True)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Date & Time Handling**

- Convert string column to datetime.

  ```py
  bios["died_datetime"] = pd.to_datetime(bios["died_date"])
  ```

- Extract year from datetime column.

  ```py
  bios["died_year"] = bios["died_datetime"].dt.year
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Exporting Data**

- Save DataFrame to CSV without index.

  ```py
  bios.to_csv("data/temp_bios.csv", index=False)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Row-wise Logic with apply()**

- Define custom classification logic.

  ```py
  def categorize_athlete(row):
      if row['height_cm'] < 175 and row['weight_kg'] < 70:
          return 'Lightweight'
      elif row['height_cm'] < 185 or row['weight_kg'] <= 80:
          return 'Middleweight'
      else:
          return 'Heavyweight'
  ```

- Apply function row-wise.

  ```py
  bios["Category"] = bios.apply(categorize_athlete, axis=1)
  bios
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Merging & Joining DataFrames**

- Load lookup table for merging.

  ```py
  nocs = pd.read_csv('./data/noc_regions.csv')
  ```

- Merge DataFrames using different key names.

  ```py
  bios_new = pd.merge(
      bios,
      nocs,
      left_on="born_country",
      right_on="NOC"
  )
  bios_new.head()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Handling Missing (NaN) Values**

- Detect missing values per column.

  ```py
  coffee.isnull().sum()
  ```

- Introduce NaN values manually.

  ```py
  coffee.loc[[2,3], 'Units Sold'] = np.nan
  ```

- Fill missing values with column mean.

  ```py
  coffee["Units Sold"].fillna(
      coffee["Units Sold"].mean(),
      inplace=True
  )
  ```

- Drop rows with NaN in specific column.

  ```py
  coffee.dropna(subset=['Units Sold'], inplace=True)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Aggregation & Grouping**

- Count frequency of values in a column.

  ```py
  bios['born_city'].value_counts()
  ```

- Aggregate using groupby with sum.

  ```py
  coffee.groupby(["Coffee Type"])["Units Sold"].sum()
  ```

- Aggregate using groupby with mean.

  ```py
  coffee.groupby(["Coffee Type"])["Units Sold"].mean()
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Pivot Tables (Reshaping Data)**

- Create pivot table from DataFrame.

  ```py
  pivot = coffee.pivot(
      columns="Coffee Type",
      index="Day",
      values="revenue"
  )
  pivot
  ```

[‚¨ÜÔ∏è Go to Context](#context)

# **Day 32 - Numpy for Data Science**

## **NumPy Setup**

- [Numpy docs](https://numpy.org/doc/stable/user/absolute_beginners.html)
- Install [numpy](https://pypi.org/project/numpy/), [ipykernel](https://pypi.org/project/ipykernel/)
- Import NumPy

  ```py
  import numpy as np
  ```

- Check version

  ```py
  np.__version__
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Creating NumPy Arrays**

- From Python list

  ```py
  arr = np.array([1, 2, 3, 4])
  ```

- 2D array (matrix)

  ```py
  arr2d = np.array([
      [1, 2, 3],
      [4, 5, 6]
  ])
  ```

- Check array type

  ```py
  type(arr)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Array Attributes**

- Shape (rows, columns)

  ```py
  arr2d.shape
  ```

- Number of dimensions

  ```py
  arr2d.ndim
  ```

- Total elements

  ```py
  arr2d.size
  ```

- Data type

  ```py
  arr2d.dtype
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Common Array Creation Methods**

- Zeros

  ```py
  np.zeros((3, 4))
  ```

- Ones

  ```py
  np.ones((2, 2))
  ```

- Identity matrix

  ```py
  np.eye(3)
  ```

- Range (like Python range)

  ```py
  np.arange(0, 10, 2)
  ```

- Evenly spaced numbers

  ```py
  np.linspace(0, 1, 5)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Random Numbers**

- Random floats (0 to 1)

  ```py
  np.random.rand(3, 2)
  ```

- Random integers

  ```py
  np.random.randint(1, 10, size=(2, 3))
  ```

- Normal distribution

  ```py
  np.random.randn(3, 3)
  ```

- Set random seed (important for ML)

  ```py
  np.random.seed(42)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Array Indexing**

- 1D indexing

  ```py
  arr = np.array([10, 20, 30, 40])
  arr[0]
  arr[-1]
  ```

- 2D indexing

  ```py
  arr2d[0, 1]   # row 0, col 1
  ```

- Row slicing

  ```py
  arr2d[1]
  ```

- Column slicing

  ```py
  arr2d[:, 1]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Array Slicing**

- Basic slicing

  ```py
  arr[1:4]
  ```

- 2D slicing

  ```py
  arr2d[:2, :2]
  ```

- Step slicing

  ```py
  arr[::2]
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Boolean Indexing**

- Condition-based selection

  ```py
  arr = np.array([5, 10, 15, 20])
  arr[arr > 10]
  ```

- Modify values using condition

  ```py
  arr[arr < 10] = 0
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Array Operations (Vectorization)**

- Element-wise operations

  ```py
  arr + 10
  arr * 2
  arr ** 2
  ```

- Array-to-array operations

  ```py
  a = np.array([1, 2, 3])
  b = np.array([4, 5, 6])

  a + b
  a * b
  ```

- Why NumPy is fast

  - No Python loops
  - Uses C under the hood

[‚¨ÜÔ∏è Go to Context](#context)

## **Mathematical Functions**

- Basic math

  ```py
  np.sum(arr)
  np.mean(arr)
  np.min(arr)
  np.max(arr)
  np.std(arr)
  ```

- Axis-wise operations

  ```py
  np.sum(arr2d, axis=0)  # column-wise
  np.sum(arr2d, axis=1)  # row-wise
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Reshaping Arrays**

- Change shape

  ```py
  arr = np.arange(12)
  arr.reshape(3, 4)
  ```

- Flatten array

  ```py
  arr.flatten()
  ```

- Automatic dimension inference

  ```py
  arr.reshape(2, -1)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Broadcasting**

- Add scalar to matrix

  ```py
  arr2d + 10
  ```

- Broadcasting rules (simple idea)

  - Smaller array stretches to match shape
  - Dimensions must be compatible

- Example

  ```py
  mat = np.array([[1, 2, 3]])
  mat + np.array([10, 20, 30])
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Copy vs View**

- View (shares memory)

  ```py
  a = np.array([1, 2, 3])
  b = a[:]
  b[0] = 99
  ```

- Copy (independent)

  ```py
  c = a.copy()
  c[0] = 100
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Sorting & Searching**

- Sort array

  ```py
  np.sort(arr)
  ```

- Argsort (indices)

  ```py
  np.argsort(arr)
  ```

- Where condition

  ```py
  np.where(arr > 10)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Stacking & Splitting**

- Vertical stack

  ```py
  np.vstack([a, b])
  ```

- Horizontal stack

  ```py
  np.hstack([a, b])
  ```

- Split array

  ```py
  np.split(arr, 3)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **Linear Algebra**

- Matrix multiplication

  ```py
  A = np.array([[1, 2], [3, 4]])
  B = np.array([[5, 6], [7, 8]])

  A @ B
  ```

- Transpose

  ```py
  A.T
  ```

- Determinant

  ```py
  np.linalg.det(A)
  ```

- Inverse

  ```py
  np.linalg.inv(A)
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **File I/O with NumPy**

- Save array

  ```py
  np.save("data.npy", arr)
  ```

- Load array

  ```py
  np.load("data.npy")
  ```

- Load CSV

  ```py
  np.loadtxt("data.csv", delimiter=",")
  ```

[‚¨ÜÔ∏è Go to Context](#context)

## **NumPy vs Python Lists**

- Faster numerical computation
- Less memory usage
- Vectorized operations
- Foundation of Pandas, SciPy, Scikit-learn, TensorFlow

[‚¨ÜÔ∏è Go to Context](#context)

## **When to Use NumPy**

- Numerical computation
- Matrix & vector math
- Data preprocessing
- Machine learning foundations
- Scientific computing

[‚¨ÜÔ∏è Go to Context](#context)
